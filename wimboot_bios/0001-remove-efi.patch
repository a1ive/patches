From bd8441a791b831ddd8af69f90bdb1de7f30a1261 Mon Sep 17 00:00:00 2001
From: a1ive <10670106+a1ive@users.noreply.github.com>
Date: Wed, 3 Jun 2020 20:27:45 +0800
Subject: [PATCH] remove efi

---
 src/.gitignore                                |    5 -
 src/Makefile                                  |  121 +-
 src/coverity-model.c                          |   10 -
 src/die.c                                     |   29 +-
 src/efi.c                                     |   34 -
 src/efi.h                                     |   52 -
 src/efi/Base.h                                | 1021 --------
 src/efi/Guid/FileInfo.h                       |   71 -
 src/efi/Guid/HiiFormMapMethodGuid.h           |   25 -
 src/efi/Guid/PcAnsi.h                         |   58 -
 src/efi/Guid/WinCertificate.h                 |  128 -
 src/efi/Ia32/ProcessorBind.h                  |  288 ---
 src/efi/IndustryStandard/PeImage.h            |  756 ------
 src/efi/ProcessorBind.h                       |   19 -
 src/efi/Protocol/BlockIo.h                    |  241 --
 src/efi/Protocol/DevicePath.h                 | 1169 ---------
 src/efi/Protocol/GraphicsOutput.h             |  276 ---
 src/efi/Protocol/LoadedImage.h                |   88 -
 src/efi/Protocol/SimpleFileSystem.h           |  562 -----
 src/efi/Protocol/SimpleTextIn.h               |  134 --
 src/efi/Protocol/SimpleTextInEx.h             |  325 ---
 src/efi/Protocol/SimpleTextOut.h              |  404 ----
 src/efi/Uefi.h                                |   27 -
 src/efi/Uefi/UefiBaseType.h                   |  301 ---
 src/efi/Uefi/UefiGpt.h                        |  141 --
 src/efi/Uefi/UefiInternalFormRepresentation.h | 2106 ----------------
 src/efi/Uefi/UefiMultiPhase.h                 |  193 --
 src/efi/Uefi/UefiPxe.h                        | 1772 --------------
 src/efi/Uefi/UefiSpec.h                       | 2144 -----------------
 src/efi/X64/ProcessorBind.h                   |  294 ---
 src/efi/import.pl                             |  120 -
 src/efiblock.c                                |  307 ---
 src/efiblock.h                                |   38 -
 src/efiboot.c                                 |  157 --
 src/efiboot.h                                 |   38 -
 src/efifile.c                                 |  218 --
 src/efifile.h                                 |   39 -
 src/efiguid.c                                 |   53 -
 src/efimain.c                                 |  101 -
 src/efipath.c                                 |   46 -
 src/efipath.h                                 |   89 -
 src/efireloc.c                                |  548 -----
 src/i386.i                                    |    1 -
 src/prefix.S                                  |  188 +-
 src/script.lds                                |   41 +-
 src/sha1.c                                    |    9 +
 src/stdio.c                                   |   45 +-
 src/vdisk.c                                   |    9 +
 src/wimboot.h                                 |   14 -
 src/wimboot.i386                              |  Bin 27776 -> 0 bytes
 src/wimboot.x86_64                            |  Bin 42752 -> 0 bytes
 src/wimpatch.c                                |    9 +
 src/x86_64.i                                  |    1 -
 53 files changed, 69 insertions(+), 14796 deletions(-)
 delete mode 100644 src/coverity-model.c
 delete mode 100644 src/efi.c
 delete mode 100644 src/efi.h
 delete mode 100644 src/efi/Base.h
 delete mode 100644 src/efi/Guid/FileInfo.h
 delete mode 100644 src/efi/Guid/HiiFormMapMethodGuid.h
 delete mode 100644 src/efi/Guid/PcAnsi.h
 delete mode 100644 src/efi/Guid/WinCertificate.h
 delete mode 100644 src/efi/Ia32/ProcessorBind.h
 delete mode 100644 src/efi/IndustryStandard/PeImage.h
 delete mode 100644 src/efi/ProcessorBind.h
 delete mode 100644 src/efi/Protocol/BlockIo.h
 delete mode 100644 src/efi/Protocol/DevicePath.h
 delete mode 100644 src/efi/Protocol/GraphicsOutput.h
 delete mode 100644 src/efi/Protocol/LoadedImage.h
 delete mode 100644 src/efi/Protocol/SimpleFileSystem.h
 delete mode 100644 src/efi/Protocol/SimpleTextIn.h
 delete mode 100644 src/efi/Protocol/SimpleTextInEx.h
 delete mode 100644 src/efi/Protocol/SimpleTextOut.h
 delete mode 100644 src/efi/Uefi.h
 delete mode 100644 src/efi/Uefi/UefiBaseType.h
 delete mode 100644 src/efi/Uefi/UefiGpt.h
 delete mode 100644 src/efi/Uefi/UefiInternalFormRepresentation.h
 delete mode 100644 src/efi/Uefi/UefiMultiPhase.h
 delete mode 100644 src/efi/Uefi/UefiPxe.h
 delete mode 100644 src/efi/Uefi/UefiSpec.h
 delete mode 100644 src/efi/X64/ProcessorBind.h
 delete mode 100755 src/efi/import.pl
 delete mode 100644 src/efiblock.c
 delete mode 100644 src/efiblock.h
 delete mode 100644 src/efiboot.c
 delete mode 100644 src/efiboot.h
 delete mode 100644 src/efifile.c
 delete mode 100644 src/efifile.h
 delete mode 100644 src/efiguid.c
 delete mode 100644 src/efimain.c
 delete mode 100644 src/efipath.c
 delete mode 100644 src/efipath.h
 delete mode 100644 src/efireloc.c
 delete mode 100644 src/i386.i
 delete mode 100755 src/wimboot.i386
 delete mode 100755 src/wimboot.x86_64
 delete mode 100644 src/x86_64.i

diff --git a/src/.gitignore b/src/.gitignore
index 80c3366..e56abcb 100644
--- a/src/.gitignore
+++ b/src/.gitignore
@@ -3,8 +3,3 @@ wimboot
 *.o
 *.a
 *.elf
-*.map
-*.unsigned
-*.efi
-*.cab
-efireloc
diff --git a/src/Makefile b/src/Makefile
index c0f1f37..c1389a9 100644
--- a/src/Makefile
+++ b/src/Makefile
@@ -1,8 +1,7 @@
 VERSION := v2.6.0
 
 OBJECTS := prefix.o startup.o callback.o main.o vsprintf.o string.o peloader.o
-OBJECTS += int13.o vdisk.o cpio.o stdio.o lznt1.o xca.o die.o efi.o efimain.o
-OBJECTS += efiguid.o efifile.o efipath.o efiboot.o efiblock.o cmdline.o
+OBJECTS += int13.o vdisk.o cpio.o stdio.o lznt1.o xca.o die.o cmdline.o
 OBJECTS += wimpatch.o huffman.o lzx.o wim.o wimfile.o pause.o sha1.o
 
 OBJECTS_i386 := $(patsubst %.o,%.i386.o,$(OBJECTS))
@@ -19,21 +18,15 @@ AR		:= ar
 RANLIB		:= ranlib
 CP		:= cp
 RM		:= rm
-GCAB		:= gcab
-PESIGN		:= pesign
 DIFF		:= diff
 CUT		:= cut
-BINUTILS_DIR	:= /usr
-BFD_DIR		:= $(BINUTILS_DIR)
-ZLIB_DIR	:= /usr
 
 HOST_CFLAGS += -Wall -W -Werror
 
 CFLAGS += -Os -ffreestanding -Wall -W -Werror -nostdinc -I. -fshort-wchar
 CFLAGS += -DVERSION="\"$(VERSION)\""
 
-CFLAGS_i386 += -m32 -march=i386 -malign-double -fno-pic
-CFLAGS_x86_64 += -m64 -mno-red-zone -fpie
+CFLAGS += -m32 -march=i386 -malign-double -fno-pic
 
 # Inhibit -fno-stack-protector
 SP_TEST = $(CC) -fno-stack-protector -x c -c /dev/null \
@@ -50,15 +43,6 @@ CFI_FLAGS := $(shell $(CFI_TEST) && \
 		    '-fno-unwind-tables -fno-asynchronous-unwind-tables')
 WORKAROUND_CFLAGS += $(CFI_FLAGS)
 
-# Add -maccumulate-outgoing-args if required by this version of gcc
-MS_ABI_TEST_CODE := extern void __attribute__ (( ms_abi )) ms_abi(); \
-		    void sysv_abi ( void ) { ms_abi(); }
-MS_ABI_TEST = $(ECHO) '$(MS_ABI_TEST_CODE)' | \
-	      $(CC) -m64 -mno-accumulate-outgoing-args -x c -c - -o /dev/null \
-		    >/dev/null 2>&1
-MS_ABI_FLAGS := $(shell $(MS_ABI_TEST) || $(ECHO) '-maccumulate-outgoing-args')
-WORKAROUND_CFLAGS += $(MS_ABI_FLAGS)
-
 CFLAGS += $(WORKAROUND_CFLAGS)
 CFLAGS += $(EXTRA_CFLAGS)
 
@@ -72,101 +56,20 @@ CFLAGS += -include compiler.h
 #
 # Final targets
 
-all : wimboot wimboot.i386 wimboot.x86_64 wimboot.cab
-
-wimboot : wimboot.x86_64 Makefile
-	$(CP) $< $@
-	$(CP) $@ ../$@
+all : wimboot
 
-wimboot.%.elf : prefix.%.o lib.%.a script.lds Makefile
-	$(LD) -m elf_$* -T script.lds -o $@ -q -Map wimboot.$*.map \
-		prefix.$*.o lib.$*.a
-
-wimboot.%.unsigned : wimboot.%.elf efireloc Makefile
+wimboot : wimboot.elf
 	$(OBJCOPY) -Obinary $< $@
-	./efireloc $< $@
-
-wimboot.%.unsigned.hash : wimboot.%.unsigned Makefile
-	$(PESIGN) -h -i $< | $(CUT) -d" " -f2- > $@
-
-wimboot.%.efi : wimboot.%.unsigned Makefile
-	$(CP) $< $@
-
-wimboot.%.efi.hash : wimboot.%.efi Makefile
-	$(PESIGN) -h -i $< | $(CUT) -d" " -f2- > $@
-
-wimboot.% : wimboot.%.efi wimboot.%.efi.hash wimboot.%.unsigned.hash Makefile
-	$(DIFF) wimboot.$*.efi.hash wimboot.$*.unsigned.hash
-	$(CP) $< $@
-
-wimboot.cab : wimboot.i386.efi wimboot.x86_64.efi Makefile
-	$(GCAB) -n -c $@ wimboot.i386.efi wimboot.x86_64.efi
-
-###############################################################################
-#
-# i386 objects
-
-%.i386.s : %.S $(HEADERS) Makefile
-	$(CC) $(CFLAGS) $(CFLAGS_i386) -DASSEMBLY -Ui386 -E $< -o $@
-
-%.i386.s : %.c $(HEADERS) Makefile
-	$(CC) $(CFLAGS) $(CFLAGS_i386) -S $< -o $@
-
-%.i386.o : %.i386.s i386.i Makefile
-	$(AS) --32 i386.i $< -o $@
-
-lib.i386.a : $(OBJECTS_i386) Makefile
-	$(RM) -f $@
-	$(AR) r $@ $(OBJECTS_i386)
-	$(RANLIB) $@
-
-###############################################################################
-#
-# i386 objects to be linked into an x86_64 binary
-
-%.i386.x86_64.raw.o : %.i386.s i386.i Makefile
-	$(AS) --64 i386.i $< -o $@
-
-%.i386.x86_64.o : %.i386.x86_64.raw.o Makefile
-	$(OBJCOPY) --prefix-symbols=__i386_ $< $@
-
-###############################################################################
-#
-# x86_64 objects
-
-%.x86_64.s : %.S $(HEADERS) Makefile
-	$(CC) $(CFLAGS) $(CFLAGS_x86_64) -DASSEMBLY -Ui386 -E $< -o $@
+	cp $@ ../$@
 
-%.x86_64.s : %.c $(HEADERS) Makefile
-	$(CC) $(CFLAGS) $(CFLAGS_x86_64) -S $< -o $@
+wimboot.elf : $(OBJECTS) script.lds
+	$(LD) -m elf_i386 -T script.lds -o $@ $(OBJECTS)
 
-%.x86_64.o : %.x86_64.s x86_64.i Makefile
-	$(AS) --64 x86_64.i $< -o $@
+%.o : %.S $(HEADERS) Makefile
+	$(CC) $(CFLAGS) -DASSEMBLY -Ui386 -E $< | as --32 -o $@
 
-lib.x86_64.a : $(OBJECTS_x86_64) $(OBJECTS_i386_x86_64) Makefile
-	$(RM) -f $@
-	$(AR) r $@ $(OBJECTS_x86_64) $(OBJECTS_i386_x86_64)
-	$(RANLIB) $@
-
-###############################################################################
-#
-# EFI relocator
-
-EFIRELOC_CFLAGS := -I$(BINUTILS_DIR)/include -I$(BFD_DIR)/include \
-		   -I$(ZLIB_DIR)/include -idirafter .
-EFIRELOC_LDFLAGS := -L$(BINUTILS_DIR)/lib -L$(BFD_DIR)/lib -L$(ZLIB_DIR)/lib \
-		    -lbfd -ldl -liberty -lz -Wl,--no-warn-search-mismatch
-
-efireloc : efireloc.c Makefile
-	$(CC) $(HOST_CFLAGS) $(EFIRELOC_CFLAGS) $< $(EFIRELOC_LDFLAGS) -o $@
-
-###############################################################################
-#
-# Cleanup
+%.o : %.c $(HEADERS) Makefile
+	$(CC) $(CFLAGS) -c $< -o $@
 
 clean :
-	$(RM) -f *.s *.o *.a *.elf
-	$(RM) -f efireloc
-	$(RM) -f wimboot wimboot.i386 wimboot.x86_64 ../wimboot
-	$(RM) -f wimboot.i386.unsigned wimboot.x86_64.unsigned
-	$(RM) -f wimboot.i386.efi wimboot.x86_64.efi wimboot.cab
+	rm -f *.o *.elf wimboot ../wimboot
diff --git a/src/coverity-model.c b/src/coverity-model.c
deleted file mode 100644
index e65ecfd..0000000
--- a/src/coverity-model.c
+++ /dev/null
@@ -1,10 +0,0 @@
-/*
- * Coverity modelling file
- *
- */
-
-/* Inhibit use of built-in models for functions where Coverity's
- * assumptions about the modelled function are incorrect for wimboot.
- */
-int getchar ( void ) {
-}
diff --git a/src/die.c b/src/die.c
index 54e287e..7833b84 100644
--- a/src/die.c
+++ b/src/die.c
@@ -27,7 +27,6 @@
 #include <stdarg.h>
 #include <stdio.h>
 #include "wimboot.h"
-#include "efi.h"
 
 /**
  * Handle fatal errors
@@ -36,8 +35,6 @@
  * @v ...	Arguments
  */
 void die ( const char *fmt, ... ) {
-	EFI_BOOT_SERVICES *bs;
-	EFI_RUNTIME_SERVICES *rs;
 	va_list args;
 
 	/* Print message */
@@ -45,27 +42,13 @@ void die ( const char *fmt, ... ) {
 	vprintf ( fmt, args );
 	va_end ( args );
 
-	/* Reboot or exit as applicable */
-	if ( efi_systab ) {
+	/* Wait for keypress */
+	printf ( "Press a key to reboot..." );
+	getchar();
+	printf ( "\n" );
 
-		/* Exit */
-		bs = efi_systab->BootServices;
-		bs->Exit ( efi_image_handle, EFI_LOAD_ERROR, 0, NULL );
-		printf ( "Failed to exit\n" );
-		rs = efi_systab->RuntimeServices;
-		rs->ResetSystem ( EfiResetWarm, 0, 0, NULL );
-		printf ( "Failed to reboot\n" );
-
-	} else {
-
-		/* Wait for keypress */
-		printf ( "Press a key to reboot..." );
-		getchar();
-		printf ( "\n" );
-
-		/* Reboot system */
-		reboot();
-	}
+	/* Reboot system */
+	reboot();
 
 	/* Should be impossible to reach this */
 	__builtin_unreachable();
diff --git a/src/efi.c b/src/efi.c
deleted file mode 100644
index 1be33e9..0000000
--- a/src/efi.c
+++ /dev/null
@@ -1,34 +0,0 @@
-/*
- * Copyright (C) 2014 Michael Brown <mbrown@fensystems.co.uk>.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of the
- * License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
- * 02110-1301, USA.
- */
-
-/**
- * @file
- *
- * EFI interface
- *
- */
-
-#include "wimboot.h"
-#include "efi.h"
-
-/** EFI system table */
-EFI_SYSTEM_TABLE *efi_systab;
-
-/** EFI image handle */
-EFI_HANDLE efi_image_handle;
diff --git a/src/efi.h b/src/efi.h
deleted file mode 100644
index afc7c42..0000000
--- a/src/efi.h
+++ /dev/null
@@ -1,52 +0,0 @@
-#ifndef _EFI_H
-#define _EFI_H
-
-/*
- * Copyright (C) 2014 Michael Brown <mbrown@fensystems.co.uk>.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of the
- * License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
- * 02110-1301, USA.
- */
-
-/**
- * @file
- *
- * EFI definitions
- *
- */
-
-/* EFIAPI definition */
-#if __x86_64__
-#define EFIAPI __attribute__ (( ms_abi ))
-#else
-#define EFIAPI
-#endif
-
-/* EFI headers rudely redefine NULL */
-#undef NULL
-
-#include "efi/Uefi.h"
-#include "efi/Protocol/LoadedImage.h"
-
-extern EFI_SYSTEM_TABLE *efi_systab;
-extern EFI_HANDLE efi_image_handle;
-
-extern EFI_GUID efi_block_io_protocol_guid;
-extern EFI_GUID efi_device_path_protocol_guid;
-extern EFI_GUID efi_graphics_output_protocol_guid;
-extern EFI_GUID efi_loaded_image_protocol_guid;
-extern EFI_GUID efi_simple_file_system_protocol_guid;
-
-#endif /* _EFI_H */
diff --git a/src/efi/Base.h b/src/efi/Base.h
deleted file mode 100644
index 488f0ef..0000000
--- a/src/efi/Base.h
+++ /dev/null
@@ -1,1021 +0,0 @@
-/** @file
-  Root include file for Mde Package Base type modules
-
-  This is the include file for any module of type base. Base modules only use
-  types defined via this include file and can be ported easily to any
-  environment. There are a set of base libraries in the Mde Package that can
-  be used to implement base modules.
-
-Copyright (c) 2006 - 2013, Intel Corporation. All rights reserved.<BR>
-Portions copyright (c) 2008 - 2009, Apple Inc. All rights reserved.<BR>
-This program and the accompanying materials
-are licensed and made available under the terms and conditions of the BSD License
-which accompanies this distribution.  The full text of the license may be found at
-http://opensource.org/licenses/bsd-license.php.
-
-THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
-WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
-
-**/
-
-
-#ifndef __BASE_H__
-#define __BASE_H__
-
-//
-// Include processor specific binding
-//
-#include "efi/ProcessorBind.h"
-
-
-/**
-  Verifies the storage size of a given data type.
-
-  This macro generates a divide by zero error or a zero size array declaration in
-  the preprocessor if the size is incorrect.  These are declared as "extern" so
-  the space for these arrays will not be in the modules.
-
-  @param  TYPE  The date type to determine the size of.
-  @param  Size  The expected size for the TYPE.
-
-**/
-#define VERIFY_SIZE_OF(TYPE, Size) extern UINT8 _VerifySizeof##TYPE[(sizeof(TYPE) == (Size)) / (sizeof(TYPE) == (Size))]
-
-//
-// Verify that ProcessorBind.h produced UEFI Data Types that are compliant with
-// Section 2.3.1 of the UEFI 2.3 Specification.
-//
-VERIFY_SIZE_OF (BOOLEAN, 1);
-VERIFY_SIZE_OF (INT8, 1);
-VERIFY_SIZE_OF (UINT8, 1);
-VERIFY_SIZE_OF (INT16, 2);
-VERIFY_SIZE_OF (UINT16, 2);
-VERIFY_SIZE_OF (INT32, 4);
-VERIFY_SIZE_OF (UINT32, 4);
-VERIFY_SIZE_OF (INT64, 8);
-VERIFY_SIZE_OF (UINT64, 8);
-VERIFY_SIZE_OF (CHAR8, 1);
-VERIFY_SIZE_OF (CHAR16, 2);
-
-//
-// The Microsoft* C compiler can removed references to unreferenced data items
-//  if the /OPT:REF linker option is used. We defined a macro as this is a
-//  a non standard extension
-//
-#if defined(_MSC_EXTENSIONS) && !defined (MDE_CPU_EBC)
-  ///
-  /// Remove global variable from the linked image if there are no references to
-  /// it after all compiler and linker optimizations have been performed.
-  ///
-  ///
-  #define GLOBAL_REMOVE_IF_UNREFERENCED __declspec(selectany)
-#else
-  ///
-  /// Remove the global variable from the linked image if there are no references
-  ///  to it after all compiler and linker optimizations have been performed.
-  ///
-  ///
-  #define GLOBAL_REMOVE_IF_UNREFERENCED
-#endif
-
-//
-// For symbol name in GNU assembly code, an extra "_" is necessary
-//
-#if defined(__GNUC__)
-  ///
-  /// Private worker functions for ASM_PFX()
-  ///
-  #define _CONCATENATE(a, b)  __CONCATENATE(a, b)
-  #define __CONCATENATE(a, b) a ## b
-
-  ///
-  /// The __USER_LABEL_PREFIX__ macro predefined by GNUC represents the prefix
-  /// on symbols in assembly language.
-  ///
-  #define ASM_PFX(name) _CONCATENATE (__USER_LABEL_PREFIX__, name)
-#endif
-
-#if __APPLE__
-  //
-  // Apple extension that is used by the linker to optimize code size
-  // with assembly functions. Put at the end of your .S files
-  //
-  #define ASM_FUNCTION_REMOVE_IF_UNREFERENCED  .subsections_via_symbols
-#else
-  #define ASM_FUNCTION_REMOVE_IF_UNREFERENCED
-#endif
-
-#ifdef __CC_ARM
-  //
-  // Older RVCT ARM compilers don't fully support #pragma pack and require __packed
-  // as a prefix for the structure.
-  //
-  #define PACKED  __packed
-#else
-  #define PACKED
-#endif
-
-///
-/// 128 bit buffer containing a unique identifier value.
-/// Unless otherwise specified, aligned on a 64 bit boundary.
-///
-typedef struct {
-  UINT32  Data1;
-  UINT16  Data2;
-  UINT16  Data3;
-  UINT8   Data4[8];
-} GUID;
-
-//
-// 8-bytes unsigned value that represents a physical system address.
-//
-typedef UINT64 PHYSICAL_ADDRESS;
-
-///
-/// LIST_ENTRY structure definition.
-///
-typedef struct _LIST_ENTRY LIST_ENTRY;
-
-///
-/// _LIST_ENTRY structure definition.
-///
-struct _LIST_ENTRY {
-  LIST_ENTRY  *ForwardLink;
-  LIST_ENTRY  *BackLink;
-};
-
-//
-// Modifiers to abstract standard types to aid in debug of problems
-//
-
-///
-/// Datum is read-only.
-///
-#define CONST     const
-
-///
-/// Datum is scoped to the current file or function.
-///
-#define STATIC    static
-
-///
-/// Undeclared type.
-///
-#define VOID      void
-
-//
-// Modifiers for Data Types used to self document code.
-// This concept is borrowed for UEFI specification.
-//
-
-///
-/// Datum is passed to the function.
-///
-#define IN
-
-///
-/// Datum is returned from the function.
-///
-#define OUT
-
-///
-/// Passing the datum to the function is optional, and a NULL
-/// is passed if the value is not supplied.
-///
-#define OPTIONAL
-
-//
-//  UEFI specification claims 1 and 0. We are concerned about the
-//  complier portability so we did it this way.
-//
-
-///
-/// Boolean true value.  UEFI Specification defines this value to be 1,
-/// but this form is more portable.
-///
-#define TRUE  ((BOOLEAN)(1==1))
-
-///
-/// Boolean false value.  UEFI Specification defines this value to be 0,
-/// but this form is more portable.
-///
-#define FALSE ((BOOLEAN)(0==1))
-
-///
-/// NULL pointer (VOID *)
-///
-#define NULL  ((VOID *) 0)
-
-///
-/// Maximum values for common UEFI Data Types
-///
-#define MAX_INT8    ((INT8)0x7F)
-#define MAX_UINT8   ((UINT8)0xFF)
-#define MAX_INT16   ((INT16)0x7FFF)
-#define MAX_UINT16  ((UINT16)0xFFFF)
-#define MAX_INT32   ((INT32)0x7FFFFFFF)
-#define MAX_UINT32  ((UINT32)0xFFFFFFFF)
-#define MAX_INT64   ((INT64)0x7FFFFFFFFFFFFFFFULL)
-#define MAX_UINT64  ((UINT64)0xFFFFFFFFFFFFFFFFULL)
-
-#define  BIT0     0x00000001
-#define  BIT1     0x00000002
-#define  BIT2     0x00000004
-#define  BIT3     0x00000008
-#define  BIT4     0x00000010
-#define  BIT5     0x00000020
-#define  BIT6     0x00000040
-#define  BIT7     0x00000080
-#define  BIT8     0x00000100
-#define  BIT9     0x00000200
-#define  BIT10    0x00000400
-#define  BIT11    0x00000800
-#define  BIT12    0x00001000
-#define  BIT13    0x00002000
-#define  BIT14    0x00004000
-#define  BIT15    0x00008000
-#define  BIT16    0x00010000
-#define  BIT17    0x00020000
-#define  BIT18    0x00040000
-#define  BIT19    0x00080000
-#define  BIT20    0x00100000
-#define  BIT21    0x00200000
-#define  BIT22    0x00400000
-#define  BIT23    0x00800000
-#define  BIT24    0x01000000
-#define  BIT25    0x02000000
-#define  BIT26    0x04000000
-#define  BIT27    0x08000000
-#define  BIT28    0x10000000
-#define  BIT29    0x20000000
-#define  BIT30    0x40000000
-#define  BIT31    0x80000000
-#define  BIT32    0x0000000100000000ULL
-#define  BIT33    0x0000000200000000ULL
-#define  BIT34    0x0000000400000000ULL
-#define  BIT35    0x0000000800000000ULL
-#define  BIT36    0x0000001000000000ULL
-#define  BIT37    0x0000002000000000ULL
-#define  BIT38    0x0000004000000000ULL
-#define  BIT39    0x0000008000000000ULL
-#define  BIT40    0x0000010000000000ULL
-#define  BIT41    0x0000020000000000ULL
-#define  BIT42    0x0000040000000000ULL
-#define  BIT43    0x0000080000000000ULL
-#define  BIT44    0x0000100000000000ULL
-#define  BIT45    0x0000200000000000ULL
-#define  BIT46    0x0000400000000000ULL
-#define  BIT47    0x0000800000000000ULL
-#define  BIT48    0x0001000000000000ULL
-#define  BIT49    0x0002000000000000ULL
-#define  BIT50    0x0004000000000000ULL
-#define  BIT51    0x0008000000000000ULL
-#define  BIT52    0x0010000000000000ULL
-#define  BIT53    0x0020000000000000ULL
-#define  BIT54    0x0040000000000000ULL
-#define  BIT55    0x0080000000000000ULL
-#define  BIT56    0x0100000000000000ULL
-#define  BIT57    0x0200000000000000ULL
-#define  BIT58    0x0400000000000000ULL
-#define  BIT59    0x0800000000000000ULL
-#define  BIT60    0x1000000000000000ULL
-#define  BIT61    0x2000000000000000ULL
-#define  BIT62    0x4000000000000000ULL
-#define  BIT63    0x8000000000000000ULL
-
-#define  SIZE_1KB    0x00000400
-#define  SIZE_2KB    0x00000800
-#define  SIZE_4KB    0x00001000
-#define  SIZE_8KB    0x00002000
-#define  SIZE_16KB   0x00004000
-#define  SIZE_32KB   0x00008000
-#define  SIZE_64KB   0x00010000
-#define  SIZE_128KB  0x00020000
-#define  SIZE_256KB  0x00040000
-#define  SIZE_512KB  0x00080000
-#define  SIZE_1MB    0x00100000
-#define  SIZE_2MB    0x00200000
-#define  SIZE_4MB    0x00400000
-#define  SIZE_8MB    0x00800000
-#define  SIZE_16MB   0x01000000
-#define  SIZE_32MB   0x02000000
-#define  SIZE_64MB   0x04000000
-#define  SIZE_128MB  0x08000000
-#define  SIZE_256MB  0x10000000
-#define  SIZE_512MB  0x20000000
-#define  SIZE_1GB    0x40000000
-#define  SIZE_2GB    0x80000000
-#define  SIZE_4GB    0x0000000100000000ULL
-#define  SIZE_8GB    0x0000000200000000ULL
-#define  SIZE_16GB   0x0000000400000000ULL
-#define  SIZE_32GB   0x0000000800000000ULL
-#define  SIZE_64GB   0x0000001000000000ULL
-#define  SIZE_128GB  0x0000002000000000ULL
-#define  SIZE_256GB  0x0000004000000000ULL
-#define  SIZE_512GB  0x0000008000000000ULL
-#define  SIZE_1TB    0x0000010000000000ULL
-#define  SIZE_2TB    0x0000020000000000ULL
-#define  SIZE_4TB    0x0000040000000000ULL
-#define  SIZE_8TB    0x0000080000000000ULL
-#define  SIZE_16TB   0x0000100000000000ULL
-#define  SIZE_32TB   0x0000200000000000ULL
-#define  SIZE_64TB   0x0000400000000000ULL
-#define  SIZE_128TB  0x0000800000000000ULL
-#define  SIZE_256TB  0x0001000000000000ULL
-#define  SIZE_512TB  0x0002000000000000ULL
-#define  SIZE_1PB    0x0004000000000000ULL
-#define  SIZE_2PB    0x0008000000000000ULL
-#define  SIZE_4PB    0x0010000000000000ULL
-#define  SIZE_8PB    0x0020000000000000ULL
-#define  SIZE_16PB   0x0040000000000000ULL
-#define  SIZE_32PB   0x0080000000000000ULL
-#define  SIZE_64PB   0x0100000000000000ULL
-#define  SIZE_128PB  0x0200000000000000ULL
-#define  SIZE_256PB  0x0400000000000000ULL
-#define  SIZE_512PB  0x0800000000000000ULL
-#define  SIZE_1EB    0x1000000000000000ULL
-#define  SIZE_2EB    0x2000000000000000ULL
-#define  SIZE_4EB    0x4000000000000000ULL
-#define  SIZE_8EB    0x8000000000000000ULL
-
-#define  BASE_1KB    0x00000400
-#define  BASE_2KB    0x00000800
-#define  BASE_4KB    0x00001000
-#define  BASE_8KB    0x00002000
-#define  BASE_16KB   0x00004000
-#define  BASE_32KB   0x00008000
-#define  BASE_64KB   0x00010000
-#define  BASE_128KB  0x00020000
-#define  BASE_256KB  0x00040000
-#define  BASE_512KB  0x00080000
-#define  BASE_1MB    0x00100000
-#define  BASE_2MB    0x00200000
-#define  BASE_4MB    0x00400000
-#define  BASE_8MB    0x00800000
-#define  BASE_16MB   0x01000000
-#define  BASE_32MB   0x02000000
-#define  BASE_64MB   0x04000000
-#define  BASE_128MB  0x08000000
-#define  BASE_256MB  0x10000000
-#define  BASE_512MB  0x20000000
-#define  BASE_1GB    0x40000000
-#define  BASE_2GB    0x80000000
-#define  BASE_4GB    0x0000000100000000ULL
-#define  BASE_8GB    0x0000000200000000ULL
-#define  BASE_16GB   0x0000000400000000ULL
-#define  BASE_32GB   0x0000000800000000ULL
-#define  BASE_64GB   0x0000001000000000ULL
-#define  BASE_128GB  0x0000002000000000ULL
-#define  BASE_256GB  0x0000004000000000ULL
-#define  BASE_512GB  0x0000008000000000ULL
-#define  BASE_1TB    0x0000010000000000ULL
-#define  BASE_2TB    0x0000020000000000ULL
-#define  BASE_4TB    0x0000040000000000ULL
-#define  BASE_8TB    0x0000080000000000ULL
-#define  BASE_16TB   0x0000100000000000ULL
-#define  BASE_32TB   0x0000200000000000ULL
-#define  BASE_64TB   0x0000400000000000ULL
-#define  BASE_128TB  0x0000800000000000ULL
-#define  BASE_256TB  0x0001000000000000ULL
-#define  BASE_512TB  0x0002000000000000ULL
-#define  BASE_1PB    0x0004000000000000ULL
-#define  BASE_2PB    0x0008000000000000ULL
-#define  BASE_4PB    0x0010000000000000ULL
-#define  BASE_8PB    0x0020000000000000ULL
-#define  BASE_16PB   0x0040000000000000ULL
-#define  BASE_32PB   0x0080000000000000ULL
-#define  BASE_64PB   0x0100000000000000ULL
-#define  BASE_128PB  0x0200000000000000ULL
-#define  BASE_256PB  0x0400000000000000ULL
-#define  BASE_512PB  0x0800000000000000ULL
-#define  BASE_1EB    0x1000000000000000ULL
-#define  BASE_2EB    0x2000000000000000ULL
-#define  BASE_4EB    0x4000000000000000ULL
-#define  BASE_8EB    0x8000000000000000ULL
-
-//
-//  Support for variable length argument lists using the ANSI standard.
-//
-//  Since we are using the ANSI standard we used the standard naming and
-//  did not follow the coding convention
-//
-//  VA_LIST  - typedef for argument list.
-//  VA_START (VA_LIST Marker, argument before the ...) - Init Marker for use.
-//  VA_END (VA_LIST Marker) - Clear Marker
-//  VA_ARG (VA_LIST Marker, var arg size) - Use Marker to get an argument from
-//    the ... list. You must know the size and pass it in this macro.
-//  VA_COPY (VA_LIST Dest, VA_LIST Start) - Initialize Dest as a copy of Start.
-//
-//  example:
-//
-//  UINTN
-//  ExampleVarArg (
-//    IN UINTN  NumberOfArgs,
-//    ...
-//    )
-//  {
-//    VA_LIST Marker;
-//    UINTN   Index;
-//    UINTN   Result;
-//
-//    //
-//    // Initialize the Marker
-//    //
-//    VA_START (Marker, NumberOfArgs);
-//    for (Index = 0, Result = 0; Index < NumberOfArgs; Index++) {
-//      //
-//      // The ... list is a series of UINTN values, so average them up.
-//      //
-//      Result += VA_ARG (Marker, UINTN);
-//    }
-//
-//    VA_END (Marker);
-//    return Result
-//  }
-//
-
-/**
-  Return the size of argument that has been aligned to sizeof (UINTN).
-
-  @param  n    The parameter size to be aligned.
-
-  @return The aligned size.
-**/
-#define _INT_SIZE_OF(n) ((sizeof (n) + sizeof (UINTN) - 1) &~(sizeof (UINTN) - 1))
-
-#if defined(__CC_ARM)
-//
-// RVCT ARM variable argument list support.
-//
-
-///
-/// Variable used to traverse the list of arguments. This type can vary by
-/// implementation and could be an array or structure.
-///
-#ifdef __APCS_ADSABI
-  typedef int         *va_list[1];
-  #define VA_LIST     va_list
-#else
-  typedef struct __va_list { void *__ap; } va_list;
-  #define VA_LIST                          va_list
-#endif
-
-#define VA_START(Marker, Parameter)   __va_start(Marker, Parameter)
-
-#define VA_ARG(Marker, TYPE)          __va_arg(Marker, TYPE)
-
-#define VA_END(Marker)                ((void)0)
-
-// For some ARM RVCT compilers, __va_copy is not defined
-#ifndef __va_copy
-  #define __va_copy(dest, src) ((void)((dest) = (src)))
-#endif
-
-#define VA_COPY(Dest, Start)          __va_copy (Dest, Start)
-
-#elif defined(__GNUC__) && !defined(NO_BUILTIN_VA_FUNCS)
-//
-// Use GCC built-in macros for variable argument lists.
-//
-
-///
-/// Variable used to traverse the list of arguments. This type can vary by
-/// implementation and could be an array or structure.
-///
-typedef __builtin_va_list VA_LIST;
-
-#define VA_START(Marker, Parameter)  __builtin_va_start (Marker, Parameter)
-
-#define VA_ARG(Marker, TYPE)         ((sizeof (TYPE) < sizeof (UINTN)) ? (TYPE)(__builtin_va_arg (Marker, UINTN)) : (TYPE)(__builtin_va_arg (Marker, TYPE)))
-
-#define VA_END(Marker)               __builtin_va_end (Marker)
-
-#define VA_COPY(Dest, Start)         __builtin_va_copy (Dest, Start)
-
-#else
-///
-/// Variable used to traverse the list of arguments. This type can vary by
-/// implementation and could be an array or structure.
-///
-typedef CHAR8 *VA_LIST;
-
-/**
-  Retrieves a pointer to the beginning of a variable argument list, based on
-  the name of the parameter that immediately precedes the variable argument list.
-
-  This function initializes Marker to point to the beginning of the variable
-  argument list that immediately follows Parameter.  The method for computing the
-  pointer to the next argument in the argument list is CPU-specific following the
-  EFIAPI ABI.
-
-  @param   Marker       The VA_LIST used to traverse the list of arguments.
-  @param   Parameter    The name of the parameter that immediately precedes
-                        the variable argument list.
-
-  @return  A pointer to the beginning of a variable argument list.
-
-**/
-#define VA_START(Marker, Parameter) (Marker = (VA_LIST) ((UINTN) & (Parameter) + _INT_SIZE_OF (Parameter)))
-
-/**
-  Returns an argument of a specified type from a variable argument list and updates
-  the pointer to the variable argument list to point to the next argument.
-
-  This function returns an argument of the type specified by TYPE from the beginning
-  of the variable argument list specified by Marker.  Marker is then updated to point
-  to the next argument in the variable argument list.  The method for computing the
-  pointer to the next argument in the argument list is CPU-specific following the EFIAPI ABI.
-
-  @param   Marker   VA_LIST used to traverse the list of arguments.
-  @param   TYPE     The type of argument to retrieve from the beginning
-                    of the variable argument list.
-
-  @return  An argument of the type specified by TYPE.
-
-**/
-#define VA_ARG(Marker, TYPE)   (*(TYPE *) ((Marker += _INT_SIZE_OF (TYPE)) - _INT_SIZE_OF (TYPE)))
-
-/**
-  Terminates the use of a variable argument list.
-
-  This function initializes Marker so it can no longer be used with VA_ARG().
-  After this macro is used, the only way to access the variable argument list is
-  by using VA_START() again.
-
-  @param   Marker   VA_LIST used to traverse the list of arguments.
-
-**/
-#define VA_END(Marker)      (Marker = (VA_LIST) 0)
-
-/**
-  Initializes a VA_LIST as a copy of an existing VA_LIST.
-
-  This macro initializes Dest as a copy of Start, as if the VA_START macro had been applied to Dest
-  followed by the same sequence of uses of the VA_ARG macro as had previously been used to reach
-  the present state of Start.
-
-  @param   Dest   VA_LIST used to traverse the list of arguments.
-  @param   Start  VA_LIST used to traverse the list of arguments.
-
-**/
-#define VA_COPY(Dest, Start)  ((void)((Dest) = (Start)))
-
-#endif
-
-///
-/// Pointer to the start of a variable argument list stored in a memory buffer. Same as UINT8 *.
-///
-typedef UINTN  *BASE_LIST;
-
-/**
-  Returns the size of a data type in sizeof(UINTN) units rounded up to the nearest UINTN boundary.
-
-  @param  TYPE  The date type to determine the size of.
-
-  @return The size of TYPE in sizeof (UINTN) units rounded up to the nearest UINTN boundary.
-**/
-#define _BASE_INT_SIZE_OF(TYPE) ((sizeof (TYPE) + sizeof (UINTN) - 1) / sizeof (UINTN))
-
-/**
-  Returns an argument of a specified type from a variable argument list and updates
-  the pointer to the variable argument list to point to the next argument.
-
-  This function returns an argument of the type specified by TYPE from the beginning
-  of the variable argument list specified by Marker.  Marker is then updated to point
-  to the next argument in the variable argument list.  The method for computing the
-  pointer to the next argument in the argument list is CPU specific following the EFIAPI ABI.
-
-  @param   Marker   The pointer to the beginning of a variable argument list.
-  @param   TYPE     The type of argument to retrieve from the beginning
-                    of the variable argument list.
-
-  @return  An argument of the type specified by TYPE.
-
-**/
-#define BASE_ARG(Marker, TYPE)   (*(TYPE *) ((Marker += _BASE_INT_SIZE_OF (TYPE)) - _BASE_INT_SIZE_OF (TYPE)))
-
-/**
-  The macro that returns the byte offset of a field in a data structure.
-
-  This function returns the offset, in bytes, of field specified by Field from the
-  beginning of the  data structure specified by TYPE. If TYPE does not contain Field,
-  the module will not compile.
-
-  @param   TYPE     The name of the data structure that contains the field specified by Field.
-  @param   Field    The name of the field in the data structure.
-
-  @return  Offset, in bytes, of field.
-
-**/
-#ifdef __GNUC__
-#if __GNUC__ >= 4
-#define OFFSET_OF(TYPE, Field) ((UINTN) __builtin_offsetof(TYPE, Field))
-#endif
-#endif
-
-#ifndef OFFSET_OF
-#define OFFSET_OF(TYPE, Field) ((UINTN) &(((TYPE *)0)->Field))
-#endif
-
-/**
-  Macro that returns a pointer to the data structure that contains a specified field of
-  that data structure.  This is a lightweight method to hide information by placing a
-  public data structure inside a larger private data structure and using a pointer to
-  the public data structure to retrieve a pointer to the private data structure.
-
-  This function computes the offset, in bytes, of field specified by Field from the beginning
-  of the  data structure specified by TYPE.  This offset is subtracted from Record, and is
-  used to return a pointer to a data structure of the type specified by TYPE. If the data type
-  specified by TYPE does not contain the field specified by Field, then the module will not compile.
-
-  @param   Record   Pointer to the field specified by Field within a data structure of type TYPE.
-  @param   TYPE     The name of the data structure type to return.  This data structure must
-                    contain the field specified by Field.
-  @param   Field    The name of the field in the data structure specified by TYPE to which Record points.
-
-  @return  A pointer to the structure from one of it's elements.
-
-**/
-#define BASE_CR(Record, TYPE, Field)  ((TYPE *) ((CHAR8 *) (Record) - (CHAR8 *) &(((TYPE *) 0)->Field)))
-
-/**
-  Rounds a value up to the next boundary using a specified alignment.
-
-  This function rounds Value up to the next boundary using the specified Alignment.
-  This aligned value is returned.
-
-  @param   Value      The value to round up.
-  @param   Alignment  The alignment boundary used to return the aligned value.
-
-  @return  A value up to the next boundary.
-
-**/
-#define ALIGN_VALUE(Value, Alignment) ((Value) + (((Alignment) - (Value)) & ((Alignment) - 1)))
-
-/**
-  Adjust a pointer by adding the minimum offset required for it to be aligned on
-  a specified alignment boundary.
-
-  This function rounds the pointer specified by Pointer to the next alignment boundary
-  specified by Alignment. The pointer to the aligned address is returned.
-
-  @param   Pointer    The pointer to round up.
-  @param   Alignment  The alignment boundary to use to return an aligned pointer.
-
-  @return  Pointer to the aligned address.
-
-**/
-#define ALIGN_POINTER(Pointer, Alignment) ((VOID *) (ALIGN_VALUE ((UINTN)(Pointer), (Alignment))))
-
-/**
-  Rounds a value up to the next natural boundary for the current CPU.
-  This is 4-bytes for 32-bit CPUs and 8-bytes for 64-bit CPUs.
-
-  This function rounds the value specified by Value up to the next natural boundary for the
-  current CPU. This rounded value is returned.
-
-  @param   Value      The value to round up.
-
-  @return  Rounded value specified by Value.
-
-**/
-#define ALIGN_VARIABLE(Value)  ALIGN_VALUE ((Value), sizeof (UINTN))
-
-
-/**
-  Return the maximum of two operands.
-
-  This macro returns the maximum of two operand specified by a and b.
-  Both a and b must be the same numerical types, signed or unsigned.
-
-  @param   a        The first operand with any numerical type.
-  @param   b        The second operand. Can be any numerical type as long as is
-                    the same type as a.
-
-  @return  Maximum of two operands.
-
-**/
-#define MAX(a, b)                       \
-  (((a) > (b)) ? (a) : (b))
-
-/**
-  Return the minimum of two operands.
-
-  This macro returns the minimal of two operand specified by a and b.
-  Both a and b must be the same numerical types, signed or unsigned.
-
-  @param   a        The first operand with any numerical type.
-  @param   b        The second operand. It should be the same any numerical type with a.
-
-  @return  Minimum of two operands.
-
-**/
-#define MIN(a, b)                       \
-  (((a) < (b)) ? (a) : (b))
-
-/**
-  Return the absolute value of a signed operand.
-
-  This macro returns the absolute value of the signed operand specified by a.
-
-  @param   a        The signed operand.
-
-  @return  The absolute value of the signed operand.
-
-**/
-#define ABS(a)                          \
-  (((a) < 0) ? (-(a)) : (a))
-
-//
-// Status codes common to all execution phases
-//
-typedef UINTN RETURN_STATUS;
-
-/**
-  Produces a RETURN_STATUS code with the highest bit set.
-
-  @param  StatusCode    The status code value to convert into a warning code.
-                        StatusCode must be in the range 0x00000000..0x7FFFFFFF.
-
-  @return The value specified by StatusCode with the highest bit set.
-
-**/
-#define ENCODE_ERROR(StatusCode)     ((RETURN_STATUS)(MAX_BIT | (StatusCode)))
-
-/**
-  Produces a RETURN_STATUS code with the highest bit clear.
-
-  @param  StatusCode    The status code value to convert into a warning code.
-                        StatusCode must be in the range 0x00000000..0x7FFFFFFF.
-
-  @return The value specified by StatusCode with the highest bit clear.
-
-**/
-#define ENCODE_WARNING(StatusCode)   ((RETURN_STATUS)(StatusCode))
-
-/**
-  Returns TRUE if a specified RETURN_STATUS code is an error code.
-
-  This function returns TRUE if StatusCode has the high bit set.  Otherwise, FALSE is returned.
-
-  @param  StatusCode    The status code value to evaluate.
-
-  @retval TRUE          The high bit of StatusCode is set.
-  @retval FALSE         The high bit of StatusCode is clear.
-
-**/
-#define RETURN_ERROR(StatusCode)     (((INTN)(RETURN_STATUS)(StatusCode)) < 0)
-
-///
-/// The operation completed successfully.
-///
-#define RETURN_SUCCESS               0
-
-///
-/// The image failed to load.
-///
-#define RETURN_LOAD_ERROR            ENCODE_ERROR (1)
-
-///
-/// The parameter was incorrect.
-///
-#define RETURN_INVALID_PARAMETER     ENCODE_ERROR (2)
-
-///
-/// The operation is not supported.
-///
-#define RETURN_UNSUPPORTED           ENCODE_ERROR (3)
-
-///
-/// The buffer was not the proper size for the request.
-///
-#define RETURN_BAD_BUFFER_SIZE       ENCODE_ERROR (4)
-
-///
-/// The buffer was not large enough to hold the requested data.
-/// The required buffer size is returned in the appropriate
-/// parameter when this error occurs.
-///
-#define RETURN_BUFFER_TOO_SMALL      ENCODE_ERROR (5)
-
-///
-/// There is no data pending upon return.
-///
-#define RETURN_NOT_READY             ENCODE_ERROR (6)
-
-///
-/// The physical device reported an error while attempting the
-/// operation.
-///
-#define RETURN_DEVICE_ERROR          ENCODE_ERROR (7)
-
-///
-/// The device can not be written to.
-///
-#define RETURN_WRITE_PROTECTED       ENCODE_ERROR (8)
-
-///
-/// The resource has run out.
-///
-#define RETURN_OUT_OF_RESOURCES      ENCODE_ERROR (9)
-
-///
-/// An inconsistency was detected on the file system causing the
-/// operation to fail.
-///
-#define RETURN_VOLUME_CORRUPTED      ENCODE_ERROR (10)
-
-///
-/// There is no more space on the file system.
-///
-#define RETURN_VOLUME_FULL           ENCODE_ERROR (11)
-
-///
-/// The device does not contain any medium to perform the
-/// operation.
-///
-#define RETURN_NO_MEDIA              ENCODE_ERROR (12)
-
-///
-/// The medium in the device has changed since the last
-/// access.
-///
-#define RETURN_MEDIA_CHANGED         ENCODE_ERROR (13)
-
-///
-/// The item was not found.
-///
-#define RETURN_NOT_FOUND             ENCODE_ERROR (14)
-
-///
-/// Access was denied.
-///
-#define RETURN_ACCESS_DENIED         ENCODE_ERROR (15)
-
-///
-/// The server was not found or did not respond to the request.
-///
-#define RETURN_NO_RESPONSE           ENCODE_ERROR (16)
-
-///
-/// A mapping to the device does not exist.
-///
-#define RETURN_NO_MAPPING            ENCODE_ERROR (17)
-
-///
-/// A timeout time expired.
-///
-#define RETURN_TIMEOUT               ENCODE_ERROR (18)
-
-///
-/// The protocol has not been started.
-///
-#define RETURN_NOT_STARTED           ENCODE_ERROR (19)
-
-///
-/// The protocol has already been started.
-///
-#define RETURN_ALREADY_STARTED       ENCODE_ERROR (20)
-
-///
-/// The operation was aborted.
-///
-#define RETURN_ABORTED               ENCODE_ERROR (21)
-
-///
-/// An ICMP error occurred during the network operation.
-///
-#define RETURN_ICMP_ERROR            ENCODE_ERROR (22)
-
-///
-/// A TFTP error occurred during the network operation.
-///
-#define RETURN_TFTP_ERROR            ENCODE_ERROR (23)
-
-///
-/// A protocol error occurred during the network operation.
-///
-#define RETURN_PROTOCOL_ERROR        ENCODE_ERROR (24)
-
-///
-/// A function encountered an internal version that was
-/// incompatible with a version requested by the caller.
-///
-#define RETURN_INCOMPATIBLE_VERSION  ENCODE_ERROR (25)
-
-///
-/// The function was not performed due to a security violation.
-///
-#define RETURN_SECURITY_VIOLATION    ENCODE_ERROR (26)
-
-///
-/// A CRC error was detected.
-///
-#define RETURN_CRC_ERROR             ENCODE_ERROR (27)
-
-///
-/// The beginning or end of media was reached.
-///
-#define RETURN_END_OF_MEDIA          ENCODE_ERROR (28)
-
-///
-/// The end of the file was reached.
-///
-#define RETURN_END_OF_FILE           ENCODE_ERROR (31)
-
-///
-/// The language specified was invalid.
-///
-#define RETURN_INVALID_LANGUAGE      ENCODE_ERROR (32)
-
-///
-/// The security status of the data is unknown or compromised
-/// and the data must be updated or replaced to restore a valid
-/// security status.
-///
-#define RETURN_COMPROMISED_DATA      ENCODE_ERROR (33)
-
-///
-/// The string contained one or more characters that
-/// the device could not render and were skipped.
-///
-#define RETURN_WARN_UNKNOWN_GLYPH    ENCODE_WARNING (1)
-
-///
-/// The handle was closed, but the file was not deleted.
-///
-#define RETURN_WARN_DELETE_FAILURE   ENCODE_WARNING (2)
-
-///
-/// The handle was closed, but the data to the file was not
-/// flushed properly.
-///
-#define RETURN_WARN_WRITE_FAILURE    ENCODE_WARNING (3)
-
-///
-/// The resulting buffer was too small, and the data was
-/// truncated to the buffer size.
-///
-#define RETURN_WARN_BUFFER_TOO_SMALL ENCODE_WARNING (4)
-
-///
-/// The data has not been updated within the timeframe set by
-/// local policy for this type of data.
-///
-#define RETURN_WARN_STALE_DATA       ENCODE_WARNING (5)
-
-/**
-  Returns a 16-bit signature built from 2 ASCII characters.
-
-  This macro returns a 16-bit value built from the two ASCII characters specified
-  by A and B.
-
-  @param  A    The first ASCII character.
-  @param  B    The second ASCII character.
-
-  @return A 16-bit value built from the two ASCII characters specified by A and B.
-
-**/
-#define SIGNATURE_16(A, B)        ((A) | (B << 8))
-
-/**
-  Returns a 32-bit signature built from 4 ASCII characters.
-
-  This macro returns a 32-bit value built from the four ASCII characters specified
-  by A, B, C, and D.
-
-  @param  A    The first ASCII character.
-  @param  B    The second ASCII character.
-  @param  C    The third ASCII character.
-  @param  D    The fourth ASCII character.
-
-  @return A 32-bit value built from the two ASCII characters specified by A, B,
-          C and D.
-
-**/
-#define SIGNATURE_32(A, B, C, D)  (SIGNATURE_16 (A, B) | (SIGNATURE_16 (C, D) << 16))
-
-/**
-  Returns a 64-bit signature built from 8 ASCII characters.
-
-  This macro returns a 64-bit value built from the eight ASCII characters specified
-  by A, B, C, D, E, F, G,and H.
-
-  @param  A    The first ASCII character.
-  @param  B    The second ASCII character.
-  @param  C    The third ASCII character.
-  @param  D    The fourth ASCII character.
-  @param  E    The fifth ASCII character.
-  @param  F    The sixth ASCII character.
-  @param  G    The seventh ASCII character.
-  @param  H    The eighth ASCII character.
-
-  @return A 64-bit value built from the two ASCII characters specified by A, B,
-          C, D, E, F, G and H.
-
-**/
-#define SIGNATURE_64(A, B, C, D, E, F, G, H) \
-    (SIGNATURE_32 (A, B, C, D) | ((UINT64) (SIGNATURE_32 (E, F, G, H)) << 32))
-
-#endif
-
diff --git a/src/efi/Guid/FileInfo.h b/src/efi/Guid/FileInfo.h
deleted file mode 100644
index 1457275..0000000
--- a/src/efi/Guid/FileInfo.h
+++ /dev/null
@@ -1,71 +0,0 @@
-/** @file
-  Provides a GUID and a data structure that can be used with EFI_FILE_PROTOCOL.SetInfo()
-  and EFI_FILE_PROTOCOL.GetInfo() to set or get generic file information.
-  This GUID is defined in UEFI specification.
-
-Copyright (c) 2006 - 2010, Intel Corporation. All rights reserved.<BR>
-This program and the accompanying materials are licensed and made available under
-the terms and conditions of the BSD License that accompanies this distribution.
-The full text of the license may be found at
-http://opensource.org/licenses/bsd-license.php.
-
-THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
-WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
-
-**/
-
-#ifndef __FILE_INFO_H__
-#define __FILE_INFO_H__
-
-#define EFI_FILE_INFO_ID \
-  { \
-    0x9576e92, 0x6d3f, 0x11d2, {0x8e, 0x39, 0x0, 0xa0, 0xc9, 0x69, 0x72, 0x3b } \
-  }
-
-typedef struct {
-  ///
-  /// The size of the EFI_FILE_INFO structure, including the Null-terminated FileName string.
-  ///
-  UINT64    Size;
-  ///
-  /// The size of the file in bytes.
-  ///
-  UINT64    FileSize;
-  ///
-  /// PhysicalSize The amount of physical space the file consumes on the file system volume.
-  ///
-  UINT64    PhysicalSize;
-  ///
-  /// The time the file was created.
-  ///
-  EFI_TIME  CreateTime;
-  ///
-  /// The time when the file was last accessed.
-  ///
-  EFI_TIME  LastAccessTime;
-  ///
-  /// The time when the file's contents were last modified.
-  ///
-  EFI_TIME  ModificationTime;
-  ///
-  /// The attribute bits for the file.
-  ///
-  UINT64    Attribute;
-  ///
-  /// The Null-terminated name of the file.
-  ///
-  CHAR16    FileName[1];
-} EFI_FILE_INFO;
-
-///
-/// The FileName field of the EFI_FILE_INFO data structure is variable length.
-/// Whenever code needs to know the size of the EFI_FILE_INFO data structure, it needs to
-/// be the size of the data structure without the FileName field.  The following macro
-/// computes this size correctly no matter how big the FileName array is declared.
-/// This is required to make the EFI_FILE_INFO data structure ANSI compilant.
-///
-#define SIZE_OF_EFI_FILE_INFO OFFSET_OF (EFI_FILE_INFO, FileName)
-
-extern EFI_GUID gEfiFileInfoGuid;
-
-#endif
diff --git a/src/efi/Guid/HiiFormMapMethodGuid.h b/src/efi/Guid/HiiFormMapMethodGuid.h
deleted file mode 100644
index ab508fd..0000000
--- a/src/efi/Guid/HiiFormMapMethodGuid.h
+++ /dev/null
@@ -1,25 +0,0 @@
-/** @file
-  Guid used to identify HII FormMap configuration method.
-
-  Copyright (c) 2009, Intel Corporation. All rights reserved.<BR>
-  This program and the accompanying materials
-  are licensed and made available under the terms and conditions of the BSD License
-  which accompanies this distribution.  The full text of the license may be found at
-  http://opensource.org/licenses/bsd-license.php
-
-  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
-  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
-
-  @par Revision Reference:
-  GUID defined in UEFI 2.2 spec.
-**/
-
-#ifndef __EFI_HII_FORMMAP_GUID_H__
-#define __EFI_HII_FORMMAP_GUID_H__
-
-#define EFI_HII_STANDARD_FORM_GUID \
-  { 0x3bd2f4ec, 0xe524, 0x46e4, { 0xa9, 0xd8, 0x51, 0x1, 0x17, 0x42, 0x55, 0x62 } }
-
-extern EFI_GUID gEfiHiiStandardFormGuid;
-
-#endif
diff --git a/src/efi/Guid/PcAnsi.h b/src/efi/Guid/PcAnsi.h
deleted file mode 100644
index 8f31254..0000000
--- a/src/efi/Guid/PcAnsi.h
+++ /dev/null
@@ -1,58 +0,0 @@
-/** @file
-  Terminal Device Path Vendor Guid.
-
-  Copyright (c) 2006 - 2009, Intel Corporation. All rights reserved.<BR>
-  This program and the accompanying materials
-  are licensed and made available under the terms and conditions of the BSD License
-  which accompanies this distribution.  The full text of the license may be found at
-  http://opensource.org/licenses/bsd-license.php
-
-  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
-  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
-
-  @par Revision Reference:
-  GUIDs defined in UEFI 2.0 spec.
-
-**/
-
-#ifndef __PC_ANSI_H__
-#define __PC_ANSI_H__
-
-#define EFI_PC_ANSI_GUID \
-  { \
-    0xe0c14753, 0xf9be, 0x11d2, {0x9a, 0x0c, 0x00, 0x90, 0x27, 0x3f, 0xc1, 0x4d } \
-  }
-
-#define EFI_VT_100_GUID \
-  { \
-    0xdfa66065, 0xb419, 0x11d3, {0x9a, 0x2d, 0x00, 0x90, 0x27, 0x3f, 0xc1, 0x4d } \
-  }
-
-#define EFI_VT_100_PLUS_GUID \
-  { \
-    0x7baec70b, 0x57e0, 0x4c76, {0x8e, 0x87, 0x2f, 0x9e, 0x28, 0x08, 0x83, 0x43 } \
-  }
-
-#define EFI_VT_UTF8_GUID \
-  { \
-    0xad15a0d6, 0x8bec, 0x4acf, {0xa0, 0x73, 0xd0, 0x1d, 0xe7, 0x7e, 0x2d, 0x88 } \
-  }
-
-#define DEVICE_PATH_MESSAGING_UART_FLOW_CONTROL \
-  { \
-    0x37499a9d, 0x542f, 0x4c89, {0xa0, 0x26, 0x35, 0xda, 0x14, 0x20, 0x94, 0xe4 } \
-  }
-
-#define EFI_SAS_DEVICE_PATH_GUID \
-  { \
-    0xd487ddb4, 0x008b, 0x11d9, {0xaf, 0xdc, 0x00, 0x10, 0x83, 0xff, 0xca, 0x4d } \
-  }
-
-extern EFI_GUID gEfiPcAnsiGuid;
-extern EFI_GUID gEfiVT100Guid;
-extern EFI_GUID gEfiVT100PlusGuid;
-extern EFI_GUID gEfiVTUTF8Guid;
-extern EFI_GUID gEfiUartDevicePathGuid;
-extern EFI_GUID gEfiSasDevicePathGuid;
-
-#endif
diff --git a/src/efi/Guid/WinCertificate.h b/src/efi/Guid/WinCertificate.h
deleted file mode 100644
index 6dea446..0000000
--- a/src/efi/Guid/WinCertificate.h
+++ /dev/null
@@ -1,128 +0,0 @@
-/** @file
-  GUID for UEFI WIN_CERTIFICATE structure.
-
-  Copyright (c) 2006 - 2012, Intel Corporation. All rights reserved.<BR>
-  This program and the accompanying materials
-  are licensed and made available under the terms and conditions of the BSD License
-  which accompanies this distribution.  The full text of the license may be found at
-  http://opensource.org/licenses/bsd-license.php
-
-  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
-  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
-
-  @par Revision Reference:
-  GUID defined in UEFI 2.0 spec.
-**/
-
-#ifndef __EFI_WIN_CERTIFICATE_H__
-#define __EFI_WIN_CERTIFICATE_H__
-
-//
-// _WIN_CERTIFICATE.wCertificateType
-//
-#define WIN_CERT_TYPE_PKCS_SIGNED_DATA 0x0002
-#define WIN_CERT_TYPE_EFI_PKCS115      0x0EF0
-#define WIN_CERT_TYPE_EFI_GUID         0x0EF1
-
-///
-/// The WIN_CERTIFICATE structure is part of the PE/COFF specification.
-///
-typedef struct {
-  ///
-  /// The length of the entire certificate,
-  /// including the length of the header, in bytes.
-  ///
-  UINT32  dwLength;
-  ///
-  /// The revision level of the WIN_CERTIFICATE
-  /// structure. The current revision level is 0x0200.
-  ///
-  UINT16  wRevision;
-  ///
-  /// The certificate type. See WIN_CERT_TYPE_xxx for the UEFI
-  /// certificate types. The UEFI specification reserves the range of
-  /// certificate type values from 0x0EF0 to 0x0EFF.
-  ///
-  UINT16  wCertificateType;
-  ///
-  /// The following is the actual certificate. The format of
-  /// the certificate depends on wCertificateType.
-  ///
-  /// UINT8 bCertificate[ANYSIZE_ARRAY];
-  ///
-} WIN_CERTIFICATE;
-
-///
-/// WIN_CERTIFICATE_UEFI_GUID.CertType
-///
-#define EFI_CERT_TYPE_RSA2048_SHA256_GUID \
-  {0xa7717414, 0xc616, 0x4977, {0x94, 0x20, 0x84, 0x47, 0x12, 0xa7, 0x35, 0xbf } }
-
-///
-/// WIN_CERTIFICATE_UEFI_GUID.CertData
-///
-typedef struct {
-  EFI_GUID  HashType;
-  UINT8     PublicKey[256];
-  UINT8     Signature[256];
-} EFI_CERT_BLOCK_RSA_2048_SHA256;
-
-
-///
-/// Certificate which encapsulates a GUID-specific digital signature
-///
-typedef struct {
-  ///
-  /// This is the standard WIN_CERTIFICATE header, where
-  /// wCertificateType is set to WIN_CERT_TYPE_EFI_GUID.
-  ///
-  WIN_CERTIFICATE   Hdr;
-  ///
-  /// This is the unique id which determines the
-  /// format of the CertData. .
-  ///
-  EFI_GUID          CertType;
-  ///
-  /// The following is the certificate data. The format of
-  /// the data is determined by the CertType.
-  /// If CertType is EFI_CERT_TYPE_RSA2048_SHA256_GUID,
-  /// the CertData will be EFI_CERT_BLOCK_RSA_2048_SHA256 structure.
-  ///
-  UINT8            CertData[1];
-} WIN_CERTIFICATE_UEFI_GUID;
-
-
-///
-/// Certificate which encapsulates the RSASSA_PKCS1-v1_5 digital signature.
-///
-/// The WIN_CERTIFICATE_UEFI_PKCS1_15 structure is derived from
-/// WIN_CERTIFICATE and encapsulate the information needed to
-/// implement the RSASSA-PKCS1-v1_5 digital signature algorithm as
-/// specified in RFC2437.
-///
-typedef struct {
-  ///
-  /// This is the standard WIN_CERTIFICATE header, where
-  /// wCertificateType is set to WIN_CERT_TYPE_UEFI_PKCS1_15.
-  ///
-  WIN_CERTIFICATE Hdr;
-  ///
-  /// This is the hashing algorithm which was performed on the
-  /// UEFI executable when creating the digital signature.
-  ///
-  EFI_GUID        HashAlgorithm;
-  ///
-  /// The following is the actual digital signature. The
-  /// size of the signature is the same size as the key
-  /// (1024-bit key is 128 bytes) and can be determined by
-  /// subtracting the length of the other parts of this header
-  /// from the total length of the certificate as found in
-  /// Hdr.dwLength.
-  ///
-  /// UINT8 Signature[];
-  ///
-} WIN_CERTIFICATE_EFI_PKCS1_15;
-
-extern EFI_GUID gEfiCertTypeRsa2048Sha256Guid;
-
-#endif
diff --git a/src/efi/Ia32/ProcessorBind.h b/src/efi/Ia32/ProcessorBind.h
deleted file mode 100644
index bdcd7d4..0000000
--- a/src/efi/Ia32/ProcessorBind.h
+++ /dev/null
@@ -1,288 +0,0 @@
-/** @file
-  Processor or Compiler specific defines and types for IA-32 architecture.
-
-Copyright (c) 2006 - 2013, Intel Corporation. All rights reserved.<BR>
-This program and the accompanying materials are licensed and made available under
-the terms and conditions of the BSD License that accompanies this distribution.
-The full text of the license may be found at
-http://opensource.org/licenses/bsd-license.php.
-
-THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
-WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
-
-**/
-
-#ifndef __PROCESSOR_BIND_H__
-#define __PROCESSOR_BIND_H__
-
-///
-/// Define the processor type so other code can make processor based choices.
-///
-#define MDE_CPU_IA32
-
-//
-// Make sure we are using the correct packing rules per EFI specification
-//
-#if !defined(__GNUC__)
-#pragma pack()
-#endif
-
-#if defined(__INTEL_COMPILER)
-//
-// Disable ICC's remark #869: "Parameter" was never referenced warning.
-// This is legal ANSI C code so we disable the remark that is turned on with -Wall
-//
-#pragma warning ( disable : 869 )
-
-//
-// Disable ICC's remark #1418: external function definition with no prior declaration.
-// This is legal ANSI C code so we disable the remark that is turned on with /W4
-//
-#pragma warning ( disable : 1418 )
-
-//
-// Disable ICC's remark #1419: external declaration in primary source file
-// This is legal ANSI C code so we disable the remark that is turned on with /W4
-//
-#pragma warning ( disable : 1419 )
-
-//
-// Disable ICC's remark #593: "Variable" was set but never used.
-// This is legal ANSI C code so we disable the remark that is turned on with /W4
-//
-#pragma warning ( disable : 593 )
-
-#endif
-
-
-#if defined(_MSC_EXTENSIONS)
-
-//
-// Disable warning that make it impossible to compile at /W4
-// This only works for Microsoft* tools
-//
-
-//
-// Disabling bitfield type checking warnings.
-//
-#pragma warning ( disable : 4214 )
-
-//
-// Disabling the unreferenced formal parameter warnings.
-//
-#pragma warning ( disable : 4100 )
-
-//
-// Disable slightly different base types warning as CHAR8 * can not be set
-// to a constant string.
-//
-#pragma warning ( disable : 4057 )
-
-//
-// ASSERT(FALSE) or while (TRUE) are legal constructes so supress this warning
-//
-#pragma warning ( disable : 4127 )
-
-//
-// This warning is caused by functions defined but not used. For precompiled header only.
-//
-#pragma warning ( disable : 4505 )
-
-//
-// This warning is caused by empty (after preprocessing) source file. For precompiled header only.
-//
-#pragma warning ( disable : 4206 )
-
-#endif
-
-
-#if defined(_MSC_EXTENSIONS)
-
-  //
-  // use Microsoft C complier dependent integer width types
-  //
-
-  ///
-  /// 8-byte unsigned value.
-  ///
-  typedef unsigned __int64    UINT64;
-  ///
-  /// 8-byte signed value.
-  ///
-  typedef __int64             INT64;
-  ///
-  /// 4-byte unsigned value.
-  ///
-  typedef unsigned __int32    UINT32;
-  ///
-  /// 4-byte signed value.
-  ///
-  typedef __int32             INT32;
-  ///
-  /// 2-byte unsigned value.
-  ///
-  typedef unsigned short      UINT16;
-  ///
-  /// 2-byte Character.  Unless otherwise specified all strings are stored in the
-  /// UTF-16 encoding format as defined by Unicode 2.1 and ISO/IEC 10646 standards.
-  ///
-  typedef unsigned short      CHAR16;
-  ///
-  /// 2-byte signed value.
-  ///
-  typedef short               INT16;
-  ///
-  /// Logical Boolean.  1-byte value containing 0 for FALSE or a 1 for TRUE.  Other
-  /// values are undefined.
-  ///
-  typedef unsigned char       BOOLEAN;
-  ///
-  /// 1-byte unsigned value.
-  ///
-  typedef unsigned char       UINT8;
-  ///
-  /// 1-byte Character.
-  ///
-  typedef char                CHAR8;
-  ///
-  /// 1-byte signed value.
-  ///
-  typedef signed char         INT8;
-#else
-  ///
-  /// 8-byte unsigned value.
-  ///
-  typedef unsigned long long  UINT64;
-  ///
-  /// 8-byte signed value.
-  ///
-  typedef long long           INT64;
-  ///
-  /// 4-byte unsigned value.
-  ///
-  typedef unsigned int        UINT32;
-  ///
-  /// 4-byte signed value.
-  ///
-  typedef int                 INT32;
-  ///
-  /// 2-byte unsigned value.
-  ///
-  typedef unsigned short      UINT16;
-  ///
-  /// 2-byte Character.  Unless otherwise specified all strings are stored in the
-  /// UTF-16 encoding format as defined by Unicode 2.1 and ISO/IEC 10646 standards.
-  ///
-  typedef unsigned short      CHAR16;
-  ///
-  /// 2-byte signed value.
-  ///
-  typedef short               INT16;
-  ///
-  /// Logical Boolean.  1-byte value containing 0 for FALSE or a 1 for TRUE.  Other
-  /// values are undefined.
-  ///
-  typedef unsigned char       BOOLEAN;
-  ///
-  /// 1-byte unsigned value.
-  ///
-  typedef unsigned char       UINT8;
-  ///
-  /// 1-byte Character
-  ///
-  typedef char                CHAR8;
-  ///
-  /// 1-byte signed value
-  ///
-  typedef signed char         INT8;
-#endif
-
-///
-/// Unsigned value of native width.  (4 bytes on supported 32-bit processor instructions;
-/// 8 bytes on supported 64-bit processor instructions.)
-///
-typedef UINT32  UINTN;
-///
-/// Signed value of native width.  (4 bytes on supported 32-bit processor instructions;
-/// 8 bytes on supported 64-bit processor instructions.)
-///
-typedef INT32   INTN;
-
-//
-// Processor specific defines
-//
-
-///
-/// A value of native width with the highest bit set.
-///
-#define MAX_BIT     0x80000000
-///
-/// A value of native width with the two highest bits set.
-///
-#define MAX_2_BITS  0xC0000000
-
-///
-/// Maximum legal IA-32 address.
-///
-#define MAX_ADDRESS   0xFFFFFFFF
-
-///
-/// Maximum legal IA-32 INTN and UINTN values.
-///
-#define MAX_INTN   ((INTN)0x7FFFFFFF)
-#define MAX_UINTN  ((UINTN)0xFFFFFFFF)
-
-///
-/// The stack alignment required for IA-32.
-///
-#define CPU_STACK_ALIGNMENT   sizeof(UINTN)
-
-//
-// Modifier to ensure that all protocol member functions and EFI intrinsics
-// use the correct C calling convention. All protocol member functions and
-// EFI intrinsics are required to modify their member functions with EFIAPI.
-//
-#ifdef EFIAPI
-  ///
-  /// If EFIAPI is already defined, then we use that definition.
-  ///
-#elif defined(_MSC_EXTENSIONS)
-  ///
-  /// Microsoft* compiler specific method for EFIAPI calling convention.
-  ///
-  #define EFIAPI __cdecl
-#elif defined(__GNUC__)
-  ///
-  /// GCC specific method for EFIAPI calling convention.
-  ///
-  #define EFIAPI __attribute__((cdecl))
-#else
-  ///
-  /// The default for a non Microsoft* or GCC compiler is to assume the EFI ABI
-  /// is the standard.
-  ///
-  #define EFIAPI
-#endif
-
-#if defined(__GNUC__)
-  ///
-  /// For GNU assembly code, .global or .globl can declare global symbols.
-  /// Define this macro to unify the usage.
-  ///
-  #define ASM_GLOBAL .globl
-#endif
-
-/**
-  Return the pointer to the first instruction of a function given a function pointer.
-  On IA-32 CPU architectures, these two pointer values are the same,
-  so the implementation of this macro is very simple.
-
-  @param  FunctionPointer   A pointer to a function.
-
-  @return The pointer to the first instruction of a function given a function pointer.
-
-**/
-#define FUNCTION_ENTRY_POINT(FunctionPointer) (VOID *)(UINTN)(FunctionPointer)
-
-#endif
-
diff --git a/src/efi/IndustryStandard/PeImage.h b/src/efi/IndustryStandard/PeImage.h
deleted file mode 100644
index 254e5d2..0000000
--- a/src/efi/IndustryStandard/PeImage.h
+++ /dev/null
@@ -1,756 +0,0 @@
-/** @file
-  EFI image format for PE32, PE32+ and TE. Please note some data structures are
-  different for PE32 and PE32+. EFI_IMAGE_NT_HEADERS32 is for PE32 and
-  EFI_IMAGE_NT_HEADERS64 is for PE32+.
-
-  This file is coded to the Visual Studio, Microsoft Portable Executable and
-  Common Object File Format Specification, Revision 8.3 - February 6, 2013.
-  This file also includes some definitions in PI Specification, Revision 1.0.
-
-Copyright (c) 2006 - 2010, Intel Corporation. All rights reserved.<BR>
-Portions copyright (c) 2008 - 2009, Apple Inc. All rights reserved.<BR>
-This program and the accompanying materials
-are licensed and made available under the terms and conditions of the BSD License
-which accompanies this distribution.  The full text of the license may be found at
-http://opensource.org/licenses/bsd-license.php.
-
-THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
-WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
-
-**/
-
-#ifndef __PE_IMAGE_H__
-#define __PE_IMAGE_H__
-
-//
-// PE32+ Subsystem type for EFI images
-//
-#define EFI_IMAGE_SUBSYSTEM_EFI_APPLICATION         10
-#define EFI_IMAGE_SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER 11
-#define EFI_IMAGE_SUBSYSTEM_EFI_RUNTIME_DRIVER      12
-#define EFI_IMAGE_SUBSYSTEM_SAL_RUNTIME_DRIVER      13 ///< defined PI Specification, 1.0
-
-
-//
-// PE32+ Machine type for EFI images
-//
-#define IMAGE_FILE_MACHINE_I386            0x014c
-#define IMAGE_FILE_MACHINE_IA64            0x0200
-#define IMAGE_FILE_MACHINE_EBC             0x0EBC
-#define IMAGE_FILE_MACHINE_X64             0x8664
-#define IMAGE_FILE_MACHINE_ARMTHUMB_MIXED  0x01c2
-#define IMAGE_FILE_MACHINE_ARM64           0xAA64
-
-//
-// EXE file formats
-//
-#define EFI_IMAGE_DOS_SIGNATURE     SIGNATURE_16('M', 'Z')
-#define EFI_IMAGE_OS2_SIGNATURE     SIGNATURE_16('N', 'E')
-#define EFI_IMAGE_OS2_SIGNATURE_LE  SIGNATURE_16('L', 'E')
-#define EFI_IMAGE_NT_SIGNATURE      SIGNATURE_32('P', 'E', '\0', '\0')
-
-///
-/// PE images can start with an optional DOS header, so if an image is run
-/// under DOS it can print an error message.
-///
-typedef struct {
-  UINT16  e_magic;    ///< Magic number.
-  UINT16  e_cblp;     ///< Bytes on last page of file.
-  UINT16  e_cp;       ///< Pages in file.
-  UINT16  e_crlc;     ///< Relocations.
-  UINT16  e_cparhdr;  ///< Size of header in paragraphs.
-  UINT16  e_minalloc; ///< Minimum extra paragraphs needed.
-  UINT16  e_maxalloc; ///< Maximum extra paragraphs needed.
-  UINT16  e_ss;       ///< Initial (relative) SS value.
-  UINT16  e_sp;       ///< Initial SP value.
-  UINT16  e_csum;     ///< Checksum.
-  UINT16  e_ip;       ///< Initial IP value.
-  UINT16  e_cs;       ///< Initial (relative) CS value.
-  UINT16  e_lfarlc;   ///< File address of relocation table.
-  UINT16  e_ovno;     ///< Overlay number.
-  UINT16  e_res[4];   ///< Reserved words.
-  UINT16  e_oemid;    ///< OEM identifier (for e_oeminfo).
-  UINT16  e_oeminfo;  ///< OEM information; e_oemid specific.
-  UINT16  e_res2[10]; ///< Reserved words.
-  UINT32  e_lfanew;   ///< File address of new exe header.
-} EFI_IMAGE_DOS_HEADER;
-
-///
-/// COFF File Header (Object and Image).
-///
-typedef struct {
-  UINT16  Machine;
-  UINT16  NumberOfSections;
-  UINT32  TimeDateStamp;
-  UINT32  PointerToSymbolTable;
-  UINT32  NumberOfSymbols;
-  UINT16  SizeOfOptionalHeader;
-  UINT16  Characteristics;
-} EFI_IMAGE_FILE_HEADER;
-
-///
-/// Size of EFI_IMAGE_FILE_HEADER.
-///
-#define EFI_IMAGE_SIZEOF_FILE_HEADER        20
-
-//
-// Characteristics
-//
-#define EFI_IMAGE_FILE_RELOCS_STRIPPED      BIT0     ///< 0x0001  Relocation info stripped from file.
-#define EFI_IMAGE_FILE_EXECUTABLE_IMAGE     BIT1     ///< 0x0002  File is executable  (i.e. no unresolved externel references).
-#define EFI_IMAGE_FILE_LINE_NUMS_STRIPPED   BIT2     ///< 0x0004  Line nunbers stripped from file.
-#define EFI_IMAGE_FILE_LOCAL_SYMS_STRIPPED  BIT3     ///< 0x0008  Local symbols stripped from file.
-#define EFI_IMAGE_FILE_BYTES_REVERSED_LO    BIT7     ///< 0x0080  Bytes of machine word are reversed.
-#define EFI_IMAGE_FILE_32BIT_MACHINE        BIT8     ///< 0x0100  32 bit word machine.
-#define EFI_IMAGE_FILE_DEBUG_STRIPPED       BIT9     ///< 0x0200  Debugging info stripped from file in .DBG file.
-#define EFI_IMAGE_FILE_SYSTEM               BIT12    ///< 0x1000  System File.
-#define EFI_IMAGE_FILE_DLL                  BIT13    ///< 0x2000  File is a DLL.
-#define EFI_IMAGE_FILE_BYTES_REVERSED_HI    BIT15    ///< 0x8000  Bytes of machine word are reversed.
-
-///
-/// Header Data Directories.
-///
-typedef struct {
-  UINT32  VirtualAddress;
-  UINT32  Size;
-} EFI_IMAGE_DATA_DIRECTORY;
-
-//
-// Directory Entries
-//
-#define EFI_IMAGE_DIRECTORY_ENTRY_EXPORT      0
-#define EFI_IMAGE_DIRECTORY_ENTRY_IMPORT      1
-#define EFI_IMAGE_DIRECTORY_ENTRY_RESOURCE    2
-#define EFI_IMAGE_DIRECTORY_ENTRY_EXCEPTION   3
-#define EFI_IMAGE_DIRECTORY_ENTRY_SECURITY    4
-#define EFI_IMAGE_DIRECTORY_ENTRY_BASERELOC   5
-#define EFI_IMAGE_DIRECTORY_ENTRY_DEBUG       6
-#define EFI_IMAGE_DIRECTORY_ENTRY_COPYRIGHT   7
-#define EFI_IMAGE_DIRECTORY_ENTRY_GLOBALPTR   8
-#define EFI_IMAGE_DIRECTORY_ENTRY_TLS         9
-#define EFI_IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG 10
-
-#define EFI_IMAGE_NUMBER_OF_DIRECTORY_ENTRIES 16
-
-///
-/// @attention
-/// EFI_IMAGE_NT_OPTIONAL_HDR32_MAGIC means PE32 and
-/// EFI_IMAGE_OPTIONAL_HEADER32 must be used. The data structures only vary
-/// after NT additional fields.
-///
-#define EFI_IMAGE_NT_OPTIONAL_HDR32_MAGIC 0x10b
-
-///
-/// Optional Header Standard Fields for PE32.
-///
-typedef struct {
-  ///
-  /// Standard fields.
-  ///
-  UINT16                    Magic;
-  UINT8                     MajorLinkerVersion;
-  UINT8                     MinorLinkerVersion;
-  UINT32                    SizeOfCode;
-  UINT32                    SizeOfInitializedData;
-  UINT32                    SizeOfUninitializedData;
-  UINT32                    AddressOfEntryPoint;
-  UINT32                    BaseOfCode;
-  UINT32                    BaseOfData;  ///< PE32 contains this additional field, which is absent in PE32+.
-  ///
-  /// Optional Header Windows-Specific Fields.
-  ///
-  UINT32                    ImageBase;
-  UINT32                    SectionAlignment;
-  UINT32                    FileAlignment;
-  UINT16                    MajorOperatingSystemVersion;
-  UINT16                    MinorOperatingSystemVersion;
-  UINT16                    MajorImageVersion;
-  UINT16                    MinorImageVersion;
-  UINT16                    MajorSubsystemVersion;
-  UINT16                    MinorSubsystemVersion;
-  UINT32                    Win32VersionValue;
-  UINT32                    SizeOfImage;
-  UINT32                    SizeOfHeaders;
-  UINT32                    CheckSum;
-  UINT16                    Subsystem;
-  UINT16                    DllCharacteristics;
-  UINT32                    SizeOfStackReserve;
-  UINT32                    SizeOfStackCommit;
-  UINT32                    SizeOfHeapReserve;
-  UINT32                    SizeOfHeapCommit;
-  UINT32                    LoaderFlags;
-  UINT32                    NumberOfRvaAndSizes;
-  EFI_IMAGE_DATA_DIRECTORY  DataDirectory[EFI_IMAGE_NUMBER_OF_DIRECTORY_ENTRIES];
-} EFI_IMAGE_OPTIONAL_HEADER32;
-
-///
-/// @attention
-/// EFI_IMAGE_NT_OPTIONAL_HDR64_MAGIC means PE32+ and
-/// EFI_IMAGE_OPTIONAL_HEADER64 must be used. The data structures only vary
-/// after NT additional fields.
-///
-#define EFI_IMAGE_NT_OPTIONAL_HDR64_MAGIC 0x20b
-
-///
-/// Optional Header Standard Fields for PE32+.
-///
-typedef struct {
-  ///
-  /// Standard fields.
-  ///
-  UINT16                    Magic;
-  UINT8                     MajorLinkerVersion;
-  UINT8                     MinorLinkerVersion;
-  UINT32                    SizeOfCode;
-  UINT32                    SizeOfInitializedData;
-  UINT32                    SizeOfUninitializedData;
-  UINT32                    AddressOfEntryPoint;
-  UINT32                    BaseOfCode;
-  ///
-  /// Optional Header Windows-Specific Fields.
-  ///
-  UINT64                    ImageBase;
-  UINT32                    SectionAlignment;
-  UINT32                    FileAlignment;
-  UINT16                    MajorOperatingSystemVersion;
-  UINT16                    MinorOperatingSystemVersion;
-  UINT16                    MajorImageVersion;
-  UINT16                    MinorImageVersion;
-  UINT16                    MajorSubsystemVersion;
-  UINT16                    MinorSubsystemVersion;
-  UINT32                    Win32VersionValue;
-  UINT32                    SizeOfImage;
-  UINT32                    SizeOfHeaders;
-  UINT32                    CheckSum;
-  UINT16                    Subsystem;
-  UINT16                    DllCharacteristics;
-  UINT64                    SizeOfStackReserve;
-  UINT64                    SizeOfStackCommit;
-  UINT64                    SizeOfHeapReserve;
-  UINT64                    SizeOfHeapCommit;
-  UINT32                    LoaderFlags;
-  UINT32                    NumberOfRvaAndSizes;
-  EFI_IMAGE_DATA_DIRECTORY  DataDirectory[EFI_IMAGE_NUMBER_OF_DIRECTORY_ENTRIES];
-} EFI_IMAGE_OPTIONAL_HEADER64;
-
-
-///
-/// @attention
-/// EFI_IMAGE_NT_HEADERS32 is for use ONLY by tools.
-///
-typedef struct {
-  UINT32                      Signature;
-  EFI_IMAGE_FILE_HEADER       FileHeader;
-  EFI_IMAGE_OPTIONAL_HEADER32 OptionalHeader;
-} EFI_IMAGE_NT_HEADERS32;
-
-#define EFI_IMAGE_SIZEOF_NT_OPTIONAL32_HEADER sizeof (EFI_IMAGE_NT_HEADERS32)
-
-///
-/// @attention
-/// EFI_IMAGE_HEADERS64 is for use ONLY by tools.
-///
-typedef struct {
-  UINT32                      Signature;
-  EFI_IMAGE_FILE_HEADER       FileHeader;
-  EFI_IMAGE_OPTIONAL_HEADER64 OptionalHeader;
-} EFI_IMAGE_NT_HEADERS64;
-
-#define EFI_IMAGE_SIZEOF_NT_OPTIONAL64_HEADER sizeof (EFI_IMAGE_NT_HEADERS64)
-
-//
-// Other Windows Subsystem Values
-//
-#define EFI_IMAGE_SUBSYSTEM_UNKNOWN     0
-#define EFI_IMAGE_SUBSYSTEM_NATIVE      1
-#define EFI_IMAGE_SUBSYSTEM_WINDOWS_GUI 2
-#define EFI_IMAGE_SUBSYSTEM_WINDOWS_CUI 3
-#define EFI_IMAGE_SUBSYSTEM_OS2_CUI     5
-#define EFI_IMAGE_SUBSYSTEM_POSIX_CUI   7
-
-///
-/// Length of ShortName.
-///
-#define EFI_IMAGE_SIZEOF_SHORT_NAME 8
-
-///
-/// Section Table. This table immediately follows the optional header.
-///
-typedef struct {
-  UINT8 Name[EFI_IMAGE_SIZEOF_SHORT_NAME];
-  union {
-    UINT32  PhysicalAddress;
-    UINT32  VirtualSize;
-  } Misc;
-  UINT32  VirtualAddress;
-  UINT32  SizeOfRawData;
-  UINT32  PointerToRawData;
-  UINT32  PointerToRelocations;
-  UINT32  PointerToLinenumbers;
-  UINT16  NumberOfRelocations;
-  UINT16  NumberOfLinenumbers;
-  UINT32  Characteristics;
-} EFI_IMAGE_SECTION_HEADER;
-
-///
-/// Size of EFI_IMAGE_SECTION_HEADER.
-///
-#define EFI_IMAGE_SIZEOF_SECTION_HEADER       40
-
-//
-// Section Flags Values
-//
-#define EFI_IMAGE_SCN_TYPE_NO_PAD                  BIT3   ///< 0x00000008  ///< Reserved.
-#define EFI_IMAGE_SCN_CNT_CODE                     BIT5   ///< 0x00000020
-#define EFI_IMAGE_SCN_CNT_INITIALIZED_DATA         BIT6   ///< 0x00000040
-#define EFI_IMAGE_SCN_CNT_UNINITIALIZED_DATA       BIT7   ///< 0x00000080
-
-#define EFI_IMAGE_SCN_LNK_OTHER                    BIT8   ///< 0x00000100  ///< Reserved.
-#define EFI_IMAGE_SCN_LNK_INFO                     BIT9   ///< 0x00000200  ///< Section contains comments or some other type of information.
-#define EFI_IMAGE_SCN_LNK_REMOVE                   BIT11  ///< 0x00000800  ///< Section contents will not become part of image.
-#define EFI_IMAGE_SCN_LNK_COMDAT                   BIT12  ///< 0x00001000
-
-#define EFI_IMAGE_SCN_ALIGN_1BYTES                 BIT20  ///< 0x00100000
-#define EFI_IMAGE_SCN_ALIGN_2BYTES                 BIT21  ///< 0x00200000
-#define EFI_IMAGE_SCN_ALIGN_4BYTES          (BIT20|BIT21) ///< 0x00300000
-#define EFI_IMAGE_SCN_ALIGN_8BYTES                 BIT22  ///< 0x00400000
-#define EFI_IMAGE_SCN_ALIGN_16BYTES         (BIT20|BIT22) ///< 0x00500000
-#define EFI_IMAGE_SCN_ALIGN_32BYTES         (BIT21|BIT22) ///< 0x00600000
-#define EFI_IMAGE_SCN_ALIGN_64BYTES   (BIT20|BIT21|BIT22) ///< 0x00700000
-
-#define EFI_IMAGE_SCN_MEM_DISCARDABLE              BIT25  ///< 0x02000000
-#define EFI_IMAGE_SCN_MEM_NOT_CACHED               BIT26  ///< 0x04000000
-#define EFI_IMAGE_SCN_MEM_NOT_PAGED                BIT27  ///< 0x08000000
-#define EFI_IMAGE_SCN_MEM_SHARED                   BIT28  ///< 0x10000000
-#define EFI_IMAGE_SCN_MEM_EXECUTE                  BIT29  ///< 0x20000000
-#define EFI_IMAGE_SCN_MEM_READ                     BIT30  ///< 0x40000000
-#define EFI_IMAGE_SCN_MEM_WRITE                    BIT31  ///< 0x80000000
-
-///
-/// Size of a Symbol Table Record.
-///
-#define EFI_IMAGE_SIZEOF_SYMBOL 18
-
-//
-// Symbols have a section number of the section in which they are
-// defined. Otherwise, section numbers have the following meanings:
-//
-#define EFI_IMAGE_SYM_UNDEFINED (UINT16) 0  ///< Symbol is undefined or is common.
-#define EFI_IMAGE_SYM_ABSOLUTE  (UINT16) -1 ///< Symbol is an absolute value.
-#define EFI_IMAGE_SYM_DEBUG     (UINT16) -2 ///< Symbol is a special debug item.
-
-//
-// Symbol Type (fundamental) values.
-//
-#define EFI_IMAGE_SYM_TYPE_NULL   0   ///< no type.
-#define EFI_IMAGE_SYM_TYPE_VOID   1   ///< no valid type.
-#define EFI_IMAGE_SYM_TYPE_CHAR   2   ///< type character.
-#define EFI_IMAGE_SYM_TYPE_SHORT  3   ///< type short integer.
-#define EFI_IMAGE_SYM_TYPE_INT    4
-#define EFI_IMAGE_SYM_TYPE_LONG   5
-#define EFI_IMAGE_SYM_TYPE_FLOAT  6
-#define EFI_IMAGE_SYM_TYPE_DOUBLE 7
-#define EFI_IMAGE_SYM_TYPE_STRUCT 8
-#define EFI_IMAGE_SYM_TYPE_UNION  9
-#define EFI_IMAGE_SYM_TYPE_ENUM   10  ///< enumeration.
-#define EFI_IMAGE_SYM_TYPE_MOE    11  ///< member of enumeration.
-#define EFI_IMAGE_SYM_TYPE_BYTE   12
-#define EFI_IMAGE_SYM_TYPE_WORD   13
-#define EFI_IMAGE_SYM_TYPE_UINT   14
-#define EFI_IMAGE_SYM_TYPE_DWORD  15
-
-//
-// Symbol Type (derived) values.
-//
-#define EFI_IMAGE_SYM_DTYPE_NULL      0 ///< no derived type.
-#define EFI_IMAGE_SYM_DTYPE_POINTER   1
-#define EFI_IMAGE_SYM_DTYPE_FUNCTION  2
-#define EFI_IMAGE_SYM_DTYPE_ARRAY     3
-
-//
-// Storage classes.
-//
-#define EFI_IMAGE_SYM_CLASS_END_OF_FUNCTION   ((UINT8) -1)
-#define EFI_IMAGE_SYM_CLASS_NULL              0
-#define EFI_IMAGE_SYM_CLASS_AUTOMATIC         1
-#define EFI_IMAGE_SYM_CLASS_EXTERNAL          2
-#define EFI_IMAGE_SYM_CLASS_STATIC            3
-#define EFI_IMAGE_SYM_CLASS_REGISTER          4
-#define EFI_IMAGE_SYM_CLASS_EXTERNAL_DEF      5
-#define EFI_IMAGE_SYM_CLASS_LABEL             6
-#define EFI_IMAGE_SYM_CLASS_UNDEFINED_LABEL   7
-#define EFI_IMAGE_SYM_CLASS_MEMBER_OF_STRUCT  8
-#define EFI_IMAGE_SYM_CLASS_ARGUMENT          9
-#define EFI_IMAGE_SYM_CLASS_STRUCT_TAG        10
-#define EFI_IMAGE_SYM_CLASS_MEMBER_OF_UNION   11
-#define EFI_IMAGE_SYM_CLASS_UNION_TAG         12
-#define EFI_IMAGE_SYM_CLASS_TYPE_DEFINITION   13
-#define EFI_IMAGE_SYM_CLASS_UNDEFINED_STATIC  14
-#define EFI_IMAGE_SYM_CLASS_ENUM_TAG          15
-#define EFI_IMAGE_SYM_CLASS_MEMBER_OF_ENUM    16
-#define EFI_IMAGE_SYM_CLASS_REGISTER_PARAM    17
-#define EFI_IMAGE_SYM_CLASS_BIT_FIELD         18
-#define EFI_IMAGE_SYM_CLASS_BLOCK             100
-#define EFI_IMAGE_SYM_CLASS_FUNCTION          101
-#define EFI_IMAGE_SYM_CLASS_END_OF_STRUCT     102
-#define EFI_IMAGE_SYM_CLASS_FILE              103
-#define EFI_IMAGE_SYM_CLASS_SECTION           104
-#define EFI_IMAGE_SYM_CLASS_WEAK_EXTERNAL     105
-
-//
-// type packing constants
-//
-#define EFI_IMAGE_N_BTMASK  017
-#define EFI_IMAGE_N_TMASK   060
-#define EFI_IMAGE_N_TMASK1  0300
-#define EFI_IMAGE_N_TMASK2  0360
-#define EFI_IMAGE_N_BTSHFT  4
-#define EFI_IMAGE_N_TSHIFT  2
-
-//
-// Communal selection types.
-//
-#define EFI_IMAGE_COMDAT_SELECT_NODUPLICATES    1
-#define EFI_IMAGE_COMDAT_SELECT_ANY             2
-#define EFI_IMAGE_COMDAT_SELECT_SAME_SIZE       3
-#define EFI_IMAGE_COMDAT_SELECT_EXACT_MATCH     4
-#define EFI_IMAGE_COMDAT_SELECT_ASSOCIATIVE     5
-
-//
-// the following values only be referred in PeCoff, not defined in PECOFF.
-//
-#define EFI_IMAGE_WEAK_EXTERN_SEARCH_NOLIBRARY  1
-#define EFI_IMAGE_WEAK_EXTERN_SEARCH_LIBRARY    2
-#define EFI_IMAGE_WEAK_EXTERN_SEARCH_ALIAS      3
-
-///
-/// Relocation format.
-///
-typedef struct {
-  UINT32  VirtualAddress;
-  UINT32  SymbolTableIndex;
-  UINT16  Type;
-} EFI_IMAGE_RELOCATION;
-
-///
-/// Size of EFI_IMAGE_RELOCATION
-///
-#define EFI_IMAGE_SIZEOF_RELOCATION 10
-
-//
-// I386 relocation types.
-//
-#define EFI_IMAGE_REL_I386_ABSOLUTE 0x0000  ///< Reference is absolute, no relocation is necessary.
-#define EFI_IMAGE_REL_I386_DIR16    0x0001  ///< Direct 16-bit reference to the symbols virtual address.
-#define EFI_IMAGE_REL_I386_REL16    0x0002  ///< PC-relative 16-bit reference to the symbols virtual address.
-#define EFI_IMAGE_REL_I386_DIR32    0x0006  ///< Direct 32-bit reference to the symbols virtual address.
-#define EFI_IMAGE_REL_I386_DIR32NB  0x0007  ///< Direct 32-bit reference to the symbols virtual address, base not included.
-#define EFI_IMAGE_REL_I386_SEG12    0x0009  ///< Direct 16-bit reference to the segment-selector bits of a 32-bit virtual address.
-#define EFI_IMAGE_REL_I386_SECTION  0x000A
-#define EFI_IMAGE_REL_I386_SECREL   0x000B
-#define EFI_IMAGE_REL_I386_REL32    0x0014  ///< PC-relative 32-bit reference to the symbols virtual address.
-
-//
-// x64 processor relocation types.
-//
-#define IMAGE_REL_AMD64_ABSOLUTE  0x0000
-#define IMAGE_REL_AMD64_ADDR64    0x0001
-#define IMAGE_REL_AMD64_ADDR32    0x0002
-#define IMAGE_REL_AMD64_ADDR32NB  0x0003
-#define IMAGE_REL_AMD64_REL32     0x0004
-#define IMAGE_REL_AMD64_REL32_1   0x0005
-#define IMAGE_REL_AMD64_REL32_2   0x0006
-#define IMAGE_REL_AMD64_REL32_3   0x0007
-#define IMAGE_REL_AMD64_REL32_4   0x0008
-#define IMAGE_REL_AMD64_REL32_5   0x0009
-#define IMAGE_REL_AMD64_SECTION   0x000A
-#define IMAGE_REL_AMD64_SECREL    0x000B
-#define IMAGE_REL_AMD64_SECREL7   0x000C
-#define IMAGE_REL_AMD64_TOKEN     0x000D
-#define IMAGE_REL_AMD64_SREL32    0x000E
-#define IMAGE_REL_AMD64_PAIR      0x000F
-#define IMAGE_REL_AMD64_SSPAN32   0x0010
-
-///
-/// Based relocation format.
-///
-typedef struct {
-  UINT32  VirtualAddress;
-  UINT32  SizeOfBlock;
-} EFI_IMAGE_BASE_RELOCATION;
-
-///
-/// Size of EFI_IMAGE_BASE_RELOCATION.
-///
-#define EFI_IMAGE_SIZEOF_BASE_RELOCATION  8
-
-//
-// Based relocation types.
-//
-#define EFI_IMAGE_REL_BASED_ABSOLUTE        0
-#define EFI_IMAGE_REL_BASED_HIGH            1
-#define EFI_IMAGE_REL_BASED_LOW             2
-#define EFI_IMAGE_REL_BASED_HIGHLOW         3
-#define EFI_IMAGE_REL_BASED_HIGHADJ         4
-#define EFI_IMAGE_REL_BASED_MIPS_JMPADDR    5
-#define EFI_IMAGE_REL_BASED_ARM_MOV32A      5
-#define EFI_IMAGE_REL_BASED_ARM_MOV32T      7
-#define EFI_IMAGE_REL_BASED_IA64_IMM64      9
-#define EFI_IMAGE_REL_BASED_MIPS_JMPADDR16  9
-#define EFI_IMAGE_REL_BASED_DIR64           10
-
-///
-/// Line number format.
-///
-typedef struct {
-  union {
-    UINT32  SymbolTableIndex; ///< Symbol table index of function name if Linenumber is 0.
-    UINT32  VirtualAddress;   ///< Virtual address of line number.
-  } Type;
-  UINT16  Linenumber;         ///< Line number.
-} EFI_IMAGE_LINENUMBER;
-
-///
-/// Size of EFI_IMAGE_LINENUMBER.
-///
-#define EFI_IMAGE_SIZEOF_LINENUMBER 6
-
-//
-// Archive format.
-//
-#define EFI_IMAGE_ARCHIVE_START_SIZE        8
-#define EFI_IMAGE_ARCHIVE_START             "!<arch>\n"
-#define EFI_IMAGE_ARCHIVE_END               "`\n"
-#define EFI_IMAGE_ARCHIVE_PAD               "\n"
-#define EFI_IMAGE_ARCHIVE_LINKER_MEMBER     "/               "
-#define EFI_IMAGE_ARCHIVE_LONGNAMES_MEMBER  "//              "
-
-///
-/// Archive Member Headers
-///
-typedef struct {
-  UINT8 Name[16];     ///< File member name - `/' terminated.
-  UINT8 Date[12];     ///< File member date - decimal.
-  UINT8 UserID[6];    ///< File member user id - decimal.
-  UINT8 GroupID[6];   ///< File member group id - decimal.
-  UINT8 Mode[8];      ///< File member mode - octal.
-  UINT8 Size[10];     ///< File member size - decimal.
-  UINT8 EndHeader[2]; ///< String to end header. (0x60 0x0A).
-} EFI_IMAGE_ARCHIVE_MEMBER_HEADER;
-
-///
-/// Size of EFI_IMAGE_ARCHIVE_MEMBER_HEADER.
-///
-#define EFI_IMAGE_SIZEOF_ARCHIVE_MEMBER_HDR 60
-
-
-//
-// DLL Support
-//
-
-///
-/// Export Directory Table.
-///
-typedef struct {
-  UINT32  Characteristics;
-  UINT32  TimeDateStamp;
-  UINT16  MajorVersion;
-  UINT16  MinorVersion;
-  UINT32  Name;
-  UINT32  Base;
-  UINT32  NumberOfFunctions;
-  UINT32  NumberOfNames;
-  UINT32  AddressOfFunctions;
-  UINT32  AddressOfNames;
-  UINT32  AddressOfNameOrdinals;
-} EFI_IMAGE_EXPORT_DIRECTORY;
-
-///
-/// Hint/Name Table.
-///
-typedef struct {
-  UINT16  Hint;
-  UINT8   Name[1];
-} EFI_IMAGE_IMPORT_BY_NAME;
-
-///
-/// Import Address Table RVA (Thunk Table).
-///
-typedef struct {
-  union {
-    UINT32                    Function;
-    UINT32                    Ordinal;
-    EFI_IMAGE_IMPORT_BY_NAME  *AddressOfData;
-  } u1;
-} EFI_IMAGE_THUNK_DATA;
-
-#define EFI_IMAGE_ORDINAL_FLAG              BIT31    ///< Flag for PE32.
-#define EFI_IMAGE_SNAP_BY_ORDINAL(Ordinal)  ((Ordinal & EFI_IMAGE_ORDINAL_FLAG) != 0)
-#define EFI_IMAGE_ORDINAL(Ordinal)          (Ordinal & 0xffff)
-
-///
-/// Import Directory Table
-///
-typedef struct {
-  UINT32                Characteristics;
-  UINT32                TimeDateStamp;
-  UINT32                ForwarderChain;
-  UINT32                Name;
-  EFI_IMAGE_THUNK_DATA  *FirstThunk;
-} EFI_IMAGE_IMPORT_DESCRIPTOR;
-
-
-///
-/// Debug Directory Format.
-///
-typedef struct {
-  UINT32  Characteristics;
-  UINT32  TimeDateStamp;
-  UINT16  MajorVersion;
-  UINT16  MinorVersion;
-  UINT32  Type;
-  UINT32  SizeOfData;
-  UINT32  RVA;           ///< The address of the debug data when loaded, relative to the image base.
-  UINT32  FileOffset;    ///< The file pointer to the debug data.
-} EFI_IMAGE_DEBUG_DIRECTORY_ENTRY;
-
-#define EFI_IMAGE_DEBUG_TYPE_CODEVIEW 2     ///< The Visual C++ debug information.
-
-///
-/// Debug Data Structure defined in Microsoft C++.
-///
-#define CODEVIEW_SIGNATURE_NB10  SIGNATURE_32('N', 'B', '1', '0')
-typedef struct {
-  UINT32  Signature;                        ///< "NB10"
-  UINT32  Unknown;
-  UINT32  Unknown2;
-  UINT32  Unknown3;
-  //
-  // Filename of .PDB goes here
-  //
-} EFI_IMAGE_DEBUG_CODEVIEW_NB10_ENTRY;
-
-///
-/// Debug Data Structure defined in Microsoft C++.
-///
-#define CODEVIEW_SIGNATURE_RSDS  SIGNATURE_32('R', 'S', 'D', 'S')
-typedef struct {
-  UINT32  Signature;                        ///< "RSDS".
-  UINT32  Unknown;
-  UINT32  Unknown2;
-  UINT32  Unknown3;
-  UINT32  Unknown4;
-  UINT32  Unknown5;
-  //
-  // Filename of .PDB goes here
-  //
-} EFI_IMAGE_DEBUG_CODEVIEW_RSDS_ENTRY;
-
-
-///
-/// Debug Data Structure defined by Apple Mach-O to Coff utility.
-///
-#define CODEVIEW_SIGNATURE_MTOC  SIGNATURE_32('M', 'T', 'O', 'C')
-typedef struct {
-  UINT32    Signature;                       ///< "MTOC".
-  GUID      MachOUuid;
-  //
-  //  Filename of .DLL (Mach-O with debug info) goes here
-  //
-} EFI_IMAGE_DEBUG_CODEVIEW_MTOC_ENTRY;
-
-///
-/// Resource format.
-///
-typedef struct {
-  UINT32  Characteristics;
-  UINT32  TimeDateStamp;
-  UINT16  MajorVersion;
-  UINT16  MinorVersion;
-  UINT16  NumberOfNamedEntries;
-  UINT16  NumberOfIdEntries;
-  //
-  // Array of EFI_IMAGE_RESOURCE_DIRECTORY_ENTRY entries goes here.
-  //
-} EFI_IMAGE_RESOURCE_DIRECTORY;
-
-///
-/// Resource directory entry format.
-///
-typedef struct {
-  union {
-    struct {
-      UINT32  NameOffset:31;
-      UINT32  NameIsString:1;
-    } s;
-    UINT32  Id;
-  } u1;
-  union {
-    UINT32  OffsetToData;
-    struct {
-      UINT32  OffsetToDirectory:31;
-      UINT32  DataIsDirectory:1;
-    } s;
-  } u2;
-} EFI_IMAGE_RESOURCE_DIRECTORY_ENTRY;
-
-///
-/// Resource directory entry for string.
-///
-typedef struct {
-  UINT16  Length;
-  CHAR16  String[1];
-} EFI_IMAGE_RESOURCE_DIRECTORY_STRING;
-
-///
-/// Resource directory entry for data array.
-///
-typedef struct {
-  UINT32  OffsetToData;
-  UINT32  Size;
-  UINT32  CodePage;
-  UINT32  Reserved;
-} EFI_IMAGE_RESOURCE_DATA_ENTRY;
-
-///
-/// Header format for TE images, defined in the PI Specification, 1.0.
-///
-typedef struct {
-  UINT16                    Signature;            ///< The signature for TE format = "VZ".
-  UINT16                    Machine;              ///< From the original file header.
-  UINT8                     NumberOfSections;     ///< From the original file header.
-  UINT8                     Subsystem;            ///< From original optional header.
-  UINT16                    StrippedSize;         ///< Number of bytes we removed from the header.
-  UINT32                    AddressOfEntryPoint;  ///< Offset to entry point -- from original optional header.
-  UINT32                    BaseOfCode;           ///< From original image -- required for ITP debug.
-  UINT64                    ImageBase;            ///< From original file header.
-  EFI_IMAGE_DATA_DIRECTORY  DataDirectory[2];     ///< Only base relocation and debug directory.
-} EFI_TE_IMAGE_HEADER;
-
-
-#define EFI_TE_IMAGE_HEADER_SIGNATURE  SIGNATURE_16('V', 'Z')
-
-//
-// Data directory indexes in our TE image header
-//
-#define EFI_TE_IMAGE_DIRECTORY_ENTRY_BASERELOC  0
-#define EFI_TE_IMAGE_DIRECTORY_ENTRY_DEBUG      1
-
-
-///
-/// Union of PE32, PE32+, and TE headers.
-///
-typedef union {
-  EFI_IMAGE_NT_HEADERS32   Pe32;
-  EFI_IMAGE_NT_HEADERS64   Pe32Plus;
-  EFI_TE_IMAGE_HEADER      Te;
-} EFI_IMAGE_OPTIONAL_HEADER_UNION;
-
-typedef union {
-  EFI_IMAGE_NT_HEADERS32            *Pe32;
-  EFI_IMAGE_NT_HEADERS64            *Pe32Plus;
-  EFI_TE_IMAGE_HEADER               *Te;
-  EFI_IMAGE_OPTIONAL_HEADER_UNION   *Union;
-} EFI_IMAGE_OPTIONAL_HEADER_PTR_UNION;
-
-#endif
diff --git a/src/efi/ProcessorBind.h b/src/efi/ProcessorBind.h
deleted file mode 100644
index 0f31cc3..0000000
--- a/src/efi/ProcessorBind.h
+++ /dev/null
@@ -1,19 +0,0 @@
-#ifndef _WIMBOOT_EFI_PROCESSOR_BIND_H
-#define _WIMBOOT_EFI_PROCESSOR_BIND_H
-
-/*
- * EFI header files rely on having the CPU architecture directory
- * present in the search path in order to pick up ProcessorBind.h.  We
- * use this header file as a quick indirection layer.
- *
- */
-
-#if __i386__
-#include <efi/Ia32/ProcessorBind.h>
-#endif
-
-#if __x86_64__
-#include <efi/X64/ProcessorBind.h>
-#endif
-
-#endif /* _WIMBOOT_EFI_PROCESSOR_BIND_H */
diff --git a/src/efi/Protocol/BlockIo.h b/src/efi/Protocol/BlockIo.h
deleted file mode 100644
index 33c6991..0000000
--- a/src/efi/Protocol/BlockIo.h
+++ /dev/null
@@ -1,241 +0,0 @@
-/** @file
-  Block IO protocol as defined in the UEFI 2.0 specification.
-
-  The Block IO protocol is used to abstract block devices like hard drives,
-  DVD-ROMs and floppy drives.
-
-  Copyright (c) 2006 - 2011, Intel Corporation. All rights reserved.<BR>
-  This program and the accompanying materials
-  are licensed and made available under the terms and conditions of the BSD License
-  which accompanies this distribution.  The full text of the license may be found at
-  http://opensource.org/licenses/bsd-license.php
-
-  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
-  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
-
-**/
-
-#ifndef __BLOCK_IO_H__
-#define __BLOCK_IO_H__
-
-#define EFI_BLOCK_IO_PROTOCOL_GUID \
-  { \
-    0x964e5b21, 0x6459, 0x11d2, {0x8e, 0x39, 0x0, 0xa0, 0xc9, 0x69, 0x72, 0x3b } \
-  }
-
-typedef struct _EFI_BLOCK_IO_PROTOCOL  EFI_BLOCK_IO_PROTOCOL;
-
-///
-/// Protocol GUID name defined in EFI1.1.
-///
-#define BLOCK_IO_PROTOCOL       EFI_BLOCK_IO_PROTOCOL_GUID
-
-///
-/// Protocol defined in EFI1.1.
-///
-typedef EFI_BLOCK_IO_PROTOCOL   EFI_BLOCK_IO;
-
-/**
-  Reset the Block Device.
-
-  @param  This                 Indicates a pointer to the calling context.
-  @param  ExtendedVerification Driver may perform diagnostics on reset.
-
-  @retval EFI_SUCCESS          The device was reset.
-  @retval EFI_DEVICE_ERROR     The device is not functioning properly and could
-                               not be reset.
-
-**/
-typedef
-EFI_STATUS
-(EFIAPI *EFI_BLOCK_RESET)(
-  IN EFI_BLOCK_IO_PROTOCOL          *This,
-  IN BOOLEAN                        ExtendedVerification
-  );
-
-/**
-  Read BufferSize bytes from Lba into Buffer.
-
-  @param  This       Indicates a pointer to the calling context.
-  @param  MediaId    Id of the media, changes every time the media is replaced.
-  @param  Lba        The starting Logical Block Address to read from
-  @param  BufferSize Size of Buffer, must be a multiple of device block size.
-  @param  Buffer     A pointer to the destination buffer for the data. The caller is
-                     responsible for either having implicit or explicit ownership of the buffer.
-
-  @retval EFI_SUCCESS           The data was read correctly from the device.
-  @retval EFI_DEVICE_ERROR      The device reported an error while performing the read.
-  @retval EFI_NO_MEDIA          There is no media in the device.
-  @retval EFI_MEDIA_CHANGED     The MediaId does not matched the current device.
-  @retval EFI_BAD_BUFFER_SIZE   The Buffer was not a multiple of the block size of the device.
-  @retval EFI_INVALID_PARAMETER The read request contains LBAs that are not valid,
-                                or the buffer is not on proper alignment.
-
-**/
-typedef
-EFI_STATUS
-(EFIAPI *EFI_BLOCK_READ)(
-  IN EFI_BLOCK_IO_PROTOCOL          *This,
-  IN UINT32                         MediaId,
-  IN EFI_LBA                        Lba,
-  IN UINTN                          BufferSize,
-  OUT VOID                          *Buffer
-  );
-
-/**
-  Write BufferSize bytes from Lba into Buffer.
-
-  @param  This       Indicates a pointer to the calling context.
-  @param  MediaId    The media ID that the write request is for.
-  @param  Lba        The starting logical block address to be written. The caller is
-                     responsible for writing to only legitimate locations.
-  @param  BufferSize Size of Buffer, must be a multiple of device block size.
-  @param  Buffer     A pointer to the source buffer for the data.
-
-  @retval EFI_SUCCESS           The data was written correctly to the device.
-  @retval EFI_WRITE_PROTECTED   The device can not be written to.
-  @retval EFI_DEVICE_ERROR      The device reported an error while performing the write.
-  @retval EFI_NO_MEDIA          There is no media in the device.
-  @retval EFI_MEDIA_CHNAGED     The MediaId does not matched the current device.
-  @retval EFI_BAD_BUFFER_SIZE   The Buffer was not a multiple of the block size of the device.
-  @retval EFI_INVALID_PARAMETER The write request contains LBAs that are not valid,
-                                or the buffer is not on proper alignment.
-
-**/
-typedef
-EFI_STATUS
-(EFIAPI *EFI_BLOCK_WRITE)(
-  IN EFI_BLOCK_IO_PROTOCOL          *This,
-  IN UINT32                         MediaId,
-  IN EFI_LBA                        Lba,
-  IN UINTN                          BufferSize,
-  IN VOID                           *Buffer
-  );
-
-/**
-  Flush the Block Device.
-
-  @param  This              Indicates a pointer to the calling context.
-
-  @retval EFI_SUCCESS       All outstanding data was written to the device
-  @retval EFI_DEVICE_ERROR  The device reported an error while writting back the data
-  @retval EFI_NO_MEDIA      There is no media in the device.
-
-**/
-typedef
-EFI_STATUS
-(EFIAPI *EFI_BLOCK_FLUSH)(
-  IN EFI_BLOCK_IO_PROTOCOL  *This
-  );
-
-/**
-  Block IO read only mode data and updated only via members of BlockIO
-**/
-typedef struct {
-  ///
-  /// The curent media Id. If the media changes, this value is changed.
-  ///
-  UINT32  MediaId;
-
-  ///
-  /// TRUE if the media is removable; otherwise, FALSE.
-  ///
-  BOOLEAN RemovableMedia;
-
-  ///
-  /// TRUE if there is a media currently present in the device;
-  /// othersise, FALSE. THis field shows the media present status
-  /// as of the most recent ReadBlocks() or WriteBlocks() call.
-  ///
-  BOOLEAN MediaPresent;
-
-  ///
-  /// TRUE if LBA 0 is the first block of a partition; otherwise
-  /// FALSE. For media with only one partition this would be TRUE.
-  ///
-  BOOLEAN LogicalPartition;
-
-  ///
-  /// TRUE if the media is marked read-only otherwise, FALSE.
-  /// This field shows the read-only status as of the most recent WriteBlocks () call.
-  ///
-  BOOLEAN ReadOnly;
-
-  ///
-  /// TRUE if the WriteBlock () function caches write data.
-  ///
-  BOOLEAN WriteCaching;
-
-  ///
-  /// The intrinsic block size of the device. If the media changes, then
-  /// this field is updated.
-  ///
-  UINT32  BlockSize;
-
-  ///
-  /// Supplies the alignment requirement for any buffer to read or write block(s).
-  ///
-  UINT32  IoAlign;
-
-  ///
-  /// The last logical block address on the device.
-  /// If the media changes, then this field is updated.
-  ///
-  EFI_LBA LastBlock;
-
-  ///
-  /// Only present if EFI_BLOCK_IO_PROTOCOL.Revision is greater than or equal to
-  /// EFI_BLOCK_IO_PROTOCOL_REVISION2. Returns the first LBA is aligned to
-  /// a physical block boundary.
-  ///
-  EFI_LBA LowestAlignedLba;
-
-  ///
-  /// Only present if EFI_BLOCK_IO_PROTOCOL.Revision is greater than or equal to
-  /// EFI_BLOCK_IO_PROTOCOL_REVISION2. Returns the number of logical blocks
-  /// per physical block.
-  ///
-  UINT32 LogicalBlocksPerPhysicalBlock;
-
-  ///
-  /// Only present if EFI_BLOCK_IO_PROTOCOL.Revision is greater than or equal to
-  /// EFI_BLOCK_IO_PROTOCOL_REVISION3. Returns the optimal transfer length
-  /// granularity as a number of logical blocks.
-  ///
-  UINT32 OptimalTransferLengthGranularity;
-} EFI_BLOCK_IO_MEDIA;
-
-#define EFI_BLOCK_IO_PROTOCOL_REVISION  0x00010000
-#define EFI_BLOCK_IO_PROTOCOL_REVISION2 0x00020001
-#define EFI_BLOCK_IO_PROTOCOL_REVISION3 0x00020031
-
-///
-/// Revision defined in EFI1.1.
-///
-#define EFI_BLOCK_IO_INTERFACE_REVISION   EFI_BLOCK_IO_PROTOCOL_REVISION
-
-///
-///  This protocol provides control over block devices.
-///
-struct _EFI_BLOCK_IO_PROTOCOL {
-  ///
-  /// The revision to which the block IO interface adheres. All future
-  /// revisions must be backwards compatible. If a future version is not
-  /// back wards compatible, it is not the same GUID.
-  ///
-  UINT64              Revision;
-  ///
-  /// Pointer to the EFI_BLOCK_IO_MEDIA data for this device.
-  ///
-  EFI_BLOCK_IO_MEDIA  *Media;
-
-  EFI_BLOCK_RESET     Reset;
-  EFI_BLOCK_READ      ReadBlocks;
-  EFI_BLOCK_WRITE     WriteBlocks;
-  EFI_BLOCK_FLUSH     FlushBlocks;
-
-};
-
-extern EFI_GUID gEfiBlockIoProtocolGuid;
-
-#endif
diff --git a/src/efi/Protocol/DevicePath.h b/src/efi/Protocol/DevicePath.h
deleted file mode 100644
index e466e87..0000000
--- a/src/efi/Protocol/DevicePath.h
+++ /dev/null
@@ -1,1169 +0,0 @@
-/** @file
-  The device path protocol as defined in UEFI 2.0.
-
-  The device path represents a programmatic path to a device,
-  from a software point of view. The path must persist from boot to boot, so
-  it can not contain things like PCI bus numbers that change from boot to boot.
-
-Copyright (c) 2006 - 2013, Intel Corporation. All rights reserved.<BR>
-This program and the accompanying materials are licensed and made available under
-the terms and conditions of the BSD License that accompanies this distribution.
-The full text of the license may be found at
-http://opensource.org/licenses/bsd-license.php.
-
-THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
-WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
-
-**/
-
-#ifndef __EFI_DEVICE_PATH_PROTOCOL_H__
-#define __EFI_DEVICE_PATH_PROTOCOL_H__
-
-#include "efi/Guid/PcAnsi.h"
-
-///
-/// Device Path protocol.
-///
-#define EFI_DEVICE_PATH_PROTOCOL_GUID \
-  { \
-    0x9576e91, 0x6d3f, 0x11d2, {0x8e, 0x39, 0x0, 0xa0, 0xc9, 0x69, 0x72, 0x3b } \
-  }
-
-///
-/// Device Path guid definition for backward-compatible with EFI1.1.
-///
-#define DEVICE_PATH_PROTOCOL  EFI_DEVICE_PATH_PROTOCOL_GUID
-
-#pragma pack(1)
-
-/**
-  This protocol can be used on any device handle to obtain generic path/location
-  information concerning the physical device or logical device. If the handle does
-  not logically map to a physical device, the handle may not necessarily support
-  the device path protocol. The device path describes the location of the device
-  the handle is for. The size of the Device Path can be determined from the structures
-  that make up the Device Path.
-**/
-typedef struct {
-  UINT8 Type;       ///< 0x01 Hardware Device Path.
-                    ///< 0x02 ACPI Device Path.
-                    ///< 0x03 Messaging Device Path.
-                    ///< 0x04 Media Device Path.
-                    ///< 0x05 BIOS Boot Specification Device Path.
-                    ///< 0x7F End of Hardware Device Path.
-
-  UINT8 SubType;    ///< Varies by Type
-                    ///< 0xFF End Entire Device Path, or
-                    ///< 0x01 End This Instance of a Device Path and start a new
-                    ///< Device Path.
-
-  UINT8 Length[2];  ///< Specific Device Path data. Type and Sub-Type define
-                    ///< type of data. Size of data is included in Length.
-
-} EFI_DEVICE_PATH_PROTOCOL;
-
-///
-/// Device Path protocol definition for backward-compatible with EFI1.1.
-///
-typedef EFI_DEVICE_PATH_PROTOCOL  EFI_DEVICE_PATH;
-
-///
-/// Hardware Device Paths.
-///
-#define HARDWARE_DEVICE_PATH      0x01
-
-///
-/// PCI Device Path SubType.
-///
-#define HW_PCI_DP                 0x01
-
-///
-/// PCI Device Path.
-///
-typedef struct {
-  EFI_DEVICE_PATH_PROTOCOL        Header;
-  ///
-  /// PCI Function Number.
-  ///
-  UINT8                           Function;
-  ///
-  /// PCI Device Number.
-  ///
-  UINT8                           Device;
-} PCI_DEVICE_PATH;
-
-///
-/// PCCARD Device Path SubType.
-///
-#define HW_PCCARD_DP              0x02
-
-///
-/// PCCARD Device Path.
-///
-typedef struct {
-  EFI_DEVICE_PATH_PROTOCOL        Header;
-  ///
-  /// Function Number (0 = First Function).
-  ///
-  UINT8                           FunctionNumber;
-} PCCARD_DEVICE_PATH;
-
-///
-/// Memory Mapped Device Path SubType.
-///
-#define HW_MEMMAP_DP              0x03
-
-///
-/// Memory Mapped Device Path.
-///
-typedef struct {
-  EFI_DEVICE_PATH_PROTOCOL        Header;
-  ///
-  /// EFI_MEMORY_TYPE
-  ///
-  UINT32                          MemoryType;
-  ///
-  /// Starting Memory Address.
-  ///
-  EFI_PHYSICAL_ADDRESS            StartingAddress;
-  ///
-  /// Ending Memory Address.
-  ///
-  EFI_PHYSICAL_ADDRESS            EndingAddress;
-} MEMMAP_DEVICE_PATH;
-
-///
-/// Hardware Vendor Device Path SubType.
-///
-#define HW_VENDOR_DP              0x04
-
-///
-/// The Vendor Device Path allows the creation of vendor-defined Device Paths. A vendor must
-/// allocate a Vendor GUID for a Device Path. The Vendor GUID can then be used to define the
-/// contents on the n bytes that follow in the Vendor Device Path node.
-///
-typedef struct {
-  EFI_DEVICE_PATH_PROTOCOL        Header;
-  ///
-  /// Vendor-assigned GUID that defines the data that follows.
-  ///
-  EFI_GUID                        Guid;
-  ///
-  /// Vendor-defined variable size data.
-  ///
-} VENDOR_DEVICE_PATH;
-
-///
-/// Controller Device Path SubType.
-///
-#define HW_CONTROLLER_DP          0x05
-
-///
-/// Controller Device Path.
-///
-typedef struct {
-  EFI_DEVICE_PATH_PROTOCOL        Header;
-  ///
-  /// Controller number.
-  ///
-  UINT32                          ControllerNumber;
-} CONTROLLER_DEVICE_PATH;
-
-///
-/// ACPI Device Paths.
-///
-#define ACPI_DEVICE_PATH          0x02
-
-///
-/// ACPI Device Path SubType.
-///
-#define ACPI_DP                   0x01
-typedef struct {
-  EFI_DEVICE_PATH_PROTOCOL        Header;
-  ///
-  /// Device's PnP hardware ID stored in a numeric 32-bit
-  /// compressed EISA-type ID. This value must match the
-  /// corresponding _HID in the ACPI name space.
-  ///
-  UINT32                          HID;
-  ///
-  /// Unique ID that is required by ACPI if two devices have the
-  /// same _HID. This value must also match the corresponding
-  /// _UID/_HID pair in the ACPI name space. Only the 32-bit
-  /// numeric value type of _UID is supported. Thus, strings must
-  /// not be used for the _UID in the ACPI name space.
-  ///
-  UINT32                          UID;
-} ACPI_HID_DEVICE_PATH;
-
-///
-/// Expanded ACPI Device Path SubType.
-///
-#define ACPI_EXTENDED_DP          0x02
-typedef struct {
-  EFI_DEVICE_PATH_PROTOCOL        Header;
-  ///
-  /// Device's PnP hardware ID stored in a numeric 32-bit
-  /// compressed EISA-type ID. This value must match the
-  /// corresponding _HID in the ACPI name space.
-  ///
-  UINT32                          HID;
-  ///
-  /// Unique ID that is required by ACPI if two devices have the
-  /// same _HID. This value must also match the corresponding
-  /// _UID/_HID pair in the ACPI name space.
-  ///
-  UINT32                          UID;
-  ///
-  /// Device's compatible PnP hardware ID stored in a numeric
-  /// 32-bit compressed EISA-type ID. This value must match at
-  /// least one of the compatible device IDs returned by the
-  /// corresponding _CID in the ACPI name space.
-  ///
-  UINT32                          CID;
-  ///
-  /// Optional variable length _HIDSTR.
-  /// Optional variable length _UIDSTR.
-  /// Optional variable length _CIDSTR.
-  ///
-} ACPI_EXTENDED_HID_DEVICE_PATH;
-
-//
-//  EISA ID Macro
-//  EISA ID Definition 32-bits
-//   bits[15:0] - three character compressed ASCII EISA ID.
-//   bits[31:16] - binary number
-//    Compressed ASCII is 5 bits per character 0b00001 = 'A' 0b11010 = 'Z'
-//
-#define PNP_EISA_ID_CONST         0x41d0
-#define EISA_ID(_Name, _Num)      ((UINT32)((_Name) | (_Num) << 16))
-#define EISA_PNP_ID(_PNPId)       (EISA_ID(PNP_EISA_ID_CONST, (_PNPId)))
-#define EFI_PNP_ID(_PNPId)        (EISA_ID(PNP_EISA_ID_CONST, (_PNPId)))
-
-#define PNP_EISA_ID_MASK          0xffff
-#define EISA_ID_TO_NUM(_Id)       ((_Id) >> 16)
-
-///
-/// ACPI _ADR Device Path SubType.
-///
-#define ACPI_ADR_DP               0x03
-
-///
-/// The _ADR device path is used to contain video output device attributes to support the Graphics
-/// Output Protocol. The device path can contain multiple _ADR entries if multiple video output
-/// devices are displaying the same output.
-///
-typedef struct {
-  EFI_DEVICE_PATH_PROTOCOL        Header;
-  ///
-  /// _ADR value. For video output devices the value of this
-  /// field comes from Table B-2 of the ACPI 3.0 specification. At
-  /// least one _ADR value is required.
-  ///
-  UINT32                          ADR;
-  //
-  // This device path may optionally contain more than one _ADR entry.
-  //
-} ACPI_ADR_DEVICE_PATH;
-
-#define ACPI_ADR_DISPLAY_TYPE_OTHER             0
-#define ACPI_ADR_DISPLAY_TYPE_VGA               1
-#define ACPI_ADR_DISPLAY_TYPE_TV                2
-#define ACPI_ADR_DISPLAY_TYPE_EXTERNAL_DIGITAL  3
-#define ACPI_ADR_DISPLAY_TYPE_INTERNAL_DIGITAL  4
-
-#define ACPI_DISPLAY_ADR(_DeviceIdScheme, _HeadId, _NonVgaOutput, _BiosCanDetect, _VendorInfo, _Type, _Port, _Index) \
-          ((UINT32)( (((_DeviceIdScheme) & 0x1) << 31) |  \
-                      (((_HeadId)         & 0x7) << 18) |  \
-                      (((_NonVgaOutput)   & 0x1) << 17) |  \
-                      (((_BiosCanDetect)  & 0x1) << 16) |  \
-                      (((_VendorInfo)     & 0xf) << 12) |  \
-                      (((_Type)           & 0xf) << 8)  |  \
-                      (((_Port)           & 0xf) << 4)  |  \
-                       ((_Index)          & 0xf) ))
-
-///
-/// Messaging Device Paths.
-/// This Device Path is used to describe the connection of devices outside the resource domain of the
-/// system. This Device Path can describe physical messaging information like SCSI ID, or abstract
-/// information like networking protocol IP addresses.
-///
-#define MESSAGING_DEVICE_PATH     0x03
-
-///
-/// ATAPI Device Path SubType
-///
-#define MSG_ATAPI_DP              0x01
-typedef struct {
-  EFI_DEVICE_PATH_PROTOCOL        Header;
-  ///
-  /// Set to zero for primary, or one for secondary.
-  ///
-  UINT8                           PrimarySecondary;
-  ///
-  /// Set to zero for master, or one for slave mode.
-  ///
-  UINT8                           SlaveMaster;
-  ///
-  /// Logical Unit Number.
-  ///
-  UINT16                          Lun;
-} ATAPI_DEVICE_PATH;
-
-///
-/// SCSI Device Path SubType.
-///
-#define MSG_SCSI_DP               0x02
-typedef struct {
-  EFI_DEVICE_PATH_PROTOCOL        Header;
-  ///
-  /// Target ID on the SCSI bus (PUN).
-  ///
-  UINT16                          Pun;
-  ///
-  /// Logical Unit Number (LUN).
-  ///
-  UINT16                          Lun;
-} SCSI_DEVICE_PATH;
-
-///
-/// Fibre Channel SubType.
-///
-#define MSG_FIBRECHANNEL_DP       0x03
-typedef struct {
-  EFI_DEVICE_PATH_PROTOCOL        Header;
-  ///
-  /// Reserved for the future.
-  ///
-  UINT32                          Reserved;
-  ///
-  /// Fibre Channel World Wide Number.
-  ///
-  UINT64                          WWN;
-  ///
-  /// Fibre Channel Logical Unit Number.
-  ///
-  UINT64                          Lun;
-} FIBRECHANNEL_DEVICE_PATH;
-
-///
-/// Fibre Channel Ex SubType.
-///
-#define MSG_FIBRECHANNELEX_DP     0x15
-typedef struct {
-  EFI_DEVICE_PATH_PROTOCOL        Header;
-  ///
-  /// Reserved for the future.
-  ///
-  UINT32                          Reserved;
-  ///
-  /// 8 byte array containing Fibre Channel End Device Port Name.
-  ///
-  UINT8                           WWN[8];
-  ///
-  /// 8 byte array containing Fibre Channel Logical Unit Number.
-  ///
-  UINT8                           Lun[8];
-} FIBRECHANNELEX_DEVICE_PATH;
-
-///
-/// 1394 Device Path SubType
-///
-#define MSG_1394_DP               0x04
-typedef struct {
-  EFI_DEVICE_PATH_PROTOCOL        Header;
-  ///
-  /// Reserved for the future.
-  ///
-  UINT32                          Reserved;
-  ///
-  /// 1394 Global Unique ID (GUID).
-  ///
-  UINT64                          Guid;
-} F1394_DEVICE_PATH;
-
-///
-/// USB Device Path SubType.
-///
-#define MSG_USB_DP                0x05
-typedef struct {
-  EFI_DEVICE_PATH_PROTOCOL      Header;
-  ///
-  /// USB Parent Port Number.
-  ///
-  UINT8                         ParentPortNumber;
-  ///
-  /// USB Interface Number.
-  ///
-  UINT8                         InterfaceNumber;
-} USB_DEVICE_PATH;
-
-///
-/// USB Class Device Path SubType.
-///
-#define MSG_USB_CLASS_DP          0x0f
-typedef struct {
-  EFI_DEVICE_PATH_PROTOCOL      Header;
-  ///
-  /// Vendor ID assigned by USB-IF. A value of 0xFFFF will
-  /// match any Vendor ID.
-  ///
-  UINT16                        VendorId;
-  ///
-  /// Product ID assigned by USB-IF. A value of 0xFFFF will
-  /// match any Product ID.
-  ///
-  UINT16                        ProductId;
-  ///
-  /// The class code assigned by the USB-IF. A value of 0xFF
-  /// will match any class code.
-  ///
-  UINT8                         DeviceClass;
-  ///
-  /// The subclass code assigned by the USB-IF. A value of
-  /// 0xFF will match any subclass code.
-  ///
-  UINT8                         DeviceSubClass;
-  ///
-  /// The protocol code assigned by the USB-IF. A value of
-  /// 0xFF will match any protocol code.
-  ///
-  UINT8                         DeviceProtocol;
-} USB_CLASS_DEVICE_PATH;
-
-///
-/// USB WWID Device Path SubType.
-///
-#define MSG_USB_WWID_DP           0x10
-
-///
-/// This device path describes a USB device using its serial number.
-///
-typedef struct {
-  EFI_DEVICE_PATH_PROTOCOL      Header;
-  ///
-  /// USB interface number.
-  ///
-  UINT16                        InterfaceNumber;
-  ///
-  /// USB vendor id of the device.
-  ///
-  UINT16                        VendorId;
-  ///
-  /// USB product id of the device.
-  ///
-  UINT16                        ProductId;
-  ///
-  /// Last 64-or-fewer UTF-16 characters of the USB
-  /// serial number. The length of the string is
-  /// determined by the Length field less the offset of the
-  /// Serial Number field (10)
-  ///
-  /// CHAR16                     SerialNumber[...];
-} USB_WWID_DEVICE_PATH;
-
-///
-/// Device Logical Unit SubType.
-///
-#define MSG_DEVICE_LOGICAL_UNIT_DP  0x11
-typedef struct {
-  EFI_DEVICE_PATH_PROTOCOL      Header;
-  ///
-  /// Logical Unit Number for the interface.
-  ///
-  UINT8                         Lun;
-} DEVICE_LOGICAL_UNIT_DEVICE_PATH;
-
-///
-/// SATA Device Path SubType.
-///
-#define MSG_SATA_DP               0x12
-typedef struct {
-  EFI_DEVICE_PATH_PROTOCOL        Header;
-  ///
-  /// The HBA port number that facilitates the connection to the
-  /// device or a port multiplier. The value 0xFFFF is reserved.
-  ///
-  UINT16                          HBAPortNumber;
-  ///
-  /// The Port multiplier port number that facilitates the connection
-  /// to the device. Bit 15 should be set if the device is directly
-  /// connected to the HBA.
-  ///
-  UINT16                          PortMultiplierPortNumber;
-  ///
-  /// Logical Unit Number.
-  ///
-  UINT16                          Lun;
-} SATA_DEVICE_PATH;
-
-///
-/// Flag for if the device is directly connected to the HBA.
-///
-#define SATA_HBA_DIRECT_CONNECT_FLAG 0x8000
-
-///
-/// I2O Device Path SubType.
-///
-#define MSG_I2O_DP                0x06
-typedef struct {
-  EFI_DEVICE_PATH_PROTOCOL        Header;
-  ///
-  /// Target ID (TID) for a device.
-  ///
-  UINT32                          Tid;
-} I2O_DEVICE_PATH;
-
-///
-/// MAC Address Device Path SubType.
-///
-#define MSG_MAC_ADDR_DP           0x0b
-typedef struct {
-  EFI_DEVICE_PATH_PROTOCOL        Header;
-  ///
-  /// The MAC address for a network interface padded with 0s.
-  ///
-  EFI_MAC_ADDRESS                 MacAddress;
-  ///
-  /// Network interface type(i.e. 802.3, FDDI).
-  ///
-  UINT8                           IfType;
-} MAC_ADDR_DEVICE_PATH;
-
-///
-/// IPv4 Device Path SubType
-///
-#define MSG_IPv4_DP               0x0c
-typedef struct {
-  EFI_DEVICE_PATH_PROTOCOL        Header;
-  ///
-  /// The local IPv4 address.
-  ///
-  EFI_IPv4_ADDRESS                LocalIpAddress;
-  ///
-  /// The remote IPv4 address.
-  ///
-  EFI_IPv4_ADDRESS                RemoteIpAddress;
-  ///
-  /// The local port number.
-  ///
-  UINT16                          LocalPort;
-  ///
-  /// The remote port number.
-  ///
-  UINT16                          RemotePort;
-  ///
-  /// The network protocol(i.e. UDP, TCP).
-  ///
-  UINT16                          Protocol;
-  ///
-  /// 0x00 - The Source IP Address was assigned though DHCP.
-  /// 0x01 - The Source IP Address is statically bound.
-  ///
-  BOOLEAN                         StaticIpAddress;
-  ///
-  /// The gateway IP address
-  ///
-  EFI_IPv4_ADDRESS                GatewayIpAddress;
-  ///
-  /// The subnet mask
-  ///
-  EFI_IPv4_ADDRESS                SubnetMask;
-} IPv4_DEVICE_PATH;
-
-///
-/// IPv6 Device Path SubType.
-///
-#define MSG_IPv6_DP               0x0d
-typedef struct {
-  EFI_DEVICE_PATH_PROTOCOL        Header;
-  ///
-  /// The local IPv6 address.
-  ///
-  EFI_IPv6_ADDRESS                LocalIpAddress;
-  ///
-  /// The remote IPv6 address.
-  ///
-  EFI_IPv6_ADDRESS                RemoteIpAddress;
-  ///
-  /// The local port number.
-  ///
-  UINT16                          LocalPort;
-  ///
-  /// The remote port number.
-  ///
-  UINT16                          RemotePort;
-  ///
-  /// The network protocol(i.e. UDP, TCP).
-  ///
-  UINT16                          Protocol;
-  ///
-  /// 0x00 - The Local IP Address was manually configured.
-  /// 0x01 - The Local IP Address is assigned through IPv6
-  /// stateless auto-configuration.
-  /// 0x02 - The Local IP Address is assigned through IPv6
-  /// stateful configuration.
-  ///
-  UINT8                           IpAddressOrigin;
-  ///
-  /// The prefix length
-  ///
-  UINT8                           PrefixLength;
-  ///
-  /// The gateway IP address
-  ///
-  EFI_IPv6_ADDRESS                GatewayIpAddress;
-} IPv6_DEVICE_PATH;
-
-///
-/// InfiniBand Device Path SubType.
-///
-#define MSG_INFINIBAND_DP         0x09
-typedef struct {
-  EFI_DEVICE_PATH_PROTOCOL        Header;
-  ///
-  /// Flags to help identify/manage InfiniBand device path elements:
-  /// Bit 0 - IOC/Service (0b = IOC, 1b = Service).
-  /// Bit 1 - Extend Boot Environment.
-  /// Bit 2 - Console Protocol.
-  /// Bit 3 - Storage Protocol.
-  /// Bit 4 - Network Protocol.
-  /// All other bits are reserved.
-  ///
-  UINT32                          ResourceFlags;
-  ///
-  /// 128-bit Global Identifier for remote fabric port.
-  ///
-  UINT8                           PortGid[16];
-  ///
-  /// 64-bit unique identifier to remote IOC or server process.
-  /// Interpretation of field specified by Resource Flags (bit 0).
-  ///
-  UINT64                          ServiceId;
-  ///
-  /// 64-bit persistent ID of remote IOC port.
-  ///
-  UINT64                          TargetPortId;
-  ///
-  /// 64-bit persistent ID of remote device.
-  ///
-  UINT64                          DeviceId;
-} INFINIBAND_DEVICE_PATH;
-
-#define INFINIBAND_RESOURCE_FLAG_IOC_SERVICE                0x01
-#define INFINIBAND_RESOURCE_FLAG_EXTENDED_BOOT_ENVIRONMENT  0x02
-#define INFINIBAND_RESOURCE_FLAG_CONSOLE_PROTOCOL           0x04
-#define INFINIBAND_RESOURCE_FLAG_STORAGE_PROTOCOL           0x08
-#define INFINIBAND_RESOURCE_FLAG_NETWORK_PROTOCOL           0x10
-
-///
-/// UART Device Path SubType.
-///
-#define MSG_UART_DP               0x0e
-typedef struct {
-  EFI_DEVICE_PATH_PROTOCOL        Header;
-  ///
-  /// Reserved.
-  ///
-  UINT32                          Reserved;
-  ///
-  /// The baud rate setting for the UART style device. A value of 0
-  /// means that the device's default baud rate will be used.
-  ///
-  UINT64                          BaudRate;
-  ///
-  /// The number of data bits for the UART style device. A value
-  /// of 0 means that the device's default number of data bits will be used.
-  ///
-  UINT8                           DataBits;
-  ///
-  /// The parity setting for the UART style device.
-  /// Parity 0x00 - Default Parity.
-  /// Parity 0x01 - No Parity.
-  /// Parity 0x02 - Even Parity.
-  /// Parity 0x03 - Odd Parity.
-  /// Parity 0x04 - Mark Parity.
-  /// Parity 0x05 - Space Parity.
-  ///
-  UINT8                           Parity;
-  ///
-  /// The number of stop bits for the UART style device.
-  /// Stop Bits 0x00 - Default Stop Bits.
-  /// Stop Bits 0x01 - 1 Stop Bit.
-  /// Stop Bits 0x02 - 1.5 Stop Bits.
-  /// Stop Bits 0x03 - 2 Stop Bits.
-  ///
-  UINT8                           StopBits;
-} UART_DEVICE_PATH;
-
-//
-// Use VENDOR_DEVICE_PATH struct
-//
-#define MSG_VENDOR_DP             0x0a
-typedef VENDOR_DEVICE_PATH        VENDOR_DEFINED_DEVICE_PATH;
-
-#define DEVICE_PATH_MESSAGING_PC_ANSI     EFI_PC_ANSI_GUID
-#define DEVICE_PATH_MESSAGING_VT_100      EFI_VT_100_GUID
-#define DEVICE_PATH_MESSAGING_VT_100_PLUS EFI_VT_100_PLUS_GUID
-#define DEVICE_PATH_MESSAGING_VT_UTF8     EFI_VT_UTF8_GUID
-
-///
-/// A new device path node is defined to declare flow control characteristics.
-/// UART Flow Control Messaging Device Path
-///
-typedef struct {
-  EFI_DEVICE_PATH_PROTOCOL        Header;
-  ///
-  /// DEVICE_PATH_MESSAGING_UART_FLOW_CONTROL GUID.
-  ///
-  EFI_GUID                        Guid;
-  ///
-  /// Bitmap of supported flow control types.
-  /// Bit 0 set indicates hardware flow control.
-  /// Bit 1 set indicates Xon/Xoff flow control.
-  /// All other bits are reserved and are clear.
-  ///
-  UINT32                          FlowControlMap;
-} UART_FLOW_CONTROL_DEVICE_PATH;
-
-#define UART_FLOW_CONTROL_HARDWARE         0x00000001
-#define UART_FLOW_CONTROL_XON_XOFF         0x00000010
-
-#define DEVICE_PATH_MESSAGING_SAS          EFI_SAS_DEVICE_PATH_GUID
-///
-/// Serial Attached SCSI (SAS) Device Path.
-///
-typedef struct {
-  EFI_DEVICE_PATH_PROTOCOL        Header;
-  ///
-  /// DEVICE_PATH_MESSAGING_SAS GUID.
-  ///
-  EFI_GUID                        Guid;
-  ///
-  /// Reserved for future use.
-  ///
-  UINT32                          Reserved;
-  ///
-  /// SAS Address for Serial Attached SCSI Target.
-  ///
-  UINT64                          SasAddress;
-  ///
-  /// SAS Logical Unit Number.
-  ///
-  UINT64                          Lun;
-  ///
-  /// More Information about the device and its interconnect.
-  ///
-  UINT16                          DeviceTopology;
-  ///
-  /// Relative Target Port (RTP).
-  ///
-  UINT16                          RelativeTargetPort;
-} SAS_DEVICE_PATH;
-
-///
-/// Serial Attached SCSI (SAS) Ex Device Path SubType
-///
-#define MSG_SASEX_DP              0x16
-typedef struct {
-  EFI_DEVICE_PATH_PROTOCOL        Header;
-  ///
-  /// 8-byte array of the SAS Address for Serial Attached SCSI Target Port.
-  ///
-  UINT8                           SasAddress[8];
-  ///
-  /// 8-byte array of the SAS Logical Unit Number.
-  ///
-  UINT8                           Lun[8];
-  ///
-  /// More Information about the device and its interconnect.
-  ///
-  UINT16                          DeviceTopology;
-  ///
-  /// Relative Target Port (RTP).
-  ///
-  UINT16                          RelativeTargetPort;
-} SASEX_DEVICE_PATH;
-
-///
-/// NvmExpress Namespace Device Path SubType.
-///
-#define MSG_NVME_NAMESPACE_DP     0x17
-typedef struct {
-  EFI_DEVICE_PATH_PROTOCOL        Header;
-  UINT32                          NamespaceId;
-  UINT64                          NamespaceUuid;
-} NVME_NAMESPACE_DEVICE_PATH;
-
-///
-/// iSCSI Device Path SubType
-///
-#define MSG_ISCSI_DP              0x13
-typedef struct {
-  EFI_DEVICE_PATH_PROTOCOL        Header;
-  ///
-  /// Network Protocol (0 = TCP, 1+ = reserved).
-  ///
-  UINT16                          NetworkProtocol;
-  ///
-  /// iSCSI Login Options.
-  ///
-  UINT16                          LoginOption;
-  ///
-  /// iSCSI Logical Unit Number.
-  ///
-  UINT64                          Lun;
-  ///
-  /// iSCSI Target Portal group tag the initiator intends
-  /// to establish a session with.
-  ///
-  UINT16                          TargetPortalGroupTag;
-  ///
-  /// iSCSI NodeTarget Name. The length of the name
-  /// is determined by subtracting the offset of this field from Length.
-  ///
-  /// CHAR8                        iSCSI Target Name.
-} ISCSI_DEVICE_PATH;
-
-#define ISCSI_LOGIN_OPTION_NO_HEADER_DIGEST             0x0000
-#define ISCSI_LOGIN_OPTION_HEADER_DIGEST_USING_CRC32C   0x0002
-#define ISCSI_LOGIN_OPTION_NO_DATA_DIGEST               0x0000
-#define ISCSI_LOGIN_OPTION_DATA_DIGEST_USING_CRC32C     0x0008
-#define ISCSI_LOGIN_OPTION_AUTHMETHOD_CHAP              0x0000
-#define ISCSI_LOGIN_OPTION_AUTHMETHOD_NON               0x1000
-#define ISCSI_LOGIN_OPTION_CHAP_BI                      0x0000
-#define ISCSI_LOGIN_OPTION_CHAP_UNI                     0x2000
-
-///
-/// VLAN Device Path SubType.
-///
-#define MSG_VLAN_DP               0x14
-typedef struct {
-  EFI_DEVICE_PATH_PROTOCOL        Header;
-  ///
-  /// VLAN identifier (0-4094).
-  ///
-  UINT16                          VlanId;
-} VLAN_DEVICE_PATH;
-
-//
-// Media Device Path
-//
-#define MEDIA_DEVICE_PATH         0x04
-
-///
-/// Hard Drive Media Device Path SubType.
-///
-#define MEDIA_HARDDRIVE_DP        0x01
-
-///
-/// The Hard Drive Media Device Path is used to represent a partition on a hard drive.
-///
-typedef struct {
-  EFI_DEVICE_PATH_PROTOCOL        Header;
-  ///
-  /// Describes the entry in a partition table, starting with entry 1.
-  /// Partition number zero represents the entire device. Valid
-  /// partition numbers for a MBR partition are [1, 4]. Valid
-  /// partition numbers for a GPT partition are [1, NumberOfPartitionEntries].
-  ///
-  UINT32                          PartitionNumber;
-  ///
-  /// Starting LBA of the partition on the hard drive.
-  ///
-  UINT64                          PartitionStart;
-  ///
-  /// Size of the partition in units of Logical Blocks.
-  ///
-  UINT64                          PartitionSize;
-  ///
-  /// Signature unique to this partition:
-  /// If SignatureType is 0, this field has to be initialized with 16 zeros.
-  /// If SignatureType is 1, the MBR signature is stored in the first 4 bytes of this field.
-  /// The other 12 bytes are initialized with zeros.
-  /// If SignatureType is 2, this field contains a 16 byte signature.
-  ///
-  UINT8                           Signature[16];
-  ///
-  /// Partition Format: (Unused values reserved).
-  /// 0x01 - PC-AT compatible legacy MBR.
-  /// 0x02 - GUID Partition Table.
-  ///
-  UINT8                           MBRType;
-  ///
-  /// Type of Disk Signature: (Unused values reserved).
-  /// 0x00 - No Disk Signature.
-  /// 0x01 - 32-bit signature from address 0x1b8 of the type 0x01 MBR.
-  /// 0x02 - GUID signature.
-  ///
-  UINT8                           SignatureType;
-} HARDDRIVE_DEVICE_PATH;
-
-#define MBR_TYPE_PCAT             0x01
-#define MBR_TYPE_EFI_PARTITION_TABLE_HEADER 0x02
-
-#define NO_DISK_SIGNATURE         0x00
-#define SIGNATURE_TYPE_MBR        0x01
-#define SIGNATURE_TYPE_GUID       0x02
-
-///
-/// CD-ROM Media Device Path SubType.
-///
-#define MEDIA_CDROM_DP            0x02
-
-///
-/// The CD-ROM Media Device Path is used to define a system partition that exists on a CD-ROM.
-///
-typedef struct {
-  EFI_DEVICE_PATH_PROTOCOL        Header;
-  ///
-  /// Boot Entry number from the Boot Catalog. The Initial/Default entry is defined as zero.
-  ///
-  UINT32                          BootEntry;
-  ///
-  /// Starting RBA of the partition on the medium. CD-ROMs use Relative logical Block Addressing.
-  ///
-  UINT64                          PartitionStart;
-  ///
-  /// Size of the partition in units of Blocks, also called Sectors.
-  ///
-  UINT64                          PartitionSize;
-} CDROM_DEVICE_PATH;
-
-//
-// Use VENDOR_DEVICE_PATH struct
-//
-#define MEDIA_VENDOR_DP           0x03  ///< Media vendor device path subtype.
-
-///
-/// File Path Media Device Path SubType
-///
-#define MEDIA_FILEPATH_DP         0x04
-typedef struct {
-  EFI_DEVICE_PATH_PROTOCOL        Header;
-  ///
-  /// A NULL-terminated Path string including directory and file names.
-  ///
-  CHAR16                          PathName[1];
-} FILEPATH_DEVICE_PATH;
-
-#define SIZE_OF_FILEPATH_DEVICE_PATH  OFFSET_OF(FILEPATH_DEVICE_PATH,PathName)
-
-///
-/// Media Protocol Device Path SubType.
-///
-#define MEDIA_PROTOCOL_DP         0x05
-
-///
-/// The Media Protocol Device Path is used to denote the protocol that is being
-/// used in a device path at the location of the path specified.
-/// Many protocols are inherent to the style of device path.
-///
-typedef struct {
-  EFI_DEVICE_PATH_PROTOCOL        Header;
-  ///
-  /// The ID of the protocol.
-  ///
-  EFI_GUID                        Protocol;
-} MEDIA_PROTOCOL_DEVICE_PATH;
-
-///
-/// PIWG Firmware File SubType.
-///
-#define MEDIA_PIWG_FW_FILE_DP     0x06
-
-///
-/// This device path is used by systems implementing the UEFI PI Specification 1.0 to describe a firmware file.
-///
-typedef struct {
-  EFI_DEVICE_PATH_PROTOCOL        Header;
-  ///
-  /// Firmware file name
-  ///
-  EFI_GUID                        FvFileName;
-} MEDIA_FW_VOL_FILEPATH_DEVICE_PATH;
-
-///
-/// PIWG Firmware Volume Device Path SubType.
-///
-#define MEDIA_PIWG_FW_VOL_DP      0x07
-
-///
-/// This device path is used by systems implementing the UEFI PI Specification 1.0 to describe a firmware volume.
-///
-typedef struct {
-  EFI_DEVICE_PATH_PROTOCOL        Header;
-  ///
-  /// Firmware volume name.
-  ///
-  EFI_GUID                        FvName;
-} MEDIA_FW_VOL_DEVICE_PATH;
-
-///
-/// Media relative offset range device path.
-///
-#define MEDIA_RELATIVE_OFFSET_RANGE_DP 0x08
-
-///
-/// Used to describe the offset range of media relative.
-///
-typedef struct {
-  EFI_DEVICE_PATH_PROTOCOL  Header;
-  UINT32                    Reserved;
-  UINT64                    StartingOffset;
-  UINT64                    EndingOffset;
-} MEDIA_RELATIVE_OFFSET_RANGE_DEVICE_PATH;
-
-///
-/// BIOS Boot Specification Device Path.
-///
-#define BBS_DEVICE_PATH           0x05
-
-///
-/// BIOS Boot Specification Device Path SubType.
-///
-#define BBS_BBS_DP                0x01
-
-///
-/// This Device Path is used to describe the booting of non-EFI-aware operating systems.
-///
-typedef struct {
-  EFI_DEVICE_PATH_PROTOCOL        Header;
-  ///
-  /// Device Type as defined by the BIOS Boot Specification.
-  ///
-  UINT16                          DeviceType;
-  ///
-  /// Status Flags as defined by the BIOS Boot Specification.
-  ///
-  UINT16                          StatusFlag;
-  ///
-  /// Null-terminated ASCII string that describes the boot device to a user.
-  ///
-  CHAR8                           String[1];
-} BBS_BBS_DEVICE_PATH;
-
-//
-// DeviceType definitions - from BBS specification
-//
-#define BBS_TYPE_FLOPPY           0x01
-#define BBS_TYPE_HARDDRIVE        0x02
-#define BBS_TYPE_CDROM            0x03
-#define BBS_TYPE_PCMCIA           0x04
-#define BBS_TYPE_USB              0x05
-#define BBS_TYPE_EMBEDDED_NETWORK 0x06
-#define BBS_TYPE_BEV              0x80
-#define BBS_TYPE_UNKNOWN          0xFF
-
-
-///
-/// Union of all possible Device Paths and pointers to Device Paths.
-///
-typedef union {
-  EFI_DEVICE_PATH_PROTOCOL                   DevPath;
-  PCI_DEVICE_PATH                            Pci;
-  PCCARD_DEVICE_PATH                         PcCard;
-  MEMMAP_DEVICE_PATH                         MemMap;
-  VENDOR_DEVICE_PATH                         Vendor;
-
-  CONTROLLER_DEVICE_PATH                     Controller;
-  ACPI_HID_DEVICE_PATH                       Acpi;
-  ACPI_EXTENDED_HID_DEVICE_PATH              ExtendedAcpi;
-  ACPI_ADR_DEVICE_PATH                       AcpiAdr;
-
-  ATAPI_DEVICE_PATH                          Atapi;
-  SCSI_DEVICE_PATH                           Scsi;
-  ISCSI_DEVICE_PATH                          Iscsi;
-  FIBRECHANNEL_DEVICE_PATH                   FibreChannel;
-  FIBRECHANNELEX_DEVICE_PATH                 FibreChannelEx;
-
-  F1394_DEVICE_PATH                          F1394;
-  USB_DEVICE_PATH                            Usb;
-  SATA_DEVICE_PATH                           Sata;
-  USB_CLASS_DEVICE_PATH                      UsbClass;
-  USB_WWID_DEVICE_PATH                       UsbWwid;
-  DEVICE_LOGICAL_UNIT_DEVICE_PATH            LogicUnit;
-  I2O_DEVICE_PATH                            I2O;
-  MAC_ADDR_DEVICE_PATH                       MacAddr;
-  IPv4_DEVICE_PATH                           Ipv4;
-  IPv6_DEVICE_PATH                           Ipv6;
-  VLAN_DEVICE_PATH                           Vlan;
-  INFINIBAND_DEVICE_PATH                     InfiniBand;
-  UART_DEVICE_PATH                           Uart;
-  UART_FLOW_CONTROL_DEVICE_PATH              UartFlowControl;
-  SAS_DEVICE_PATH                            Sas;
-  SASEX_DEVICE_PATH                          SasEx;
-  NVME_NAMESPACE_DEVICE_PATH                 NvmeNamespace;
-  HARDDRIVE_DEVICE_PATH                      HardDrive;
-  CDROM_DEVICE_PATH                          CD;
-
-  FILEPATH_DEVICE_PATH                       FilePath;
-  MEDIA_PROTOCOL_DEVICE_PATH                 MediaProtocol;
-
-  MEDIA_FW_VOL_DEVICE_PATH                   FirmwareVolume;
-  MEDIA_FW_VOL_FILEPATH_DEVICE_PATH          FirmwareFile;
-  MEDIA_RELATIVE_OFFSET_RANGE_DEVICE_PATH    Offset;
-
-  BBS_BBS_DEVICE_PATH                        Bbs;
-} EFI_DEV_PATH;
-
-
-
-typedef union {
-  EFI_DEVICE_PATH_PROTOCOL                   *DevPath;
-  PCI_DEVICE_PATH                            *Pci;
-  PCCARD_DEVICE_PATH                         *PcCard;
-  MEMMAP_DEVICE_PATH                         *MemMap;
-  VENDOR_DEVICE_PATH                         *Vendor;
-
-  CONTROLLER_DEVICE_PATH                     *Controller;
-  ACPI_HID_DEVICE_PATH                       *Acpi;
-  ACPI_EXTENDED_HID_DEVICE_PATH              *ExtendedAcpi;
-  ACPI_ADR_DEVICE_PATH                       *AcpiAdr;
-
-  ATAPI_DEVICE_PATH                          *Atapi;
-  SCSI_DEVICE_PATH                           *Scsi;
-  ISCSI_DEVICE_PATH                          *Iscsi;
-  FIBRECHANNEL_DEVICE_PATH                   *FibreChannel;
-  FIBRECHANNELEX_DEVICE_PATH                 *FibreChannelEx;
-
-  F1394_DEVICE_PATH                          *F1394;
-  USB_DEVICE_PATH                            *Usb;
-  SATA_DEVICE_PATH                           *Sata;
-  USB_CLASS_DEVICE_PATH                      *UsbClass;
-  USB_WWID_DEVICE_PATH                       *UsbWwid;
-  DEVICE_LOGICAL_UNIT_DEVICE_PATH            *LogicUnit;
-  I2O_DEVICE_PATH                            *I2O;
-  MAC_ADDR_DEVICE_PATH                       *MacAddr;
-  IPv4_DEVICE_PATH                           *Ipv4;
-  IPv6_DEVICE_PATH                           *Ipv6;
-  VLAN_DEVICE_PATH                           *Vlan;
-  INFINIBAND_DEVICE_PATH                     *InfiniBand;
-  UART_DEVICE_PATH                           *Uart;
-  UART_FLOW_CONTROL_DEVICE_PATH              *UartFlowControl;
-  SAS_DEVICE_PATH                            *Sas;
-  SASEX_DEVICE_PATH                          *SasEx;
-  NVME_NAMESPACE_DEVICE_PATH                 *NvmeNamespace;
-  HARDDRIVE_DEVICE_PATH                      *HardDrive;
-  CDROM_DEVICE_PATH                          *CD;
-
-  FILEPATH_DEVICE_PATH                       *FilePath;
-  MEDIA_PROTOCOL_DEVICE_PATH                 *MediaProtocol;
-
-  MEDIA_FW_VOL_DEVICE_PATH                   *FirmwareVolume;
-  MEDIA_FW_VOL_FILEPATH_DEVICE_PATH          *FirmwareFile;
-  MEDIA_RELATIVE_OFFSET_RANGE_DEVICE_PATH    *Offset;
-
-  BBS_BBS_DEVICE_PATH                        *Bbs;
-  UINT8                                      *Raw;
-} EFI_DEV_PATH_PTR;
-
-#pragma pack()
-
-#define END_DEVICE_PATH_TYPE                 0x7f
-#define END_ENTIRE_DEVICE_PATH_SUBTYPE       0xFF
-#define END_INSTANCE_DEVICE_PATH_SUBTYPE     0x01
-
-extern EFI_GUID gEfiDevicePathProtocolGuid;
-
-#endif
diff --git a/src/efi/Protocol/GraphicsOutput.h b/src/efi/Protocol/GraphicsOutput.h
deleted file mode 100644
index 0621b57..0000000
--- a/src/efi/Protocol/GraphicsOutput.h
+++ /dev/null
@@ -1,276 +0,0 @@
-/** @file
-  Graphics Output Protocol from the UEFI 2.0 specification.
-
-  Abstraction of a very simple graphics device.
-
-  Copyright (c) 2006 - 2012, Intel Corporation. All rights reserved.<BR>
-  This program and the accompanying materials
-  are licensed and made available under the terms and conditions of the BSD License
-  which accompanies this distribution.  The full text of the license may be found at
-  http://opensource.org/licenses/bsd-license.php
-
-  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
-  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
-
-**/
-
-#ifndef __GRAPHICS_OUTPUT_H__
-#define __GRAPHICS_OUTPUT_H__
-
-#define EFI_GRAPHICS_OUTPUT_PROTOCOL_GUID \
-  { \
-    0x9042a9de, 0x23dc, 0x4a38, {0x96, 0xfb, 0x7a, 0xde, 0xd0, 0x80, 0x51, 0x6a } \
-  }
-
-typedef struct _EFI_GRAPHICS_OUTPUT_PROTOCOL EFI_GRAPHICS_OUTPUT_PROTOCOL;
-
-typedef struct {
-  UINT32            RedMask;
-  UINT32            GreenMask;
-  UINT32            BlueMask;
-  UINT32            ReservedMask;
-} EFI_PIXEL_BITMASK;
-
-typedef enum {
-  ///
-  /// A pixel is 32-bits and byte zero represents red, byte one represents green,
-  /// byte two represents blue, and byte three is reserved. This is the definition
-  /// for the physical frame buffer. The byte values for the red, green, and blue
-  /// components represent the color intensity. This color intensity value range
-  /// from a minimum intensity of 0 to maximum intensity of 255.
-  ///
-  PixelRedGreenBlueReserved8BitPerColor,
-  ///
-  /// A pixel is 32-bits and byte zero represents blue, byte one represents green,
-  /// byte two represents red, and byte three is reserved. This is the definition
-  /// for the physical frame buffer. The byte values for the red, green, and blue
-  /// components represent the color intensity. This color intensity value range
-  /// from a minimum intensity of 0 to maximum intensity of 255.
-  ///
-  PixelBlueGreenRedReserved8BitPerColor,
-  ///
-  /// The Pixel definition of the physical frame buffer.
-  ///
-  PixelBitMask,
-  ///
-  /// This mode does not support a physical frame buffer.
-  ///
-  PixelBltOnly,
-  ///
-  /// Valid EFI_GRAPHICS_PIXEL_FORMAT enum values are less than this value.
-  ///
-  PixelFormatMax
-} EFI_GRAPHICS_PIXEL_FORMAT;
-
-typedef struct {
-  ///
-  /// The version of this data structure. A value of zero represents the
-  /// EFI_GRAPHICS_OUTPUT_MODE_INFORMATION structure as defined in this specification.
-  ///
-  UINT32                     Version;
-  ///
-  /// The size of video screen in pixels in the X dimension.
-  ///
-  UINT32                     HorizontalResolution;
-  ///
-  /// The size of video screen in pixels in the Y dimension.
-  ///
-  UINT32                     VerticalResolution;
-  ///
-  /// Enumeration that defines the physical format of the pixel. A value of PixelBltOnly
-  /// implies that a linear frame buffer is not available for this mode.
-  ///
-  EFI_GRAPHICS_PIXEL_FORMAT  PixelFormat;
-  ///
-  /// This bit-mask is only valid if PixelFormat is set to PixelPixelBitMask.
-  /// A bit being set defines what bits are used for what purpose such as Red, Green, Blue, or Reserved.
-  ///
-  EFI_PIXEL_BITMASK          PixelInformation;
-  ///
-  /// Defines the number of pixel elements per video memory line.
-  ///
-  UINT32                     PixelsPerScanLine;
-} EFI_GRAPHICS_OUTPUT_MODE_INFORMATION;
-
-/**
-  Returns information for an available graphics mode that the graphics device
-  and the set of active video output devices supports.
-
-  @param  This                  The EFI_GRAPHICS_OUTPUT_PROTOCOL instance.
-  @param  ModeNumber            The mode number to return information on.
-  @param  SizeOfInfo            A pointer to the size, in bytes, of the Info buffer.
-  @param  Info                  A pointer to callee allocated buffer that returns information about ModeNumber.
-
-  @retval EFI_SUCCESS           Valid mode information was returned.
-  @retval EFI_DEVICE_ERROR      A hardware error occurred trying to retrieve the video mode.
-  @retval EFI_INVALID_PARAMETER ModeNumber is not valid.
-
-**/
-typedef
-EFI_STATUS
-(EFIAPI *EFI_GRAPHICS_OUTPUT_PROTOCOL_QUERY_MODE)(
-  IN  EFI_GRAPHICS_OUTPUT_PROTOCOL          *This,
-  IN  UINT32                                ModeNumber,
-  OUT UINTN                                 *SizeOfInfo,
-  OUT EFI_GRAPHICS_OUTPUT_MODE_INFORMATION  **Info
-  );
-
-/**
-  Set the video device into the specified mode and clears the visible portions of
-  the output display to black.
-
-  @param  This              The EFI_GRAPHICS_OUTPUT_PROTOCOL instance.
-  @param  ModeNumber        Abstraction that defines the current video mode.
-
-  @retval EFI_SUCCESS       The graphics mode specified by ModeNumber was selected.
-  @retval EFI_DEVICE_ERROR  The device had an error and could not complete the request.
-  @retval EFI_UNSUPPORTED   ModeNumber is not supported by this device.
-
-**/
-typedef
-EFI_STATUS
-(EFIAPI *EFI_GRAPHICS_OUTPUT_PROTOCOL_SET_MODE)(
-  IN  EFI_GRAPHICS_OUTPUT_PROTOCOL *This,
-  IN  UINT32                       ModeNumber
-  );
-
-typedef struct {
-  UINT8 Blue;
-  UINT8 Green;
-  UINT8 Red;
-  UINT8 Reserved;
-} EFI_GRAPHICS_OUTPUT_BLT_PIXEL;
-
-typedef union {
-  EFI_GRAPHICS_OUTPUT_BLT_PIXEL Pixel;
-  UINT32                        Raw;
-} EFI_GRAPHICS_OUTPUT_BLT_PIXEL_UNION;
-
-///
-/// actions for BltOperations
-///
-typedef enum {
-  ///
-  /// Write data from the BltBuffer pixel (0, 0)
-  /// directly to every pixel of the video display rectangle
-  /// (DestinationX, DestinationY) (DestinationX + Width, DestinationY + Height).
-  /// Only one pixel will be used from the BltBuffer. Delta is NOT used.
-  ///
-  EfiBltVideoFill,
-
-  ///
-  /// Read data from the video display rectangle
-  /// (SourceX, SourceY) (SourceX + Width, SourceY + Height) and place it in
-  /// the BltBuffer rectangle (DestinationX, DestinationY )
-  /// (DestinationX + Width, DestinationY + Height). If DestinationX or
-  /// DestinationY is not zero then Delta must be set to the length in bytes
-  /// of a row in the BltBuffer.
-  ///
-  EfiBltVideoToBltBuffer,
-
-  ///
-  /// Write data from the BltBuffer rectangle
-  /// (SourceX, SourceY) (SourceX + Width, SourceY + Height) directly to the
-  /// video display rectangle (DestinationX, DestinationY)
-  /// (DestinationX + Width, DestinationY + Height). If SourceX or SourceY is
-  /// not zero then Delta must be set to the length in bytes of a row in the
-  /// BltBuffer.
-  ///
-  EfiBltBufferToVideo,
-
-  ///
-  /// Copy from the video display rectangle (SourceX, SourceY)
-  /// (SourceX + Width, SourceY + Height) to the video display rectangle
-  /// (DestinationX, DestinationY) (DestinationX + Width, DestinationY + Height).
-  /// The BltBuffer and Delta are not used in this mode.
-  ///
-  EfiBltVideoToVideo,
-
-  EfiGraphicsOutputBltOperationMax
-} EFI_GRAPHICS_OUTPUT_BLT_OPERATION;
-
-/**
-  Blt a rectangle of pixels on the graphics screen. Blt stands for BLock Transfer.
-
-  @param  This         Protocol instance pointer.
-  @param  BltBuffer    The data to transfer to the graphics screen.
-                       Size is at least Width*Height*sizeof(EFI_GRAPHICS_OUTPUT_BLT_PIXEL).
-  @param  BltOperation The operation to perform when copying BltBuffer on to the graphics screen.
-  @param  SourceX      The X coordinate of source for the BltOperation.
-  @param  SourceY      The Y coordinate of source for the BltOperation.
-  @param  DestinationX The X coordinate of destination for the BltOperation.
-  @param  DestinationY The Y coordinate of destination for the BltOperation.
-  @param  Width        The width of a rectangle in the blt rectangle in pixels.
-  @param  Height       The height of a rectangle in the blt rectangle in pixels.
-  @param  Delta        Not used for EfiBltVideoFill or the EfiBltVideoToVideo operation.
-                       If a Delta of zero is used, the entire BltBuffer is being operated on.
-                       If a subrectangle of the BltBuffer is being used then Delta
-                       represents the number of bytes in a row of the BltBuffer.
-
-  @retval EFI_SUCCESS           BltBuffer was drawn to the graphics screen.
-  @retval EFI_INVALID_PARAMETER BltOperation is not valid.
-  @retval EFI_DEVICE_ERROR      The device had an error and could not complete the request.
-
-**/
-typedef
-EFI_STATUS
-(EFIAPI *EFI_GRAPHICS_OUTPUT_PROTOCOL_BLT)(
-  IN  EFI_GRAPHICS_OUTPUT_PROTOCOL            *This,
-  IN  EFI_GRAPHICS_OUTPUT_BLT_PIXEL           *BltBuffer,   OPTIONAL
-  IN  EFI_GRAPHICS_OUTPUT_BLT_OPERATION       BltOperation,
-  IN  UINTN                                   SourceX,
-  IN  UINTN                                   SourceY,
-  IN  UINTN                                   DestinationX,
-  IN  UINTN                                   DestinationY,
-  IN  UINTN                                   Width,
-  IN  UINTN                                   Height,
-  IN  UINTN                                   Delta         OPTIONAL
-  );
-
-typedef struct {
-  ///
-  /// The number of modes supported by QueryMode() and SetMode().
-  ///
-  UINT32                                 MaxMode;
-  ///
-  /// Current Mode of the graphics device. Valid mode numbers are 0 to MaxMode -1.
-  ///
-  UINT32                                 Mode;
-  ///
-  /// Pointer to read-only EFI_GRAPHICS_OUTPUT_MODE_INFORMATION data.
-  ///
-  EFI_GRAPHICS_OUTPUT_MODE_INFORMATION   *Info;
-  ///
-  /// Size of Info structure in bytes.
-  ///
-  UINTN                                  SizeOfInfo;
-  ///
-  /// Base address of graphics linear frame buffer.
-  /// Offset zero in FrameBufferBase represents the upper left pixel of the display.
-  ///
-  EFI_PHYSICAL_ADDRESS                   FrameBufferBase;
-  ///
-  /// Amount of frame buffer needed to support the active mode as defined by
-  /// PixelsPerScanLine xVerticalResolution x PixelElementSize.
-  ///
-  UINTN                                  FrameBufferSize;
-} EFI_GRAPHICS_OUTPUT_PROTOCOL_MODE;
-
-///
-/// Provides a basic abstraction to set video modes and copy pixels to and from
-/// the graphics controller's frame buffer. The linear address of the hardware
-/// frame buffer is also exposed so software can write directly to the video hardware.
-///
-struct _EFI_GRAPHICS_OUTPUT_PROTOCOL {
-  EFI_GRAPHICS_OUTPUT_PROTOCOL_QUERY_MODE  QueryMode;
-  EFI_GRAPHICS_OUTPUT_PROTOCOL_SET_MODE    SetMode;
-  EFI_GRAPHICS_OUTPUT_PROTOCOL_BLT         Blt;
-  ///
-  /// Pointer to EFI_GRAPHICS_OUTPUT_PROTOCOL_MODE data.
-  ///
-  EFI_GRAPHICS_OUTPUT_PROTOCOL_MODE        *Mode;
-};
-
-extern EFI_GUID gEfiGraphicsOutputProtocolGuid;
-
-#endif
diff --git a/src/efi/Protocol/LoadedImage.h b/src/efi/Protocol/LoadedImage.h
deleted file mode 100644
index 12e5e2d..0000000
--- a/src/efi/Protocol/LoadedImage.h
+++ /dev/null
@@ -1,88 +0,0 @@
-/** @file
-  UEFI 2.0 Loaded image protocol definition.
-
-  Every EFI driver and application is passed an image handle when it is loaded.
-  This image handle will contain a Loaded Image Protocol.
-
-  Copyright (c) 2006 - 2008, Intel Corporation. All rights reserved.<BR>
-  This program and the accompanying materials
-  are licensed and made available under the terms and conditions of the BSD License
-  which accompanies this distribution.  The full text of the license may be found at
-  http://opensource.org/licenses/bsd-license.php
-
-  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
-  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
-
-**/
-
-#ifndef __LOADED_IMAGE_PROTOCOL_H__
-#define __LOADED_IMAGE_PROTOCOL_H__
-
-#define EFI_LOADED_IMAGE_PROTOCOL_GUID \
-  { \
-    0x5B1B31A1, 0x9562, 0x11d2, {0x8E, 0x3F, 0x00, 0xA0, 0xC9, 0x69, 0x72, 0x3B } \
-  }
-
-#define EFI_LOADED_IMAGE_DEVICE_PATH_PROTOCOL_GUID \
-  { \
-    0xbc62157e, 0x3e33, 0x4fec, {0x99, 0x20, 0x2d, 0x3b, 0x36, 0xd7, 0x50, 0xdf } \
-  }
-
-///
-/// Protocol GUID defined in EFI1.1.
-///
-#define LOADED_IMAGE_PROTOCOL   EFI_LOADED_IMAGE_PROTOCOL_GUID
-
-///
-/// EFI_SYSTEM_TABLE & EFI_IMAGE_UNLOAD are defined in EfiApi.h
-///
-#define EFI_LOADED_IMAGE_PROTOCOL_REVISION  0x1000
-
-///
-/// Revision defined in EFI1.1.
-///
-#define EFI_LOADED_IMAGE_INFORMATION_REVISION    EFI_LOADED_IMAGE_PROTOCOL_REVISION
-
-///
-/// Can be used on any image handle to obtain information about the loaded image.
-///
-typedef struct {
-  UINT32            Revision;       ///< Defines the revision of the EFI_LOADED_IMAGE_PROTOCOL structure.
-                                    ///< All future revisions will be backward compatible to the current revision.
-  EFI_HANDLE        ParentHandle;   ///< Parent image's image handle. NULL if the image is loaded directly from
-                                    ///< the firmware's boot manager.
-  EFI_SYSTEM_TABLE  *SystemTable;   ///< the image's EFI system table pointer.
-
-  //
-  // Source location of image
-  //
-  EFI_HANDLE        DeviceHandle;   ///< The device handle that the EFI Image was loaded from.
-  EFI_DEVICE_PATH_PROTOCOL  *FilePath;  ///< A pointer to the file path portion specific to DeviceHandle
-                                        ///< that the EFI Image was loaded from.
-  VOID              *Reserved;      ///< Reserved. DO NOT USE.
-
-  //
-  // Images load options
-  //
-  UINT32            LoadOptionsSize;///< The size in bytes of LoadOptions.
-  VOID              *LoadOptions;   ///< A pointer to the image's binary load options.
-
-  //
-  // Location of where image was loaded
-  //
-  VOID              *ImageBase;     ///< The base address at which the image was loaded.
-  UINT64            ImageSize;      ///< The size in bytes of the loaded image.
-  EFI_MEMORY_TYPE   ImageCodeType;  ///< The memory type that the code sections were loaded as.
-  EFI_MEMORY_TYPE   ImageDataType;  ///< The memory type that the data sections were loaded as.
-  EFI_IMAGE_UNLOAD  Unload;
-} EFI_LOADED_IMAGE_PROTOCOL;
-
-//
-// For backward-compatible with EFI1.1.
-//
-typedef EFI_LOADED_IMAGE_PROTOCOL EFI_LOADED_IMAGE;
-
-extern EFI_GUID gEfiLoadedImageProtocolGuid;
-extern EFI_GUID gEfiLoadedImageDevicePathProtocolGuid;
-
-#endif
diff --git a/src/efi/Protocol/SimpleFileSystem.h b/src/efi/Protocol/SimpleFileSystem.h
deleted file mode 100644
index 37888d5..0000000
--- a/src/efi/Protocol/SimpleFileSystem.h
+++ /dev/null
@@ -1,562 +0,0 @@
-/** @file
-  SimpleFileSystem protocol as defined in the UEFI 2.0 specification.
-
-  The SimpleFileSystem protocol is the programmatic access to the FAT (12,16,32)
-  file system specified in UEFI 2.0. It can also be used to abstract a file
-  system other than FAT.
-
-  UEFI 2.0 can boot from any valid EFI image contained in a SimpleFileSystem.
-
-Copyright (c) 2006 - 2014, Intel Corporation. All rights reserved.<BR>
-This program and the accompanying materials are licensed and made available under
-the terms and conditions of the BSD License that accompanies this distribution.
-The full text of the license may be found at
-http://opensource.org/licenses/bsd-license.php.
-
-THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
-WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
-
-**/
-
-#ifndef __SIMPLE_FILE_SYSTEM_H__
-#define __SIMPLE_FILE_SYSTEM_H__
-
-#define EFI_SIMPLE_FILE_SYSTEM_PROTOCOL_GUID \
-  { \
-    0x964e5b22, 0x6459, 0x11d2, {0x8e, 0x39, 0x0, 0xa0, 0xc9, 0x69, 0x72, 0x3b } \
-  }
-
-typedef struct _EFI_SIMPLE_FILE_SYSTEM_PROTOCOL  EFI_SIMPLE_FILE_SYSTEM_PROTOCOL;
-
-typedef struct _EFI_FILE_PROTOCOL         EFI_FILE_PROTOCOL;
-typedef struct _EFI_FILE_PROTOCOL         *EFI_FILE_HANDLE;
-
-///
-/// Protocol GUID name defined in EFI1.1.
-///
-#define SIMPLE_FILE_SYSTEM_PROTOCOL       EFI_SIMPLE_FILE_SYSTEM_PROTOCOL_GUID
-
-///
-/// Protocol name defined in EFI1.1.
-///
-typedef EFI_SIMPLE_FILE_SYSTEM_PROTOCOL   EFI_FILE_IO_INTERFACE;
-typedef EFI_FILE_PROTOCOL                 EFI_FILE;
-
-/**
-  Open the root directory on a volume.
-
-  @param  This A pointer to the volume to open the root directory.
-  @param  Root A pointer to the location to return the opened file handle for the
-               root directory.
-
-  @retval EFI_SUCCESS          The device was opened.
-  @retval EFI_UNSUPPORTED      This volume does not support the requested file system type.
-  @retval EFI_NO_MEDIA         The device has no medium.
-  @retval EFI_DEVICE_ERROR     The device reported an error.
-  @retval EFI_VOLUME_CORRUPTED The file system structures are corrupted.
-  @retval EFI_ACCESS_DENIED    The service denied access to the file.
-  @retval EFI_OUT_OF_RESOURCES The volume was not opened due to lack of resources.
-  @retval EFI_MEDIA_CHANGED    The device has a different medium in it or the medium is no
-                               longer supported. Any existing file handles for this volume are
-                               no longer valid. To access the files on the new medium, the
-                               volume must be reopened with OpenVolume().
-
-**/
-typedef
-EFI_STATUS
-(EFIAPI *EFI_SIMPLE_FILE_SYSTEM_PROTOCOL_OPEN_VOLUME)(
-  IN EFI_SIMPLE_FILE_SYSTEM_PROTOCOL    *This,
-  OUT EFI_FILE_PROTOCOL                 **Root
-  );
-
-#define EFI_SIMPLE_FILE_SYSTEM_PROTOCOL_REVISION  0x00010000
-
-///
-/// Revision defined in EFI1.1
-///
-#define EFI_FILE_IO_INTERFACE_REVISION  EFI_SIMPLE_FILE_SYSTEM_PROTOCOL_REVISION
-
-struct _EFI_SIMPLE_FILE_SYSTEM_PROTOCOL {
-  ///
-  /// The version of the EFI_SIMPLE_FILE_SYSTEM_PROTOCOL. The version
-  /// specified by this specification is 0x00010000. All future revisions
-  /// must be backwards compatible.
-  ///
-  UINT64                                      Revision;
-  EFI_SIMPLE_FILE_SYSTEM_PROTOCOL_OPEN_VOLUME OpenVolume;
-};
-
-/**
-  Opens a new file relative to the source file's location.
-
-  @param  This       A pointer to the EFI_FILE_PROTOCOL instance that is the file
-                     handle to the source location. This would typically be an open
-                     handle to a directory.
-  @param  NewHandle  A pointer to the location to return the opened handle for the new
-                     file.
-  @param  FileName   The Null-terminated string of the name of the file to be opened.
-                     The file name may contain the following path modifiers: "\", ".",
-                     and "..".
-  @param  OpenMode   The mode to open the file. The only valid combinations that the
-                     file may be opened with are: Read, Read/Write, or Create/Read/Write.
-  @param  Attributes Only valid for EFI_FILE_MODE_CREATE, in which case these are the
-                     attribute bits for the newly created file.
-
-  @retval EFI_SUCCESS          The file was opened.
-  @retval EFI_NOT_FOUND        The specified file could not be found on the device.
-  @retval EFI_NO_MEDIA         The device has no medium.
-  @retval EFI_MEDIA_CHANGED    The device has a different medium in it or the medium is no
-                               longer supported.
-  @retval EFI_DEVICE_ERROR     The device reported an error.
-  @retval EFI_VOLUME_CORRUPTED The file system structures are corrupted.
-  @retval EFI_WRITE_PROTECTED  An attempt was made to create a file, or open a file for write
-                               when the media is write-protected.
-  @retval EFI_ACCESS_DENIED    The service denied access to the file.
-  @retval EFI_OUT_OF_RESOURCES Not enough resources were available to open the file.
-  @retval EFI_VOLUME_FULL      The volume is full.
-
-**/
-typedef
-EFI_STATUS
-(EFIAPI *EFI_FILE_OPEN)(
-  IN EFI_FILE_PROTOCOL        *This,
-  OUT EFI_FILE_PROTOCOL       **NewHandle,
-  IN CHAR16                   *FileName,
-  IN UINT64                   OpenMode,
-  IN UINT64                   Attributes
-  );
-
-//
-// Open modes
-//
-#define EFI_FILE_MODE_READ    0x0000000000000001ULL
-#define EFI_FILE_MODE_WRITE   0x0000000000000002ULL
-#define EFI_FILE_MODE_CREATE  0x8000000000000000ULL
-
-//
-// File attributes
-//
-#define EFI_FILE_READ_ONLY  0x0000000000000001ULL
-#define EFI_FILE_HIDDEN     0x0000000000000002ULL
-#define EFI_FILE_SYSTEM     0x0000000000000004ULL
-#define EFI_FILE_RESERVED   0x0000000000000008ULL
-#define EFI_FILE_DIRECTORY  0x0000000000000010ULL
-#define EFI_FILE_ARCHIVE    0x0000000000000020ULL
-#define EFI_FILE_VALID_ATTR 0x0000000000000037ULL
-
-/**
-  Closes a specified file handle.
-
-  @param  This          A pointer to the EFI_FILE_PROTOCOL instance that is the file
-                        handle to close.
-
-  @retval EFI_SUCCESS   The file was closed.
-
-**/
-typedef
-EFI_STATUS
-(EFIAPI *EFI_FILE_CLOSE)(
-  IN EFI_FILE_PROTOCOL  *This
-  );
-
-/**
-  Close and delete the file handle.
-
-  @param  This                     A pointer to the EFI_FILE_PROTOCOL instance that is the
-                                   handle to the file to delete.
-
-  @retval EFI_SUCCESS              The file was closed and deleted, and the handle was closed.
-  @retval EFI_WARN_DELETE_FAILURE  The handle was closed, but the file was not deleted.
-
-**/
-typedef
-EFI_STATUS
-(EFIAPI *EFI_FILE_DELETE)(
-  IN EFI_FILE_PROTOCOL  *This
-  );
-
-/**
-  Reads data from a file.
-
-  @param  This       A pointer to the EFI_FILE_PROTOCOL instance that is the file
-                     handle to read data from.
-  @param  BufferSize On input, the size of the Buffer. On output, the amount of data
-                     returned in Buffer. In both cases, the size is measured in bytes.
-  @param  Buffer     The buffer into which the data is read.
-
-  @retval EFI_SUCCESS          Data was read.
-  @retval EFI_NO_MEDIA         The device has no medium.
-  @retval EFI_DEVICE_ERROR     The device reported an error.
-  @retval EFI_DEVICE_ERROR     An attempt was made to read from a deleted file.
-  @retval EFI_DEVICE_ERROR     On entry, the current file position is beyond the end of the file.
-  @retval EFI_VOLUME_CORRUPTED The file system structures are corrupted.
-  @retval EFI_BUFFER_TOO_SMALL The BufferSize is too small to read the current directory
-                               entry. BufferSize has been updated with the size
-                               needed to complete the request.
-
-**/
-typedef
-EFI_STATUS
-(EFIAPI *EFI_FILE_READ)(
-  IN EFI_FILE_PROTOCOL        *This,
-  IN OUT UINTN                *BufferSize,
-  OUT VOID                    *Buffer
-  );
-
-/**
-  Writes data to a file.
-
-  @param  This       A pointer to the EFI_FILE_PROTOCOL instance that is the file
-                     handle to write data to.
-  @param  BufferSize On input, the size of the Buffer. On output, the amount of data
-                     actually written. In both cases, the size is measured in bytes.
-  @param  Buffer     The buffer of data to write.
-
-  @retval EFI_SUCCESS          Data was written.
-  @retval EFI_UNSUPPORTED      Writes to open directory files are not supported.
-  @retval EFI_NO_MEDIA         The device has no medium.
-  @retval EFI_DEVICE_ERROR     The device reported an error.
-  @retval EFI_DEVICE_ERROR     An attempt was made to write to a deleted file.
-  @retval EFI_VOLUME_CORRUPTED The file system structures are corrupted.
-  @retval EFI_WRITE_PROTECTED  The file or medium is write-protected.
-  @retval EFI_ACCESS_DENIED    The file was opened read only.
-  @retval EFI_VOLUME_FULL      The volume is full.
-
-**/
-typedef
-EFI_STATUS
-(EFIAPI *EFI_FILE_WRITE)(
-  IN EFI_FILE_PROTOCOL        *This,
-  IN OUT UINTN                *BufferSize,
-  IN VOID                     *Buffer
-  );
-
-/**
-  Sets a file's current position.
-
-  @param  This            A pointer to the EFI_FILE_PROTOCOL instance that is the
-                          file handle to set the requested position on.
-  @param  Position        The byte position from the start of the file to set.
-
-  @retval EFI_SUCCESS      The position was set.
-  @retval EFI_UNSUPPORTED  The seek request for nonzero is not valid on open
-                           directories.
-  @retval EFI_DEVICE_ERROR An attempt was made to set the position of a deleted file.
-
-**/
-typedef
-EFI_STATUS
-(EFIAPI *EFI_FILE_SET_POSITION)(
-  IN EFI_FILE_PROTOCOL        *This,
-  IN UINT64                   Position
-  );
-
-/**
-  Returns a file's current position.
-
-  @param  This            A pointer to the EFI_FILE_PROTOCOL instance that is the file
-                          handle to get the current position on.
-  @param  Position        The address to return the file's current position value.
-
-  @retval EFI_SUCCESS      The position was returned.
-  @retval EFI_UNSUPPORTED  The request is not valid on open directories.
-  @retval EFI_DEVICE_ERROR An attempt was made to get the position from a deleted file.
-
-**/
-typedef
-EFI_STATUS
-(EFIAPI *EFI_FILE_GET_POSITION)(
-  IN EFI_FILE_PROTOCOL        *This,
-  OUT UINT64                  *Position
-  );
-
-/**
-  Returns information about a file.
-
-  @param  This            A pointer to the EFI_FILE_PROTOCOL instance that is the file
-                          handle the requested information is for.
-  @param  InformationType The type identifier for the information being requested.
-  @param  BufferSize      On input, the size of Buffer. On output, the amount of data
-                          returned in Buffer. In both cases, the size is measured in bytes.
-  @param  Buffer          A pointer to the data buffer to return. The buffer's type is
-                          indicated by InformationType.
-
-  @retval EFI_SUCCESS          The information was returned.
-  @retval EFI_UNSUPPORTED      The InformationType is not known.
-  @retval EFI_NO_MEDIA         The device has no medium.
-  @retval EFI_DEVICE_ERROR     The device reported an error.
-  @retval EFI_VOLUME_CORRUPTED The file system structures are corrupted.
-  @retval EFI_BUFFER_TOO_SMALL The BufferSize is too small to read the current directory entry.
-                               BufferSize has been updated with the size needed to complete
-                               the request.
-**/
-typedef
-EFI_STATUS
-(EFIAPI *EFI_FILE_GET_INFO)(
-  IN EFI_FILE_PROTOCOL        *This,
-  IN EFI_GUID                 *InformationType,
-  IN OUT UINTN                *BufferSize,
-  OUT VOID                    *Buffer
-  );
-
-/**
-  Sets information about a file.
-
-  @param  File            A pointer to the EFI_FILE_PROTOCOL instance that is the file
-                          handle the information is for.
-  @param  InformationType The type identifier for the information being set.
-  @param  BufferSize      The size, in bytes, of Buffer.
-  @param  Buffer          A pointer to the data buffer to write. The buffer's type is
-                          indicated by InformationType.
-
-  @retval EFI_SUCCESS          The information was set.
-  @retval EFI_UNSUPPORTED      The InformationType is not known.
-  @retval EFI_NO_MEDIA         The device has no medium.
-  @retval EFI_DEVICE_ERROR     The device reported an error.
-  @retval EFI_VOLUME_CORRUPTED The file system structures are corrupted.
-  @retval EFI_WRITE_PROTECTED  InformationType is EFI_FILE_INFO_ID and the media is
-                               read-only.
-  @retval EFI_WRITE_PROTECTED  InformationType is EFI_FILE_PROTOCOL_SYSTEM_INFO_ID
-                               and the media is read only.
-  @retval EFI_WRITE_PROTECTED  InformationType is EFI_FILE_SYSTEM_VOLUME_LABEL_ID
-                               and the media is read-only.
-  @retval EFI_ACCESS_DENIED    An attempt is made to change the name of a file to a
-                               file that is already present.
-  @retval EFI_ACCESS_DENIED    An attempt is being made to change the EFI_FILE_DIRECTORY
-                               Attribute.
-  @retval EFI_ACCESS_DENIED    An attempt is being made to change the size of a directory.
-  @retval EFI_ACCESS_DENIED    InformationType is EFI_FILE_INFO_ID and the file was opened
-                               read-only and an attempt is being made to modify a field
-                               other than Attribute.
-  @retval EFI_VOLUME_FULL      The volume is full.
-  @retval EFI_BAD_BUFFER_SIZE  BufferSize is smaller than the size of the type indicated
-                               by InformationType.
-
-**/
-typedef
-EFI_STATUS
-(EFIAPI *EFI_FILE_SET_INFO)(
-  IN EFI_FILE_PROTOCOL        *This,
-  IN EFI_GUID                 *InformationType,
-  IN UINTN                    BufferSize,
-  IN VOID                     *Buffer
-  );
-
-/**
-  Flushes all modified data associated with a file to a device.
-
-  @param  This A pointer to the EFI_FILE_PROTOCOL instance that is the file
-               handle to flush.
-
-  @retval EFI_SUCCESS          The data was flushed.
-  @retval EFI_NO_MEDIA         The device has no medium.
-  @retval EFI_DEVICE_ERROR     The device reported an error.
-  @retval EFI_VOLUME_CORRUPTED The file system structures are corrupted.
-  @retval EFI_WRITE_PROTECTED  The file or medium is write-protected.
-  @retval EFI_ACCESS_DENIED    The file was opened read-only.
-  @retval EFI_VOLUME_FULL      The volume is full.
-
-**/
-typedef
-EFI_STATUS
-(EFIAPI *EFI_FILE_FLUSH)(
-  IN EFI_FILE_PROTOCOL  *This
-  );
-
-typedef struct {
-  //
-  // If Event is NULL, then blocking I/O is performed.
-  // If Event is not NULL and non-blocking I/O is supported, then non-blocking I/O is performed,
-  // and Event will be signaled when the read request is completed.
-  // The caller must be prepared to handle the case where the callback associated with Event
-  // occurs before the original asynchronous I/O request call returns.
-  //
-  EFI_EVENT                   Event;
-
-  //
-  // Defines whether or not the signaled event encountered an error.
-  //
-  EFI_STATUS                  Status;
-
-  //
-  // For OpenEx():  Not Used, ignored.
-  // For ReadEx():  On input, the size of the Buffer. On output, the amount of data returned in Buffer.
-  //                In both cases, the size is measured in bytes.
-  // For WriteEx(): On input, the size of the Buffer. On output, the amount of data actually written.
-  //                In both cases, the size is measured in bytes.
-  // For FlushEx(): Not used, ignored.
-  //
-  UINTN                       BufferSize;
-
-  //
-  // For OpenEx():  Not Used, ignored.
-  // For ReadEx():  The buffer into which the data is read.
-  // For WriteEx(): The buffer of data to write.
-  // For FlushEx(): Not Used, ignored.
-  //
-  VOID                        *Buffer;
-} EFI_FILE_IO_TOKEN;
-
-/**
-  Opens a new file relative to the source directory's location.
-
-  @param  This       A pointer to the EFI_FILE_PROTOCOL instance that is the file
-                     handle to the source location.
-  @param  NewHandle  A pointer to the location to return the opened handle for the new
-                     file.
-  @param  FileName   The Null-terminated string of the name of the file to be opened.
-                     The file name may contain the following path modifiers: "\", ".",
-                     and "..".
-  @param  OpenMode   The mode to open the file. The only valid combinations that the
-                     file may be opened with are: Read, Read/Write, or Create/Read/Write.
-  @param  Attributes Only valid for EFI_FILE_MODE_CREATE, in which case these are the
-                     attribute bits for the newly created file.
-  @param  Token      A pointer to the token associated with the transaction.
-
-  @retval EFI_SUCCESS          If Event is NULL (blocking I/O): The data was read successfully.
-                               If Event is not NULL (asynchronous I/O): The request was successfully
-                                                                        queued for processing.
-  @retval EFI_NOT_FOUND        The specified file could not be found on the device.
-  @retval EFI_NO_MEDIA         The device has no medium.
-  @retval EFI_MEDIA_CHANGED    The device has a different medium in it or the medium is no
-                               longer supported.
-  @retval EFI_DEVICE_ERROR     The device reported an error.
-  @retval EFI_VOLUME_CORRUPTED The file system structures are corrupted.
-  @retval EFI_WRITE_PROTECTED  An attempt was made to create a file, or open a file for write
-                               when the media is write-protected.
-  @retval EFI_ACCESS_DENIED    The service denied access to the file.
-  @retval EFI_OUT_OF_RESOURCES Not enough resources were available to open the file.
-  @retval EFI_VOLUME_FULL      The volume is full.
-
-**/
-typedef
-EFI_STATUS
-(EFIAPI *EFI_FILE_OPEN_EX)(
-  IN EFI_FILE_PROTOCOL        *This,
-  OUT EFI_FILE_PROTOCOL       **NewHandle,
-  IN CHAR16                   *FileName,
-  IN UINT64                   OpenMode,
-  IN UINT64                   Attributes,
-  IN OUT EFI_FILE_IO_TOKEN    *Token
-  );
-
-
-/**
-  Reads data from a file.
-
-  @param  This       A pointer to the EFI_FILE_PROTOCOL instance that is the file handle to read data from.
-  @param  Token      A pointer to the token associated with the transaction.
-
-  @retval EFI_SUCCESS          If Event is NULL (blocking I/O): The data was read successfully.
-                               If Event is not NULL (asynchronous I/O): The request was successfully
-                                                                        queued for processing.
-  @retval EFI_NO_MEDIA         The device has no medium.
-  @retval EFI_DEVICE_ERROR     The device reported an error.
-  @retval EFI_DEVICE_ERROR     An attempt was made to read from a deleted file.
-  @retval EFI_DEVICE_ERROR     On entry, the current file position is beyond the end of the file.
-  @retval EFI_VOLUME_CORRUPTED The file system structures are corrupted.
-  @retval EFI_OUT_OF_RESOURCES Unable to queue the request due to lack of resources.
-**/
-typedef
-EFI_STATUS
-(EFIAPI *EFI_FILE_READ_EX) (
-  IN EFI_FILE_PROTOCOL        *This,
-  IN OUT EFI_FILE_IO_TOKEN    *Token
-);
-
-
-/**
-  Writes data to a file.
-
-  @param  This       A pointer to the EFI_FILE_PROTOCOL instance that is the file handle to write data to.
-  @param  Token      A pointer to the token associated with the transaction.
-
-  @retval EFI_SUCCESS          If Event is NULL (blocking I/O): The data was read successfully.
-                               If Event is not NULL (asynchronous I/O): The request was successfully
-                                                                        queued for processing.
-  @retval EFI_UNSUPPORTED      Writes to open directory files are not supported.
-  @retval EFI_NO_MEDIA         The device has no medium.
-  @retval EFI_DEVICE_ERROR     The device reported an error.
-  @retval EFI_DEVICE_ERROR     An attempt was made to write to a deleted file.
-  @retval EFI_VOLUME_CORRUPTED The file system structures are corrupted.
-  @retval EFI_WRITE_PROTECTED  The file or medium is write-protected.
-  @retval EFI_ACCESS_DENIED    The file was opened read only.
-  @retval EFI_VOLUME_FULL      The volume is full.
-  @retval EFI_OUT_OF_RESOURCES Unable to queue the request due to lack of resources.
-**/
-typedef
-EFI_STATUS
-(EFIAPI *EFI_FILE_WRITE_EX) (
-  IN EFI_FILE_PROTOCOL        *This,
-  IN OUT EFI_FILE_IO_TOKEN    *Token
-);
-
-/**
-  Flushes all modified data associated with a file to a device.
-
-  @param  This  A pointer to the EFI_FILE_PROTOCOL instance that is the file
-                handle to flush.
-  @param  Token A pointer to the token associated with the transaction.
-
-  @retval EFI_SUCCESS          If Event is NULL (blocking I/O): The data was read successfully.
-                               If Event is not NULL (asynchronous I/O): The request was successfully
-                                                                        queued for processing.
-  @retval EFI_NO_MEDIA         The device has no medium.
-  @retval EFI_DEVICE_ERROR     The device reported an error.
-  @retval EFI_VOLUME_CORRUPTED The file system structures are corrupted.
-  @retval EFI_WRITE_PROTECTED  The file or medium is write-protected.
-  @retval EFI_ACCESS_DENIED    The file was opened read-only.
-  @retval EFI_VOLUME_FULL      The volume is full.
-  @retval EFI_OUT_OF_RESOURCES Unable to queue the request due to lack of resources.
-
-**/
-typedef
-EFI_STATUS
-(EFIAPI *EFI_FILE_FLUSH_EX) (
-  IN EFI_FILE_PROTOCOL        *This,
-  IN OUT EFI_FILE_IO_TOKEN    *Token
-  );
-
-#define EFI_FILE_PROTOCOL_REVISION        0x00010000
-#define EFI_FILE_PROTOCOL_REVISION2       0x00020000
-#define EFI_FILE_PROTOCOL_LATEST_REVISION EFI_FILE_PROTOCOL_REVISION2
-
-//
-// Revision defined in EFI1.1.
-//
-#define EFI_FILE_REVISION   EFI_FILE_PROTOCOL_REVISION
-
-///
-/// The EFI_FILE_PROTOCOL provides file IO access to supported file systems.
-/// An EFI_FILE_PROTOCOL provides access to a file's or directory's contents,
-/// and is also a reference to a location in the directory tree of the file system
-/// in which the file resides. With any given file handle, other files may be opened
-/// relative to this file's location, yielding new file handles.
-///
-struct _EFI_FILE_PROTOCOL {
-  ///
-  /// The version of the EFI_FILE_PROTOCOL interface. The version specified
-  /// by this specification is EFI_FILE_PROTOCOL_LATEST_REVISION.
-  /// Future versions are required to be backward compatible to version 1.0.
-  ///
-  UINT64                Revision;
-  EFI_FILE_OPEN         Open;
-  EFI_FILE_CLOSE        Close;
-  EFI_FILE_DELETE       Delete;
-  EFI_FILE_READ         Read;
-  EFI_FILE_WRITE        Write;
-  EFI_FILE_GET_POSITION GetPosition;
-  EFI_FILE_SET_POSITION SetPosition;
-  EFI_FILE_GET_INFO     GetInfo;
-  EFI_FILE_SET_INFO     SetInfo;
-  EFI_FILE_FLUSH        Flush;
-  EFI_FILE_OPEN_EX      OpenEx;
-  EFI_FILE_READ_EX      ReadEx;
-  EFI_FILE_WRITE_EX     WriteEx;
-  EFI_FILE_FLUSH_EX     FlushEx;
-};
-
-
-extern EFI_GUID gEfiSimpleFileSystemProtocolGuid;
-
-#endif
diff --git a/src/efi/Protocol/SimpleTextIn.h b/src/efi/Protocol/SimpleTextIn.h
deleted file mode 100644
index a3335f0..0000000
--- a/src/efi/Protocol/SimpleTextIn.h
+++ /dev/null
@@ -1,134 +0,0 @@
-/** @file
-  Simple Text Input protocol from the UEFI 2.0 specification.
-
-  Abstraction of a very simple input device like a keyboard or serial
-  terminal.
-
-  Copyright (c) 2006 - 2011, Intel Corporation. All rights reserved.<BR>
-  This program and the accompanying materials
-  are licensed and made available under the terms and conditions of the BSD License
-  which accompanies this distribution.  The full text of the license may be found at
-  http://opensource.org/licenses/bsd-license.php
-
-  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
-  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
-
-**/
-
-#ifndef __SIMPLE_TEXT_IN_PROTOCOL_H__
-#define __SIMPLE_TEXT_IN_PROTOCOL_H__
-
-#define EFI_SIMPLE_TEXT_INPUT_PROTOCOL_GUID \
-  { \
-    0x387477c1, 0x69c7, 0x11d2, {0x8e, 0x39, 0x0, 0xa0, 0xc9, 0x69, 0x72, 0x3b } \
-  }
-
-typedef struct _EFI_SIMPLE_TEXT_INPUT_PROTOCOL  EFI_SIMPLE_TEXT_INPUT_PROTOCOL;
-
-///
-/// Protocol GUID name defined in EFI1.1.
-///
-#define SIMPLE_INPUT_PROTOCOL   EFI_SIMPLE_TEXT_INPUT_PROTOCOL_GUID
-
-///
-/// Protocol name in EFI1.1 for backward-compatible.
-///
-typedef struct _EFI_SIMPLE_TEXT_INPUT_PROTOCOL  SIMPLE_INPUT_INTERFACE;
-
-///
-/// The keystroke information for the key that was pressed.
-///
-typedef struct {
-  UINT16  ScanCode;
-  CHAR16  UnicodeChar;
-} EFI_INPUT_KEY;
-
-//
-// Required unicode control chars
-//
-#define CHAR_NULL             0x0000
-#define CHAR_BACKSPACE        0x0008
-#define CHAR_TAB              0x0009
-#define CHAR_LINEFEED         0x000A
-#define CHAR_CARRIAGE_RETURN  0x000D
-
-//
-// EFI Scan codes
-//
-#define SCAN_NULL       0x0000
-#define SCAN_UP         0x0001
-#define SCAN_DOWN       0x0002
-#define SCAN_RIGHT      0x0003
-#define SCAN_LEFT       0x0004
-#define SCAN_HOME       0x0005
-#define SCAN_END        0x0006
-#define SCAN_INSERT     0x0007
-#define SCAN_DELETE     0x0008
-#define SCAN_PAGE_UP    0x0009
-#define SCAN_PAGE_DOWN  0x000A
-#define SCAN_F1         0x000B
-#define SCAN_F2         0x000C
-#define SCAN_F3         0x000D
-#define SCAN_F4         0x000E
-#define SCAN_F5         0x000F
-#define SCAN_F6         0x0010
-#define SCAN_F7         0x0011
-#define SCAN_F8         0x0012
-#define SCAN_F9         0x0013
-#define SCAN_F10        0x0014
-#define SCAN_ESC        0x0017
-
-/**
-  Reset the input device and optionally run diagnostics
-
-  @param  This                 Protocol instance pointer.
-  @param  ExtendedVerification Driver may perform diagnostics on reset.
-
-  @retval EFI_SUCCESS          The device was reset.
-  @retval EFI_DEVICE_ERROR     The device is not functioning properly and could not be reset.
-
-**/
-typedef
-EFI_STATUS
-(EFIAPI *EFI_INPUT_RESET)(
-  IN EFI_SIMPLE_TEXT_INPUT_PROTOCOL       *This,
-  IN BOOLEAN                              ExtendedVerification
-  );
-
-/**
-  Reads the next keystroke from the input device. The WaitForKey Event can
-  be used to test for existence of a keystroke via WaitForEvent () call.
-
-  @param  This  Protocol instance pointer.
-  @param  Key   A pointer to a buffer that is filled in with the keystroke
-                information for the key that was pressed.
-
-  @retval EFI_SUCCESS      The keystroke information was returned.
-  @retval EFI_NOT_READY    There was no keystroke data available.
-  @retval EFI_DEVICE_ERROR The keystroke information was not returned due to
-                           hardware errors.
-
-**/
-typedef
-EFI_STATUS
-(EFIAPI *EFI_INPUT_READ_KEY)(
-  IN EFI_SIMPLE_TEXT_INPUT_PROTOCOL       *This,
-  OUT EFI_INPUT_KEY                       *Key
-  );
-
-///
-/// The EFI_SIMPLE_TEXT_INPUT_PROTOCOL is used on the ConsoleIn device.
-/// It is the minimum required protocol for ConsoleIn.
-///
-struct _EFI_SIMPLE_TEXT_INPUT_PROTOCOL {
-  EFI_INPUT_RESET     Reset;
-  EFI_INPUT_READ_KEY  ReadKeyStroke;
-  ///
-  /// Event to use with WaitForEvent() to wait for a key to be available
-  ///
-  EFI_EVENT           WaitForKey;
-};
-
-extern EFI_GUID gEfiSimpleTextInProtocolGuid;
-
-#endif
diff --git a/src/efi/Protocol/SimpleTextInEx.h b/src/efi/Protocol/SimpleTextInEx.h
deleted file mode 100644
index 0950c32..0000000
--- a/src/efi/Protocol/SimpleTextInEx.h
+++ /dev/null
@@ -1,325 +0,0 @@
-/** @file
-  Simple Text Input Ex protocol from the UEFI 2.0 specification.
-
-  This protocol defines an extension to the EFI_SIMPLE_TEXT_INPUT_PROTOCOL
-  which exposes much more state and modifier information from the input device,
-  also allows one to register a notification for a particular keystroke.
-
-  Copyright (c) 2006 - 2012, Intel Corporation. All rights reserved.<BR>
-  This program and the accompanying materials
-  are licensed and made available under the terms and conditions of the BSD License
-  which accompanies this distribution.  The full text of the license may be found at
-  http://opensource.org/licenses/bsd-license.php
-
-  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
-  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
-
-**/
-
-#ifndef __SIMPLE_TEXT_IN_EX_H__
-#define __SIMPLE_TEXT_IN_EX_H__
-
-#include "efi/Protocol/SimpleTextIn.h"
-
-#define EFI_SIMPLE_TEXT_INPUT_EX_PROTOCOL_GUID \
-  {0xdd9e7534, 0x7762, 0x4698, { 0x8c, 0x14, 0xf5, 0x85, 0x17, 0xa6, 0x25, 0xaa } }
-
-
-typedef struct _EFI_SIMPLE_TEXT_INPUT_EX_PROTOCOL EFI_SIMPLE_TEXT_INPUT_EX_PROTOCOL;
-
-/**
-  The Reset() function resets the input device hardware. As part
-  of initialization process, the firmware/device will make a quick
-  but reasonable attempt to verify that the device is functioning.
-  If the ExtendedVerification flag is TRUE the firmware may take
-  an extended amount of time to verify the device is operating on
-  reset. Otherwise the reset operation is to occur as quickly as
-  possible. The hardware verification process is not defined by
-  this specification and is left up to the platform firmware or
-  driver to implement.
-
-  @param This                 A pointer to the EFI_SIMPLE_TEXT_INPUT_EX_PROTOCOL instance.
-
-  @param ExtendedVerification Indicates that the driver may
-                              perform a more exhaustive
-                              verification operation of the
-                              device during reset.
-
-
-  @retval EFI_SUCCESS       The device was reset.
-
-  @retval EFI_DEVICE_ERROR  The device is not functioning
-                            correctly and could not be reset.
-
-**/
-typedef
-EFI_STATUS
-(EFIAPI *EFI_INPUT_RESET_EX)(
-  IN EFI_SIMPLE_TEXT_INPUT_EX_PROTOCOL *This,
-  IN BOOLEAN                           ExtendedVerification
-);
-
-
-///
-/// EFI_KEY_TOGGLE_STATE. The toggle states are defined.
-/// They are: EFI_TOGGLE_STATE_VALID, EFI_SCROLL_LOCK_ACTIVE
-/// EFI_NUM_LOCK_ACTIVE, EFI_CAPS_LOCK_ACTIVE
-///
-typedef UINT8 EFI_KEY_TOGGLE_STATE;
-
-typedef struct _EFI_KEY_STATE {
-  ///
-  /// Reflects the currently pressed shift
-  /// modifiers for the input device. The
-  /// returned value is valid only if the high
-  /// order bit has been set.
-  ///
-  UINT32                KeyShiftState;
-  ///
-  /// Reflects the current internal state of
-  /// various toggled attributes. The returned
-  /// value is valid only if the high order
-  /// bit has been set.
-  ///
-  EFI_KEY_TOGGLE_STATE  KeyToggleState;
-} EFI_KEY_STATE;
-
-typedef struct {
-  ///
-  /// The EFI scan code and Unicode value returned from the input device.
-  ///
-  EFI_INPUT_KEY   Key;
-  ///
-  /// The current state of various toggled attributes as well as input modifier values.
-  ///
-  EFI_KEY_STATE   KeyState;
-} EFI_KEY_DATA;
-
-//
-// Any Shift or Toggle State that is valid should have
-// high order bit set.
-//
-// Shift state
-//
-#define EFI_SHIFT_STATE_VALID     0x80000000
-#define EFI_RIGHT_SHIFT_PRESSED   0x00000001
-#define EFI_LEFT_SHIFT_PRESSED    0x00000002
-#define EFI_RIGHT_CONTROL_PRESSED 0x00000004
-#define EFI_LEFT_CONTROL_PRESSED  0x00000008
-#define EFI_RIGHT_ALT_PRESSED     0x00000010
-#define EFI_LEFT_ALT_PRESSED      0x00000020
-#define EFI_RIGHT_LOGO_PRESSED    0x00000040
-#define EFI_LEFT_LOGO_PRESSED     0x00000080
-#define EFI_MENU_KEY_PRESSED      0x00000100
-#define EFI_SYS_REQ_PRESSED       0x00000200
-
-//
-// Toggle state
-//
-#define EFI_TOGGLE_STATE_VALID    0x80
-#define EFI_KEY_STATE_EXPOSED     0x40
-#define EFI_SCROLL_LOCK_ACTIVE    0x01
-#define EFI_NUM_LOCK_ACTIVE       0x02
-#define EFI_CAPS_LOCK_ACTIVE      0x04
-
-//
-// EFI Scan codes
-//
-#define SCAN_F11                  0x0015
-#define SCAN_F12                  0x0016
-#define SCAN_PAUSE                0x0048
-#define SCAN_F13                  0x0068
-#define SCAN_F14                  0x0069
-#define SCAN_F15                  0x006A
-#define SCAN_F16                  0x006B
-#define SCAN_F17                  0x006C
-#define SCAN_F18                  0x006D
-#define SCAN_F19                  0x006E
-#define SCAN_F20                  0x006F
-#define SCAN_F21                  0x0070
-#define SCAN_F22                  0x0071
-#define SCAN_F23                  0x0072
-#define SCAN_F24                  0x0073
-#define SCAN_MUTE                 0x007F
-#define SCAN_VOLUME_UP            0x0080
-#define SCAN_VOLUME_DOWN          0x0081
-#define SCAN_BRIGHTNESS_UP        0x0100
-#define SCAN_BRIGHTNESS_DOWN      0x0101
-#define SCAN_SUSPEND              0x0102
-#define SCAN_HIBERNATE            0x0103
-#define SCAN_TOGGLE_DISPLAY       0x0104
-#define SCAN_RECOVERY             0x0105
-#define SCAN_EJECT                0x0106
-
-/**
-  The function reads the next keystroke from the input device. If
-  there is no pending keystroke the function returns
-  EFI_NOT_READY. If there is a pending keystroke, then
-  KeyData.Key.ScanCode is the EFI scan code defined in Error!
-  Reference source not found. The KeyData.Key.UnicodeChar is the
-  actual printable character or is zero if the key does not
-  represent a printable character (control key, function key,
-  etc.). The KeyData.KeyState is shift state for the character
-  reflected in KeyData.Key.UnicodeChar or KeyData.Key.ScanCode .
-  When interpreting the data from this function, it should be
-  noted that if a class of printable characters that are
-  normally adjusted by shift modifiers (e.g. Shift Key + "f"
-  key) would be presented solely as a KeyData.Key.UnicodeChar
-  without the associated shift state. So in the previous example
-  of a Shift Key + "f" key being pressed, the only pertinent
-  data returned would be KeyData.Key.UnicodeChar with the value
-  of "F". This of course would not typically be the case for
-  non-printable characters such as the pressing of the Right
-  Shift Key + F10 key since the corresponding returned data
-  would be reflected both in the KeyData.KeyState.KeyShiftState
-  and KeyData.Key.ScanCode values. UEFI drivers which implement
-  the EFI_SIMPLE_TEXT_INPUT_EX protocol are required to return
-  KeyData.Key and KeyData.KeyState values. These drivers must
-  always return the most current state of
-  KeyData.KeyState.KeyShiftState and
-  KeyData.KeyState.KeyToggleState. It should also be noted that
-  certain input devices may not be able to produce shift or toggle
-  state information, and in those cases the high order bit in the
-  respective Toggle and Shift state fields should not be active.
-
-
-  @param This     A pointer to the EFI_SIMPLE_TEXT_INPUT_EX_PROTOCOL instance.
-
-  @param KeyData  A pointer to a buffer that is filled in with
-                  the keystroke state data for the key that was
-                  pressed.
-
-
-  @retval EFI_SUCCESS     The keystroke information was
-                          returned.
-
-  @retval EFI_NOT_READY   There was no keystroke data available.
-                          EFI_DEVICE_ERROR The keystroke
-                          information was not returned due to
-                          hardware errors.
-
-
-**/
-typedef
-EFI_STATUS
-(EFIAPI *EFI_INPUT_READ_KEY_EX)(
-  IN  EFI_SIMPLE_TEXT_INPUT_EX_PROTOCOL *This,
-  OUT EFI_KEY_DATA                      *KeyData
-);
-
-/**
-  The SetState() function allows the input device hardware to
-  have state settings adjusted.
-
-  @param This           A pointer to the EFI_SIMPLE_TEXT_INPUT_EX_PROTOCOL instance.
-
-  @param KeyToggleState Pointer to the EFI_KEY_TOGGLE_STATE to
-                        set the state for the input device.
-
-
-  @retval EFI_SUCCESS       The device state was set appropriately.
-
-  @retval EFI_DEVICE_ERROR  The device is not functioning
-                            correctly and could not have the
-                            setting adjusted.
-
-  @retval EFI_UNSUPPORTED   The device does not support the
-                            ability to have its state set.
-
-**/
-typedef
-EFI_STATUS
-(EFIAPI *EFI_SET_STATE)(
-  IN EFI_SIMPLE_TEXT_INPUT_EX_PROTOCOL *This,
-  IN EFI_KEY_TOGGLE_STATE              *KeyToggleState
-);
-
-///
-/// The function will be called when the key sequence is typed specified by KeyData.
-///
-typedef
-EFI_STATUS
-(EFIAPI *EFI_KEY_NOTIFY_FUNCTION)(
-  IN EFI_KEY_DATA *KeyData
-);
-
-/**
-  The RegisterKeystrokeNotify() function registers a function
-  which will be called when a specified keystroke will occur.
-
-  @param This                     A pointer to the EFI_SIMPLE_TEXT_INPUT_EX_PROTOCOL instance.
-
-  @param KeyData                  A pointer to a buffer that is filled in with
-                                  the keystroke information for the key that was
-                                  pressed.
-
-  @param KeyNotificationFunction  Points to the function to be
-                                  called when the key sequence
-                                  is typed specified by KeyData.
-
-
-  @param NotifyHandle             Points to the unique handle assigned to
-                                  the registered notification.
-
-  @retval EFI_SUCCESS           The device state was set
-                                appropriately.
-
-  @retval EFI_OUT_OF_RESOURCES  Unable to allocate necessary
-                                data structures.
-
-**/
-typedef
-EFI_STATUS
-(EFIAPI *EFI_REGISTER_KEYSTROKE_NOTIFY)(
-  IN  EFI_SIMPLE_TEXT_INPUT_EX_PROTOCOL *This,
-  IN  EFI_KEY_DATA                      *KeyData,
-  IN  EFI_KEY_NOTIFY_FUNCTION           KeyNotificationFunction,
-  OUT VOID                              **NotifyHandle
-);
-
-/**
-  The UnregisterKeystrokeNotify() function removes the
-  notification which was previously registered.
-
-  @param This               A pointer to the EFI_SIMPLE_TEXT_INPUT_EX_PROTOCOL instance.
-
-  @param NotificationHandle The handle of the notification
-                            function being unregistered.
-
-  @retval EFI_SUCCESS The device state was set appropriately.
-
-  @retval EFI_INVALID_PARAMETER The NotificationHandle is
-                                invalid.
-
-**/
-typedef
-EFI_STATUS
-(EFIAPI *EFI_UNREGISTER_KEYSTROKE_NOTIFY)(
-  IN EFI_SIMPLE_TEXT_INPUT_EX_PROTOCOL  *This,
-  IN VOID                               *NotificationHandle
-);
-
-
-///
-/// The EFI_SIMPLE_TEXT_INPUT_EX_PROTOCOL is used on the ConsoleIn
-/// device. It is an extension to the Simple Text Input protocol
-/// which allows a variety of extended shift state information to be
-/// returned.
-///
-struct _EFI_SIMPLE_TEXT_INPUT_EX_PROTOCOL{
-  EFI_INPUT_RESET_EX              Reset;
-  EFI_INPUT_READ_KEY_EX           ReadKeyStrokeEx;
-  ///
-  /// Event to use with WaitForEvent() to wait for a key to be available.
-  ///
-  EFI_EVENT                       WaitForKeyEx;
-  EFI_SET_STATE                   SetState;
-  EFI_REGISTER_KEYSTROKE_NOTIFY   RegisterKeyNotify;
-  EFI_UNREGISTER_KEYSTROKE_NOTIFY UnregisterKeyNotify;
-};
-
-
-extern EFI_GUID gEfiSimpleTextInputExProtocolGuid;
-
-#endif
-
diff --git a/src/efi/Protocol/SimpleTextOut.h b/src/efi/Protocol/SimpleTextOut.h
deleted file mode 100644
index 7e1c70c..0000000
--- a/src/efi/Protocol/SimpleTextOut.h
+++ /dev/null
@@ -1,404 +0,0 @@
-/** @file
-  Simple Text Out protocol from the UEFI 2.0 specification.
-
-  Abstraction of a very simple text based output device like VGA text mode or
-  a serial terminal. The Simple Text Out protocol instance can represent
-  a single hardware device or a virtual device that is an aggregation
-  of multiple physical devices.
-
-Copyright (c) 2006 - 2010, Intel Corporation. All rights reserved.<BR>
-This program and the accompanying materials are licensed and made available under
-the terms and conditions of the BSD License that accompanies this distribution.
-The full text of the license may be found at
-http://opensource.org/licenses/bsd-license.php.
-
-THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
-WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
-
-**/
-
-#ifndef __SIMPLE_TEXT_OUT_H__
-#define __SIMPLE_TEXT_OUT_H__
-
-#define EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL_GUID \
-  { \
-    0x387477c2, 0x69c7, 0x11d2, {0x8e, 0x39, 0x0, 0xa0, 0xc9, 0x69, 0x72, 0x3b } \
-  }
-
-///
-/// Protocol GUID defined in EFI1.1.
-///
-#define SIMPLE_TEXT_OUTPUT_PROTOCOL   EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL_GUID
-
-typedef struct _EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL;
-
-///
-/// Backward-compatible with EFI1.1.
-///
-typedef EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL   SIMPLE_TEXT_OUTPUT_INTERFACE;
-
-//
-// Define's for required EFI Unicode Box Draw characters
-//
-#define BOXDRAW_HORIZONTAL                  0x2500
-#define BOXDRAW_VERTICAL                    0x2502
-#define BOXDRAW_DOWN_RIGHT                  0x250c
-#define BOXDRAW_DOWN_LEFT                   0x2510
-#define BOXDRAW_UP_RIGHT                    0x2514
-#define BOXDRAW_UP_LEFT                     0x2518
-#define BOXDRAW_VERTICAL_RIGHT              0x251c
-#define BOXDRAW_VERTICAL_LEFT               0x2524
-#define BOXDRAW_DOWN_HORIZONTAL             0x252c
-#define BOXDRAW_UP_HORIZONTAL               0x2534
-#define BOXDRAW_VERTICAL_HORIZONTAL         0x253c
-#define BOXDRAW_DOUBLE_HORIZONTAL           0x2550
-#define BOXDRAW_DOUBLE_VERTICAL             0x2551
-#define BOXDRAW_DOWN_RIGHT_DOUBLE           0x2552
-#define BOXDRAW_DOWN_DOUBLE_RIGHT           0x2553
-#define BOXDRAW_DOUBLE_DOWN_RIGHT           0x2554
-#define BOXDRAW_DOWN_LEFT_DOUBLE            0x2555
-#define BOXDRAW_DOWN_DOUBLE_LEFT            0x2556
-#define BOXDRAW_DOUBLE_DOWN_LEFT            0x2557
-#define BOXDRAW_UP_RIGHT_DOUBLE             0x2558
-#define BOXDRAW_UP_DOUBLE_RIGHT             0x2559
-#define BOXDRAW_DOUBLE_UP_RIGHT             0x255a
-#define BOXDRAW_UP_LEFT_DOUBLE              0x255b
-#define BOXDRAW_UP_DOUBLE_LEFT              0x255c
-#define BOXDRAW_DOUBLE_UP_LEFT              0x255d
-#define BOXDRAW_VERTICAL_RIGHT_DOUBLE       0x255e
-#define BOXDRAW_VERTICAL_DOUBLE_RIGHT       0x255f
-#define BOXDRAW_DOUBLE_VERTICAL_RIGHT       0x2560
-#define BOXDRAW_VERTICAL_LEFT_DOUBLE        0x2561
-#define BOXDRAW_VERTICAL_DOUBLE_LEFT        0x2562
-#define BOXDRAW_DOUBLE_VERTICAL_LEFT        0x2563
-#define BOXDRAW_DOWN_HORIZONTAL_DOUBLE      0x2564
-#define BOXDRAW_DOWN_DOUBLE_HORIZONTAL      0x2565
-#define BOXDRAW_DOUBLE_DOWN_HORIZONTAL      0x2566
-#define BOXDRAW_UP_HORIZONTAL_DOUBLE        0x2567
-#define BOXDRAW_UP_DOUBLE_HORIZONTAL        0x2568
-#define BOXDRAW_DOUBLE_UP_HORIZONTAL        0x2569
-#define BOXDRAW_VERTICAL_HORIZONTAL_DOUBLE  0x256a
-#define BOXDRAW_VERTICAL_DOUBLE_HORIZONTAL  0x256b
-#define BOXDRAW_DOUBLE_VERTICAL_HORIZONTAL  0x256c
-
-//
-// EFI Required Block Elements Code Chart
-//
-#define BLOCKELEMENT_FULL_BLOCK   0x2588
-#define BLOCKELEMENT_LIGHT_SHADE  0x2591
-
-//
-// EFI Required Geometric Shapes Code Chart
-//
-#define GEOMETRICSHAPE_UP_TRIANGLE    0x25b2
-#define GEOMETRICSHAPE_RIGHT_TRIANGLE 0x25ba
-#define GEOMETRICSHAPE_DOWN_TRIANGLE  0x25bc
-#define GEOMETRICSHAPE_LEFT_TRIANGLE  0x25c4
-
-//
-// EFI Required Arrow shapes
-//
-#define ARROW_LEFT  0x2190
-#define ARROW_UP    0x2191
-#define ARROW_RIGHT 0x2192
-#define ARROW_DOWN  0x2193
-
-//
-// EFI Console Colours
-//
-#define EFI_BLACK                 0x00
-#define EFI_BLUE                  0x01
-#define EFI_GREEN                 0x02
-#define EFI_CYAN                  (EFI_BLUE | EFI_GREEN)
-#define EFI_RED                   0x04
-#define EFI_MAGENTA               (EFI_BLUE | EFI_RED)
-#define EFI_BROWN                 (EFI_GREEN | EFI_RED)
-#define EFI_LIGHTGRAY             (EFI_BLUE | EFI_GREEN | EFI_RED)
-#define EFI_BRIGHT                0x08
-#define EFI_DARKGRAY              (EFI_BRIGHT)
-#define EFI_LIGHTBLUE             (EFI_BLUE | EFI_BRIGHT)
-#define EFI_LIGHTGREEN            (EFI_GREEN | EFI_BRIGHT)
-#define EFI_LIGHTCYAN             (EFI_CYAN | EFI_BRIGHT)
-#define EFI_LIGHTRED              (EFI_RED | EFI_BRIGHT)
-#define EFI_LIGHTMAGENTA          (EFI_MAGENTA | EFI_BRIGHT)
-#define EFI_YELLOW                (EFI_BROWN | EFI_BRIGHT)
-#define EFI_WHITE                 (EFI_BLUE | EFI_GREEN | EFI_RED | EFI_BRIGHT)
-
-#define EFI_TEXT_ATTR(f, b)       ((f) | ((b) << 4))
-
-#define EFI_BACKGROUND_BLACK      0x00
-#define EFI_BACKGROUND_BLUE       0x10
-#define EFI_BACKGROUND_GREEN      0x20
-#define EFI_BACKGROUND_CYAN       (EFI_BACKGROUND_BLUE | EFI_BACKGROUND_GREEN)
-#define EFI_BACKGROUND_RED        0x40
-#define EFI_BACKGROUND_MAGENTA    (EFI_BACKGROUND_BLUE | EFI_BACKGROUND_RED)
-#define EFI_BACKGROUND_BROWN      (EFI_BACKGROUND_GREEN | EFI_BACKGROUND_RED)
-#define EFI_BACKGROUND_LIGHTGRAY  (EFI_BACKGROUND_BLUE | EFI_BACKGROUND_GREEN | EFI_BACKGROUND_RED)
-
-//
-// We currently define attributes from 0 - 7F for color manipulations
-// To internally handle the local display characteristics for a particular character,
-// Bit 7 signifies the local glyph representation for a character.  If turned on, glyphs will be
-// pulled from the wide glyph database and will display locally as a wide character (16 X 19 versus 8 X 19)
-// If bit 7 is off, the narrow glyph database will be used.  This does NOT affect information that is sent to
-// non-local displays, such as serial or LAN consoles.
-//
-#define EFI_WIDE_ATTRIBUTE  0x80
-
-/**
-  Reset the text output device hardware and optionaly run diagnostics
-
-  @param  This                 The protocol instance pointer.
-  @param  ExtendedVerification Driver may perform more exhaustive verfication
-                               operation of the device during reset.
-
-  @retval EFI_SUCCESS          The text output device was reset.
-  @retval EFI_DEVICE_ERROR     The text output device is not functioning correctly and
-                               could not be reset.
-
-**/
-typedef
-EFI_STATUS
-(EFIAPI *EFI_TEXT_RESET)(
-  IN EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL        *This,
-  IN BOOLEAN                                ExtendedVerification
-  );
-
-/**
-  Write a string to the output device.
-
-  @param  This   The protocol instance pointer.
-  @param  String The NULL-terminated string to be displayed on the output
-                 device(s). All output devices must also support the Unicode
-                 drawing character codes defined in this file.
-
-  @retval EFI_SUCCESS             The string was output to the device.
-  @retval EFI_DEVICE_ERROR        The device reported an error while attempting to output
-                                  the text.
-  @retval EFI_UNSUPPORTED         The output device's mode is not currently in a
-                                  defined text mode.
-  @retval EFI_WARN_UNKNOWN_GLYPH  This warning code indicates that some of the
-                                  characters in the string could not be
-                                  rendered and were skipped.
-
-**/
-typedef
-EFI_STATUS
-(EFIAPI *EFI_TEXT_STRING)(
-  IN EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL        *This,
-  IN CHAR16                                 *String
-  );
-
-/**
-  Verifies that all characters in a string can be output to the
-  target device.
-
-  @param  This   The protocol instance pointer.
-  @param  String The NULL-terminated string to be examined for the output
-                 device(s).
-
-  @retval EFI_SUCCESS      The device(s) are capable of rendering the output string.
-  @retval EFI_UNSUPPORTED  Some of the characters in the string cannot be
-                           rendered by one or more of the output devices mapped
-                           by the EFI handle.
-
-**/
-typedef
-EFI_STATUS
-(EFIAPI *EFI_TEXT_TEST_STRING)(
-  IN EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL        *This,
-  IN CHAR16                                 *String
-  );
-
-/**
-  Returns information for an available text mode that the output device(s)
-  supports.
-
-  @param  This       The protocol instance pointer.
-  @param  ModeNumber The mode number to return information on.
-  @param  Columns    Returns the geometry of the text output device for the
-                     requested ModeNumber.
-  @param  Rows       Returns the geometry of the text output device for the
-                     requested ModeNumber.
-
-  @retval EFI_SUCCESS      The requested mode information was returned.
-  @retval EFI_DEVICE_ERROR The device had an error and could not complete the request.
-  @retval EFI_UNSUPPORTED  The mode number was not valid.
-
-**/
-typedef
-EFI_STATUS
-(EFIAPI *EFI_TEXT_QUERY_MODE)(
-  IN EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL        *This,
-  IN UINTN                                  ModeNumber,
-  OUT UINTN                                 *Columns,
-  OUT UINTN                                 *Rows
-  );
-
-/**
-  Sets the output device(s) to a specified mode.
-
-  @param  This       The protocol instance pointer.
-  @param  ModeNumber The mode number to set.
-
-  @retval EFI_SUCCESS      The requested text mode was set.
-  @retval EFI_DEVICE_ERROR The device had an error and could not complete the request.
-  @retval EFI_UNSUPPORTED  The mode number was not valid.
-
-**/
-typedef
-EFI_STATUS
-(EFIAPI *EFI_TEXT_SET_MODE)(
-  IN EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL        *This,
-  IN UINTN                                  ModeNumber
-  );
-
-/**
-  Sets the background and foreground colors for the OutputString () and
-  ClearScreen () functions.
-
-  @param  This      The protocol instance pointer.
-  @param  Attribute The attribute to set. Bits 0..3 are the foreground color, and
-                    bits 4..6 are the background color. All other bits are undefined
-                    and must be zero. The valid Attributes are defined in this file.
-
-  @retval EFI_SUCCESS       The attribute was set.
-  @retval EFI_DEVICE_ERROR  The device had an error and could not complete the request.
-  @retval EFI_UNSUPPORTED   The attribute requested is not defined.
-
-**/
-typedef
-EFI_STATUS
-(EFIAPI *EFI_TEXT_SET_ATTRIBUTE)(
-  IN EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL        *This,
-  IN UINTN                                  Attribute
-  );
-
-/**
-  Clears the output device(s) display to the currently selected background
-  color.
-
-  @param  This              The protocol instance pointer.
-
-  @retval  EFI_SUCCESS      The operation completed successfully.
-  @retval  EFI_DEVICE_ERROR The device had an error and could not complete the request.
-  @retval  EFI_UNSUPPORTED  The output device is not in a valid text mode.
-
-**/
-typedef
-EFI_STATUS
-(EFIAPI *EFI_TEXT_CLEAR_SCREEN)(
-  IN EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL   *This
-  );
-
-/**
-  Sets the current coordinates of the cursor position
-
-  @param  This        The protocol instance pointer.
-  @param  Column      The position to set the cursor to. Must be greater than or
-                      equal to zero and less than the number of columns and rows
-                      by QueryMode ().
-  @param  Row         The position to set the cursor to. Must be greater than or
-                      equal to zero and less than the number of columns and rows
-                      by QueryMode ().
-
-  @retval EFI_SUCCESS      The operation completed successfully.
-  @retval EFI_DEVICE_ERROR The device had an error and could not complete the request.
-  @retval EFI_UNSUPPORTED  The output device is not in a valid text mode, or the
-                           cursor position is invalid for the current mode.
-
-**/
-typedef
-EFI_STATUS
-(EFIAPI *EFI_TEXT_SET_CURSOR_POSITION)(
-  IN EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL        *This,
-  IN UINTN                                  Column,
-  IN UINTN                                  Row
-  );
-
-/**
-  Makes the cursor visible or invisible
-
-  @param  This    The protocol instance pointer.
-  @param  Visible If TRUE, the cursor is set to be visible. If FALSE, the cursor is
-                  set to be invisible.
-
-  @retval EFI_SUCCESS      The operation completed successfully.
-  @retval EFI_DEVICE_ERROR The device had an error and could not complete the
-                           request, or the device does not support changing
-                           the cursor mode.
-  @retval EFI_UNSUPPORTED  The output device is not in a valid text mode.
-
-**/
-typedef
-EFI_STATUS
-(EFIAPI *EFI_TEXT_ENABLE_CURSOR)(
-  IN EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL        *This,
-  IN BOOLEAN                                Visible
-  );
-
-/**
-  @par Data Structure Description:
-  Mode Structure pointed to by Simple Text Out protocol.
-**/
-typedef struct {
-  ///
-  /// The number of modes supported by QueryMode () and SetMode ().
-  ///
-  INT32   MaxMode;
-
-  //
-  // current settings
-  //
-
-  ///
-  /// The text mode of the output device(s).
-  ///
-  INT32   Mode;
-  ///
-  /// The current character output attribute.
-  ///
-  INT32   Attribute;
-  ///
-  /// The cursor's column.
-  ///
-  INT32   CursorColumn;
-  ///
-  /// The cursor's row.
-  ///
-  INT32   CursorRow;
-  ///
-  /// The cursor is currently visbile or not.
-  ///
-  BOOLEAN CursorVisible;
-} EFI_SIMPLE_TEXT_OUTPUT_MODE;
-
-///
-/// The SIMPLE_TEXT_OUTPUT protocol is used to control text-based output devices.
-/// It is the minimum required protocol for any handle supplied as the ConsoleOut
-/// or StandardError device. In addition, the minimum supported text mode of such
-/// devices is at least 80 x 25 characters.
-///
-struct _EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL {
-  EFI_TEXT_RESET                Reset;
-
-  EFI_TEXT_STRING               OutputString;
-  EFI_TEXT_TEST_STRING          TestString;
-
-  EFI_TEXT_QUERY_MODE           QueryMode;
-  EFI_TEXT_SET_MODE             SetMode;
-  EFI_TEXT_SET_ATTRIBUTE        SetAttribute;
-
-  EFI_TEXT_CLEAR_SCREEN         ClearScreen;
-  EFI_TEXT_SET_CURSOR_POSITION  SetCursorPosition;
-  EFI_TEXT_ENABLE_CURSOR        EnableCursor;
-
-  ///
-  /// Pointer to SIMPLE_TEXT_OUTPUT_MODE data.
-  ///
-  EFI_SIMPLE_TEXT_OUTPUT_MODE   *Mode;
-};
-
-extern EFI_GUID gEfiSimpleTextOutProtocolGuid;
-
-#endif
diff --git a/src/efi/Uefi.h b/src/efi/Uefi.h
deleted file mode 100644
index 326b4ac..0000000
--- a/src/efi/Uefi.h
+++ /dev/null
@@ -1,27 +0,0 @@
-/** @file
-
-  Root include file for Mde Package UEFI, UEFI_APPLICATION type modules.
-
-  This is the include file for any module of type UEFI and UEFI_APPLICATION. Uefi modules only use
-  types defined via this include file and can be ported easily to any
-  environment.
-
-Copyright (c) 2006 - 2010, Intel Corporation. All rights reserved.<BR>
-This program and the accompanying materials are licensed and made available under
-the terms and conditions of the BSD License that accompanies this distribution.
-The full text of the license may be found at
-http://opensource.org/licenses/bsd-license.php.
-
-THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
-WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
-
-**/
-
-#ifndef __PI_UEFI_H__
-#define __PI_UEFI_H__
-
-#include "efi/Uefi/UefiBaseType.h"
-#include "efi/Uefi/UefiSpec.h"
-
-#endif
-
diff --git a/src/efi/Uefi/UefiBaseType.h b/src/efi/Uefi/UefiBaseType.h
deleted file mode 100644
index fabf72e..0000000
--- a/src/efi/Uefi/UefiBaseType.h
+++ /dev/null
@@ -1,301 +0,0 @@
-/** @file
-  Defines data types and constants introduced in UEFI.
-
-Copyright (c) 2006 - 2011, Intel Corporation. All rights reserved.<BR>
-Portions copyright (c) 2011 - 2013, ARM Ltd. All rights reserved.<BR>
-
-This program and the accompanying materials are licensed and made available under
-the terms and conditions of the BSD License that accompanies this distribution.
-The full text of the license may be found at
-http://opensource.org/licenses/bsd-license.php.
-
-THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
-WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
-
-**/
-
-#ifndef __UEFI_BASETYPE_H__
-#define __UEFI_BASETYPE_H__
-
-#include "efi/Base.h"
-
-//
-// Basic data type definitions introduced in UEFI.
-//
-
-///
-/// 128-bit buffer containing a unique identifier value.
-///
-typedef GUID                      EFI_GUID;
-///
-/// Function return status for EFI API.
-///
-typedef RETURN_STATUS             EFI_STATUS;
-///
-/// A collection of related interfaces.
-///
-typedef VOID                      *EFI_HANDLE;
-///
-/// Handle to an event structure.
-///
-typedef VOID                      *EFI_EVENT;
-///
-/// Task priority level.
-///
-typedef UINTN                     EFI_TPL;
-///
-/// Logical block address.
-///
-typedef UINT64                    EFI_LBA;
-
-///
-/// 64-bit physical memory address.
-///
-typedef UINT64                    EFI_PHYSICAL_ADDRESS;
-
-///
-/// 64-bit virtual memory address.
-///
-typedef UINT64                    EFI_VIRTUAL_ADDRESS;
-
-///
-/// EFI Time Abstraction:
-///  Year:       1900 - 9999
-///  Month:      1 - 12
-///  Day:        1 - 31
-///  Hour:       0 - 23
-///  Minute:     0 - 59
-///  Second:     0 - 59
-///  Nanosecond: 0 - 999,999,999
-///  TimeZone:   -1440 to 1440 or 2047
-///
-typedef struct {
-  UINT16  Year;
-  UINT8   Month;
-  UINT8   Day;
-  UINT8   Hour;
-  UINT8   Minute;
-  UINT8   Second;
-  UINT8   Pad1;
-  UINT32  Nanosecond;
-  INT16   TimeZone;
-  UINT8   Daylight;
-  UINT8   Pad2;
-} EFI_TIME;
-
-
-///
-/// 4-byte buffer. An IPv4 internet protocol address.
-///
-typedef struct {
-  UINT8 Addr[4];
-} EFI_IPv4_ADDRESS;
-
-///
-/// 16-byte buffer. An IPv6 internet protocol address.
-///
-typedef struct {
-  UINT8 Addr[16];
-} EFI_IPv6_ADDRESS;
-
-///
-/// 32-byte buffer containing a network Media Access Control address.
-///
-typedef struct {
-  UINT8 Addr[32];
-} EFI_MAC_ADDRESS;
-
-///
-/// 16-byte buffer aligned on a 4-byte boundary.
-/// An IPv4 or IPv6 internet protocol address.
-///
-typedef union {
-  UINT32            Addr[4];
-  EFI_IPv4_ADDRESS  v4;
-  EFI_IPv6_ADDRESS  v6;
-} EFI_IP_ADDRESS;
-
-
-///
-/// Enumeration of EFI_STATUS.
-///@{
-#define EFI_SUCCESS               RETURN_SUCCESS
-#define EFI_LOAD_ERROR            RETURN_LOAD_ERROR
-#define EFI_INVALID_PARAMETER     RETURN_INVALID_PARAMETER
-#define EFI_UNSUPPORTED           RETURN_UNSUPPORTED
-#define EFI_BAD_BUFFER_SIZE       RETURN_BAD_BUFFER_SIZE
-#define EFI_BUFFER_TOO_SMALL      RETURN_BUFFER_TOO_SMALL
-#define EFI_NOT_READY             RETURN_NOT_READY
-#define EFI_DEVICE_ERROR          RETURN_DEVICE_ERROR
-#define EFI_WRITE_PROTECTED       RETURN_WRITE_PROTECTED
-#define EFI_OUT_OF_RESOURCES      RETURN_OUT_OF_RESOURCES
-#define EFI_VOLUME_CORRUPTED      RETURN_VOLUME_CORRUPTED
-#define EFI_VOLUME_FULL           RETURN_VOLUME_FULL
-#define EFI_NO_MEDIA              RETURN_NO_MEDIA
-#define EFI_MEDIA_CHANGED         RETURN_MEDIA_CHANGED
-#define EFI_NOT_FOUND             RETURN_NOT_FOUND
-#define EFI_ACCESS_DENIED         RETURN_ACCESS_DENIED
-#define EFI_NO_RESPONSE           RETURN_NO_RESPONSE
-#define EFI_NO_MAPPING            RETURN_NO_MAPPING
-#define EFI_TIMEOUT               RETURN_TIMEOUT
-#define EFI_NOT_STARTED           RETURN_NOT_STARTED
-#define EFI_ALREADY_STARTED       RETURN_ALREADY_STARTED
-#define EFI_ABORTED               RETURN_ABORTED
-#define EFI_ICMP_ERROR            RETURN_ICMP_ERROR
-#define EFI_TFTP_ERROR            RETURN_TFTP_ERROR
-#define EFI_PROTOCOL_ERROR        RETURN_PROTOCOL_ERROR
-#define EFI_INCOMPATIBLE_VERSION  RETURN_INCOMPATIBLE_VERSION
-#define EFI_SECURITY_VIOLATION    RETURN_SECURITY_VIOLATION
-#define EFI_CRC_ERROR             RETURN_CRC_ERROR
-#define EFI_END_OF_MEDIA          RETURN_END_OF_MEDIA
-#define EFI_END_OF_FILE           RETURN_END_OF_FILE
-#define EFI_INVALID_LANGUAGE      RETURN_INVALID_LANGUAGE
-#define EFI_COMPROMISED_DATA      RETURN_COMPROMISED_DATA
-
-#define EFI_WARN_UNKNOWN_GLYPH    RETURN_WARN_UNKNOWN_GLYPH
-#define EFI_WARN_DELETE_FAILURE   RETURN_WARN_DELETE_FAILURE
-#define EFI_WARN_WRITE_FAILURE    RETURN_WARN_WRITE_FAILURE
-#define EFI_WARN_BUFFER_TOO_SMALL RETURN_WARN_BUFFER_TOO_SMALL
-#define EFI_WARN_STALE_DATA       RETURN_WARN_STALE_DATA
-///@}
-
-///
-/// Define macro to encode the status code.
-///
-#define EFIERR(_a)                ENCODE_ERROR(_a)
-
-#define EFI_ERROR(A)              RETURN_ERROR(A)
-
-///
-/// ICMP error definitions
-///@{
-#define EFI_NETWORK_UNREACHABLE   EFIERR(100)
-#define EFI_HOST_UNREACHABLE      EFIERR(101)
-#define EFI_PROTOCOL_UNREACHABLE  EFIERR(102)
-#define EFI_PORT_UNREACHABLE      EFIERR(103)
-///@}
-
-///
-/// Tcp connection status definitions
-///@{
-#define EFI_CONNECTION_FIN        EFIERR(104)
-#define EFI_CONNECTION_RESET      EFIERR(105)
-#define EFI_CONNECTION_REFUSED    EFIERR(106)
-///@}
-
-//
-// The EFI memory allocation functions work in units of EFI_PAGEs that are
-// 4KB. This should in no way be confused with the page size of the processor.
-// An EFI_PAGE is just the quanta of memory in EFI.
-//
-#define EFI_PAGE_SIZE             SIZE_4KB
-#define EFI_PAGE_MASK             0xFFF
-#define EFI_PAGE_SHIFT            12
-
-/**
-  Macro that converts a size, in bytes, to a number of EFI_PAGESs.
-
-  @param  Size      A size in bytes.  This parameter is assumed to be type UINTN.
-                    Passing in a parameter that is larger than UINTN may produce
-                    unexpected results.
-
-  @return  The number of EFI_PAGESs associated with the number of bytes specified
-           by Size.
-
-**/
-#define EFI_SIZE_TO_PAGES(Size)  (((Size) >> EFI_PAGE_SHIFT) + (((Size) & EFI_PAGE_MASK) ? 1 : 0))
-
-/**
-  Macro that converts a number of EFI_PAGEs to a size in bytes.
-
-  @param  Pages     The number of EFI_PAGES.  This parameter is assumed to be
-                    type UINTN.  Passing in a parameter that is larger than
-                    UINTN may produce unexpected results.
-
-  @return  The number of bytes associated with the number of EFI_PAGEs specified
-           by Pages.
-
-**/
-#define EFI_PAGES_TO_SIZE(Pages)  ((Pages) << EFI_PAGE_SHIFT)
-
-///
-/// PE32+ Machine type for IA32 UEFI images.
-///
-#define EFI_IMAGE_MACHINE_IA32            0x014C
-
-///
-/// PE32+ Machine type for IA64 UEFI images.
-///
-#define EFI_IMAGE_MACHINE_IA64            0x0200
-
-///
-/// PE32+ Machine type for EBC UEFI images.
-///
-#define EFI_IMAGE_MACHINE_EBC             0x0EBC
-
-///
-/// PE32+ Machine type for X64 UEFI images.
-///
-#define EFI_IMAGE_MACHINE_X64             0x8664
-
-///
-/// PE32+ Machine type for ARM mixed ARM and Thumb/Thumb2 images.
-///
-#define EFI_IMAGE_MACHINE_ARMTHUMB_MIXED  0x01C2
-
-///
-/// PE32+ Machine type for AARCH64 A64 images.
-///
-#define EFI_IMAGE_MACHINE_AARCH64  0xAA64
-
-
-#if   defined (MDE_CPU_IA32)
-
-#define EFI_IMAGE_MACHINE_TYPE_SUPPORTED(Machine) \
-  (((Machine) == EFI_IMAGE_MACHINE_IA32) || ((Machine) == EFI_IMAGE_MACHINE_EBC))
-
-#define EFI_IMAGE_MACHINE_CROSS_TYPE_SUPPORTED(Machine) ((Machine) == EFI_IMAGE_MACHINE_X64)
-
-#elif defined (MDE_CPU_IPF)
-
-#define EFI_IMAGE_MACHINE_TYPE_SUPPORTED(Machine) \
-  (((Machine) == EFI_IMAGE_MACHINE_IA64) || ((Machine) == EFI_IMAGE_MACHINE_EBC))
-
-#define EFI_IMAGE_MACHINE_CROSS_TYPE_SUPPORTED(Machine) (FALSE)
-
-#elif defined (MDE_CPU_X64)
-
-#define EFI_IMAGE_MACHINE_TYPE_SUPPORTED(Machine) \
-  (((Machine) == EFI_IMAGE_MACHINE_X64) || ((Machine) == EFI_IMAGE_MACHINE_EBC))
-
-#define EFI_IMAGE_MACHINE_CROSS_TYPE_SUPPORTED(Machine) ((Machine) == EFI_IMAGE_MACHINE_IA32)
-
-#elif defined (MDE_CPU_ARM)
-
-#define EFI_IMAGE_MACHINE_TYPE_SUPPORTED(Machine) \
-  (((Machine) == EFI_IMAGE_MACHINE_ARMTHUMB_MIXED) || ((Machine) == EFI_IMAGE_MACHINE_EBC))
-
-#define EFI_IMAGE_MACHINE_CROSS_TYPE_SUPPORTED(Machine) ((Machine) == EFI_IMAGE_MACHINE_ARMTHUMB_MIXED)
-
-#elif defined (MDE_CPU_AARCH64)
-
-#define EFI_IMAGE_MACHINE_TYPE_SUPPORTED(Machine) \
-  (((Machine) == EFI_IMAGE_MACHINE_AARCH64) || ((Machine) == EFI_IMAGE_MACHINE_EBC))
-
-#define EFI_IMAGE_MACHINE_CROSS_TYPE_SUPPORTED(Machine) (FALSE)
-
-#elif defined (MDE_CPU_EBC)
-
-///
-/// This is just to make sure you can cross compile with the EBC compiler.
-/// It does not make sense to have a PE loader coded in EBC.
-///
-#define EFI_IMAGE_MACHINE_TYPE_SUPPORTED(Machine) ((Machine) == EFI_IMAGE_MACHINE_EBC)
-
-#define EFI_IMAGE_MACHINE_CROSS_TYPE_SUPPORTED(Machine) (FALSE)
-
-#else
-#error Unknown Processor Type
-#endif
-
-#endif
diff --git a/src/efi/Uefi/UefiGpt.h b/src/efi/Uefi/UefiGpt.h
deleted file mode 100644
index 5aa2ee2..0000000
--- a/src/efi/Uefi/UefiGpt.h
+++ /dev/null
@@ -1,141 +0,0 @@
-/** @file
-  EFI Guid Partition Table Format Definition.
-
-Copyright (c) 2006 - 2011, Intel Corporation. All rights reserved.<BR>
-This program and the accompanying materials are licensed and made available under
-the terms and conditions of the BSD License that accompanies this distribution.
-The full text of the license may be found at
-http://opensource.org/licenses/bsd-license.php.
-
-THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
-WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
-
-**/
-
-#ifndef __UEFI_GPT_H__
-#define __UEFI_GPT_H__
-
-///
-/// The primary GUID Partition Table Header must be
-/// located in LBA 1 (i.e., the second logical block).
-///
-#define PRIMARY_PART_HEADER_LBA 1
-///
-/// EFI Partition Table Signature: "EFI PART".
-///
-#define EFI_PTAB_HEADER_ID      SIGNATURE_64 ('E','F','I',' ','P','A','R','T')
-
-#pragma pack(1)
-
-///
-/// GPT Partition Table Header.
-///
-typedef struct {
-  ///
-  /// The table header for the GPT partition Table.
-  /// This header contains EFI_PTAB_HEADER_ID.
-  ///
-  EFI_TABLE_HEADER  Header;
-  ///
-  /// The LBA that contains this data structure.
-  ///
-  EFI_LBA           MyLBA;
-  ///
-  /// LBA address of the alternate GUID Partition Table Header.
-  ///
-  EFI_LBA           AlternateLBA;
-  ///
-  /// The first usable logical block that may be used
-  /// by a partition described by a GUID Partition Entry.
-  ///
-  EFI_LBA           FirstUsableLBA;
-  ///
-  /// The last usable logical block that may be used
-  /// by a partition described by a GUID Partition Entry.
-  ///
-  EFI_LBA           LastUsableLBA;
-  ///
-  /// GUID that can be used to uniquely identify the disk.
-  ///
-  EFI_GUID          DiskGUID;
-  ///
-  /// The starting LBA of the GUID Partition Entry array.
-  ///
-  EFI_LBA           PartitionEntryLBA;
-  ///
-  /// The number of Partition Entries in the GUID Partition Entry array.
-  ///
-  UINT32            NumberOfPartitionEntries;
-  ///
-  /// The size, in bytes, of each the GUID Partition
-  /// Entry structures in the GUID Partition Entry
-  /// array. This field shall be set to a value of 128 x 2^n where n is
-  /// an integer greater than or equal to zero (e.g., 128, 256, 512, etc.).
-  ///
-  UINT32            SizeOfPartitionEntry;
-  ///
-  /// The CRC32 of the GUID Partition Entry array.
-  /// Starts at PartitionEntryLBA and is
-  /// computed over a byte length of
-  /// NumberOfPartitionEntries * SizeOfPartitionEntry.
-  ///
-  UINT32            PartitionEntryArrayCRC32;
-} EFI_PARTITION_TABLE_HEADER;
-
-///
-/// GPT Partition Entry.
-///
-typedef struct {
-  ///
-  /// Unique ID that defines the purpose and type of this Partition. A value of
-  /// zero defines that this partition entry is not being used.
-  ///
-  EFI_GUID  PartitionTypeGUID;
-  ///
-  /// GUID that is unique for every partition entry. Every partition ever
-  /// created will have a unique GUID.
-  /// This GUID must be assigned when the GUID Partition Entry is created.
-  ///
-  EFI_GUID  UniquePartitionGUID;
-  ///
-  /// Starting LBA of the partition defined by this entry
-  ///
-  EFI_LBA   StartingLBA;
-  ///
-  /// Ending LBA of the partition defined by this entry.
-  ///
-  EFI_LBA   EndingLBA;
-  ///
-  /// Attribute bits, all bits reserved by UEFI
-  /// Bit 0:      If this bit is set, the partition is required for the platform to function. The owner/creator of the
-  ///             partition indicates that deletion or modification of the contents can result in loss of platform
-  ///             features or failure for the platform to boot or operate. The system cannot function normally if
-  ///             this partition is removed, and it should be considered part of the hardware of the system.
-  ///             Actions such as running diagnostics, system recovery, or even OS install or boot, could
-  ///             potentially stop working if this partition is removed. Unless OS software or firmware
-  ///             recognizes this partition, it should never be removed or modified as the UEFI firmware or
-  ///             platform hardware may become non-functional.
-  /// Bit 1:      If this bit is set, then firmware must not produce an EFI_BLOCK_IO_PROTOCOL device for
-  ///             this partition. By not producing an EFI_BLOCK_IO_PROTOCOL partition, file system
-  ///             mappings will not be created for this partition in UEFI.
-  /// Bit 2:      This bit is set aside to let systems with traditional PC-AT BIOS firmware implementations
-  ///             inform certain limited, special-purpose software running on these systems that a GPT
-  ///             partition may be bootable. The UEFI boot manager must ignore this bit when selecting
-  ///             a UEFI-compliant application, e.g., an OS loader.
-  /// Bits 3-47:  Undefined and must be zero. Reserved for expansion by future versions of the UEFI
-  ///             specification.
-  /// Bits 48-63: Reserved for GUID specific use. The use of these bits will vary depending on the
-  ///             PartitionTypeGUID. Only the owner of the PartitionTypeGUID is allowed
-  ///             to modify these bits. They must be preserved if Bits 0-47 are modified..
-  ///
-  UINT64    Attributes;
-  ///
-  /// Null-terminated name of the partition.
-  ///
-  CHAR16    PartitionName[36];
-} EFI_PARTITION_ENTRY;
-
-#pragma pack()
-#endif
-
-
diff --git a/src/efi/Uefi/UefiInternalFormRepresentation.h b/src/efi/Uefi/UefiInternalFormRepresentation.h
deleted file mode 100644
index 790555e..0000000
--- a/src/efi/Uefi/UefiInternalFormRepresentation.h
+++ /dev/null
@@ -1,2106 +0,0 @@
-/** @file
-  This file defines the encoding for the VFR (Visual Form Representation) language.
-  IFR is primarily consumed by the EFI presentation engine, and produced by EFI
-  internal application and drivers as well as all add-in card option-ROM drivers
-
-Copyright (c) 2006 - 2013, Intel Corporation. All rights reserved.<BR>
-This program and the accompanying materials are licensed and made available under
-the terms and conditions of the BSD License that accompanies this distribution.
-The full text of the license may be found at
-http://opensource.org/licenses/bsd-license.php.
-
-THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
-WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
-
-  @par Revision Reference:
-  These definitions are from UEFI 2.1 and 2.2.
-
-**/
-
-#ifndef __UEFI_INTERNAL_FORMREPRESENTATION_H__
-#define __UEFI_INTERNAL_FORMREPRESENTATION_H__
-
-#include "efi/Guid/HiiFormMapMethodGuid.h"
-
-///
-/// The following types are currently defined:
-///
-typedef VOID*   EFI_HII_HANDLE;
-typedef CHAR16* EFI_STRING;
-typedef UINT16  EFI_IMAGE_ID;
-typedef UINT16  EFI_QUESTION_ID;
-typedef UINT16  EFI_STRING_ID;
-typedef UINT16  EFI_FORM_ID;
-typedef UINT16  EFI_VARSTORE_ID;
-typedef UINT16  EFI_ANIMATION_ID;
-
-typedef UINT16  EFI_DEFAULT_ID;
-
-typedef UINT32  EFI_HII_FONT_STYLE;
-
-
-
-#pragma pack(1)
-
-//
-// Definitions for Package Lists and Package Headers
-// Section 27.3.1
-//
-
-///
-/// The header found at the start of each package list.
-///
-typedef struct {
-  EFI_GUID               PackageListGuid;
-  UINT32                 PackageLength;
-} EFI_HII_PACKAGE_LIST_HEADER;
-
-///
-/// The header found at the start of each package.
-///
-typedef struct {
-  UINT32  Length:24;
-  UINT32  Type:8;
-  // UINT8  Data[...];
-} EFI_HII_PACKAGE_HEADER;
-
-//
-// Value of HII package type
-//
-#define EFI_HII_PACKAGE_TYPE_ALL             0x00
-#define EFI_HII_PACKAGE_TYPE_GUID            0x01
-#define EFI_HII_PACKAGE_FORMS                0x02
-#define EFI_HII_PACKAGE_STRINGS              0x04
-#define EFI_HII_PACKAGE_FONTS                0x05
-#define EFI_HII_PACKAGE_IMAGES               0x06
-#define EFI_HII_PACKAGE_SIMPLE_FONTS         0x07
-#define EFI_HII_PACKAGE_DEVICE_PATH          0x08
-#define EFI_HII_PACKAGE_KEYBOARD_LAYOUT      0x09
-#define EFI_HII_PACKAGE_ANIMATIONS           0x0A
-#define EFI_HII_PACKAGE_END                  0xDF
-#define EFI_HII_PACKAGE_TYPE_SYSTEM_BEGIN    0xE0
-#define EFI_HII_PACKAGE_TYPE_SYSTEM_END      0xFF
-
-//
-// Definitions for Simplified Font Package
-//
-
-///
-/// Contents of EFI_NARROW_GLYPH.Attributes.
-///@{
-#define EFI_GLYPH_NON_SPACING                0x01
-#define EFI_GLYPH_WIDE                       0x02
-#define EFI_GLYPH_HEIGHT                     19
-#define EFI_GLYPH_WIDTH                      8
-///@}
-
-///
-/// The EFI_NARROW_GLYPH has a preferred dimension (w x h) of 8 x 19 pixels.
-///
-typedef struct {
-  ///
-  /// The Unicode representation of the glyph. The term weight is the
-  /// technical term for a character code.
-  ///
-  CHAR16                 UnicodeWeight;
-  ///
-  /// The data element containing the glyph definitions.
-  ///
-  UINT8                  Attributes;
-  ///
-  /// The column major glyph representation of the character. Bits
-  /// with values of one indicate that the corresponding pixel is to be
-  /// on when normally displayed; those with zero are off.
-  ///
-  UINT8                  GlyphCol1[EFI_GLYPH_HEIGHT];
-} EFI_NARROW_GLYPH;
-
-///
-/// The EFI_WIDE_GLYPH has a preferred dimension (w x h) of 16 x 19 pixels, which is large enough
-/// to accommodate logographic characters.
-///
-typedef struct {
-  ///
-  /// The Unicode representation of the glyph. The term weight is the
-  /// technical term for a character code.
-  ///
-  CHAR16                 UnicodeWeight;
-  ///
-  /// The data element containing the glyph definitions.
-  ///
-  UINT8                  Attributes;
-  ///
-  /// The column major glyph representation of the character. Bits
-  /// with values of one indicate that the corresponding pixel is to be
-  /// on when normally displayed; those with zero are off.
-  ///
-  UINT8                  GlyphCol1[EFI_GLYPH_HEIGHT];
-  ///
-  /// The column major glyph representation of the character. Bits
-  /// with values of one indicate that the corresponding pixel is to be
-  /// on when normally displayed; those with zero are off.
-  ///
-  UINT8                  GlyphCol2[EFI_GLYPH_HEIGHT];
-  ///
-  /// Ensures that sizeof (EFI_WIDE_GLYPH) is twice the
-  /// sizeof (EFI_NARROW_GLYPH). The contents of Pad must
-  /// be zero.
-  ///
-  UINT8                  Pad[3];
-} EFI_WIDE_GLYPH;
-
-///
-/// A simplified font package consists of a font header
-/// followed by a series of glyph structures.
-///
-typedef struct _EFI_HII_SIMPLE_FONT_PACKAGE_HDR {
-  EFI_HII_PACKAGE_HEADER Header;
-  UINT16                 NumberOfNarrowGlyphs;
-  UINT16                 NumberOfWideGlyphs;
-  // EFI_NARROW_GLYPH       NarrowGlyphs[];
-  // EFI_WIDE_GLYPH         WideGlyphs[];
-} EFI_HII_SIMPLE_FONT_PACKAGE_HDR;
-
-//
-// Definitions for Font Package
-// Section 27.3.3
-//
-
-//
-// Value for font style
-//
-#define EFI_HII_FONT_STYLE_NORMAL            0x00000000
-#define EFI_HII_FONT_STYLE_BOLD              0x00000001
-#define EFI_HII_FONT_STYLE_ITALIC            0x00000002
-#define EFI_HII_FONT_STYLE_EMBOSS            0x00010000
-#define EFI_HII_FONT_STYLE_OUTLINE           0x00020000
-#define EFI_HII_FONT_STYLE_SHADOW            0x00040000
-#define EFI_HII_FONT_STYLE_UNDERLINE         0x00080000
-#define EFI_HII_FONT_STYLE_DBL_UNDER         0x00100000
-
-typedef struct _EFI_HII_GLYPH_INFO {
-  UINT16                 Width;
-  UINT16                 Height;
-  INT16                  OffsetX;
-  INT16                  OffsetY;
-  INT16                  AdvanceX;
-} EFI_HII_GLYPH_INFO;
-
-///
-/// The fixed header consists of a standard record header,
-/// then the character values in this section, the flags
-/// (including the encoding method) and the offsets of the glyph
-/// information, the glyph bitmaps and the character map.
-///
-typedef struct _EFI_HII_FONT_PACKAGE_HDR {
-  EFI_HII_PACKAGE_HEADER Header;
-  UINT32                 HdrSize;
-  UINT32                 GlyphBlockOffset;
-  EFI_HII_GLYPH_INFO     Cell;
-  EFI_HII_FONT_STYLE     FontStyle;
-  CHAR16                 FontFamily[1];
-} EFI_HII_FONT_PACKAGE_HDR;
-
-//
-// Value of different glyph info block types
-//
-#define EFI_HII_GIBT_END                  0x00
-#define EFI_HII_GIBT_GLYPH                0x10
-#define EFI_HII_GIBT_GLYPHS               0x11
-#define EFI_HII_GIBT_GLYPH_DEFAULT        0x12
-#define EFI_HII_GIBT_GLYPHS_DEFAULT       0x13
-#define EFI_HII_GIBT_DUPLICATE            0x20
-#define EFI_HII_GIBT_SKIP2                0x21
-#define EFI_HII_GIBT_SKIP1                0x22
-#define EFI_HII_GIBT_DEFAULTS             0x23
-#define EFI_HII_GIBT_EXT1                 0x30
-#define EFI_HII_GIBT_EXT2                 0x31
-#define EFI_HII_GIBT_EXT4                 0x32
-
-typedef struct _EFI_HII_GLYPH_BLOCK {
-  UINT8                  BlockType;
-} EFI_HII_GLYPH_BLOCK;
-
-//
-// Definition of different glyph info block types
-//
-
-typedef struct _EFI_HII_GIBT_DEFAULTS_BLOCK {
-  EFI_HII_GLYPH_BLOCK    Header;
-  EFI_HII_GLYPH_INFO     Cell;
-} EFI_HII_GIBT_DEFAULTS_BLOCK;
-
-typedef struct _EFI_HII_GIBT_DUPLICATE_BLOCK {
-  EFI_HII_GLYPH_BLOCK    Header;
-  CHAR16                 CharValue;
-} EFI_HII_GIBT_DUPLICATE_BLOCK;
-
-typedef struct _EFI_GLYPH_GIBT_END_BLOCK {
-  EFI_HII_GLYPH_BLOCK    Header;
-} EFI_GLYPH_GIBT_END_BLOCK;
-
-typedef struct _EFI_HII_GIBT_EXT1_BLOCK {
-  EFI_HII_GLYPH_BLOCK    Header;
-  UINT8                  BlockType2;
-  UINT8                  Length;
-} EFI_HII_GIBT_EXT1_BLOCK;
-
-typedef struct _EFI_HII_GIBT_EXT2_BLOCK {
-  EFI_HII_GLYPH_BLOCK    Header;
-  UINT8                  BlockType2;
-  UINT16                 Length;
-} EFI_HII_GIBT_EXT2_BLOCK;
-
-typedef struct _EFI_HII_GIBT_EXT4_BLOCK {
-  EFI_HII_GLYPH_BLOCK    Header;
-  UINT8                  BlockType2;
-  UINT32                 Length;
-} EFI_HII_GIBT_EXT4_BLOCK;
-
-typedef struct _EFI_HII_GIBT_GLYPH_BLOCK {
-  EFI_HII_GLYPH_BLOCK    Header;
-  EFI_HII_GLYPH_INFO     Cell;
-  UINT8                  BitmapData[1];
-} EFI_HII_GIBT_GLYPH_BLOCK;
-
-typedef struct _EFI_HII_GIBT_GLYPHS_BLOCK {
-  EFI_HII_GLYPH_BLOCK    Header;
-  EFI_HII_GLYPH_INFO     Cell;
-  UINT16                 Count;
-  UINT8                  BitmapData[1];
-} EFI_HII_GIBT_GLYPHS_BLOCK;
-
-typedef struct _EFI_HII_GIBT_GLYPH_DEFAULT_BLOCK {
-  EFI_HII_GLYPH_BLOCK    Header;
-  UINT8                  BitmapData[1];
-} EFI_HII_GIBT_GLYPH_DEFAULT_BLOCK;
-
-typedef struct _EFI_HII_GIBT_GLYPHS_DEFAULT_BLOCK {
-  EFI_HII_GLYPH_BLOCK    Header;
-  UINT16                 Count;
-  UINT8                  BitmapData[1];
-} EFI_HII_GIBT_GLYPHS_DEFAULT_BLOCK;
-
-typedef struct _EFI_HII_GIBT_SKIP1_BLOCK {
-  EFI_HII_GLYPH_BLOCK    Header;
-  UINT8                  SkipCount;
-} EFI_HII_GIBT_SKIP1_BLOCK;
-
-typedef struct _EFI_HII_GIBT_SKIP2_BLOCK {
-  EFI_HII_GLYPH_BLOCK    Header;
-  UINT16                 SkipCount;
-} EFI_HII_GIBT_SKIP2_BLOCK;
-
-//
-// Definitions for Device Path Package
-// Section 27.3.4
-//
-
-///
-/// The device path package is used to carry a device path
-/// associated with the package list.
-///
-typedef struct _EFI_HII_DEVICE_PATH_PACKAGE_HDR {
-  EFI_HII_PACKAGE_HEADER   Header;
-  // EFI_DEVICE_PATH_PROTOCOL DevicePath[];
-} EFI_HII_DEVICE_PATH_PACKAGE_HDR;
-
-//
-// Definitions for GUID Package
-// Section 27.3.5
-//
-
-///
-/// The GUID package is used to carry data where the format is defined by a GUID.
-///
-typedef struct _EFI_HII_GUID_PACKAGE_HDR {
-  EFI_HII_PACKAGE_HEADER  Header;
-  EFI_GUID                Guid;
-  // Data per GUID definition may follow
-} EFI_HII_GUID_PACKAGE_HDR;
-
-//
-// Definitions for String Package
-// Section 27.3.6
-//
-
-#define UEFI_CONFIG_LANG   "x-UEFI"
-#define UEFI_CONFIG_LANG_2 "x-i-UEFI"
-
-///
-/// The fixed header consists of a standard record header and then the string identifiers
-/// contained in this section and the offsets of the string and language information.
-///
-typedef struct _EFI_HII_STRING_PACKAGE_HDR {
-  EFI_HII_PACKAGE_HEADER  Header;
-  UINT32                  HdrSize;
-  UINT32                  StringInfoOffset;
-  CHAR16                  LanguageWindow[16];
-  EFI_STRING_ID           LanguageName;
-  CHAR8                   Language[1];
-} EFI_HII_STRING_PACKAGE_HDR;
-
-typedef struct {
-  UINT8                   BlockType;
-} EFI_HII_STRING_BLOCK;
-
-//
-// Value of different string information block types
-//
-#define EFI_HII_SIBT_END                     0x00
-#define EFI_HII_SIBT_STRING_SCSU             0x10
-#define EFI_HII_SIBT_STRING_SCSU_FONT        0x11
-#define EFI_HII_SIBT_STRINGS_SCSU            0x12
-#define EFI_HII_SIBT_STRINGS_SCSU_FONT       0x13
-#define EFI_HII_SIBT_STRING_UCS2             0x14
-#define EFI_HII_SIBT_STRING_UCS2_FONT        0x15
-#define EFI_HII_SIBT_STRINGS_UCS2            0x16
-#define EFI_HII_SIBT_STRINGS_UCS2_FONT       0x17
-#define EFI_HII_SIBT_DUPLICATE               0x20
-#define EFI_HII_SIBT_SKIP2                   0x21
-#define EFI_HII_SIBT_SKIP1                   0x22
-#define EFI_HII_SIBT_EXT1                    0x30
-#define EFI_HII_SIBT_EXT2                    0x31
-#define EFI_HII_SIBT_EXT4                    0x32
-#define EFI_HII_SIBT_FONT                    0x40
-
-//
-// Definition of different string information block types
-//
-
-typedef struct _EFI_HII_SIBT_DUPLICATE_BLOCK {
-  EFI_HII_STRING_BLOCK    Header;
-  EFI_STRING_ID           StringId;
-} EFI_HII_SIBT_DUPLICATE_BLOCK;
-
-typedef struct _EFI_HII_SIBT_END_BLOCK {
-  EFI_HII_STRING_BLOCK    Header;
-} EFI_HII_SIBT_END_BLOCK;
-
-typedef struct _EFI_HII_SIBT_EXT1_BLOCK {
-  EFI_HII_STRING_BLOCK    Header;
-  UINT8                   BlockType2;
-  UINT8                   Length;
-} EFI_HII_SIBT_EXT1_BLOCK;
-
-typedef struct _EFI_HII_SIBT_EXT2_BLOCK {
-  EFI_HII_STRING_BLOCK    Header;
-  UINT8                   BlockType2;
-  UINT16                  Length;
-} EFI_HII_SIBT_EXT2_BLOCK;
-
-typedef struct _EFI_HII_SIBT_EXT4_BLOCK {
-  EFI_HII_STRING_BLOCK    Header;
-  UINT8                   BlockType2;
-  UINT32                  Length;
-} EFI_HII_SIBT_EXT4_BLOCK;
-
-typedef struct _EFI_HII_SIBT_FONT_BLOCK {
-  EFI_HII_SIBT_EXT2_BLOCK Header;
-  UINT8                   FontId;
-  UINT16                  FontSize;
-  EFI_HII_FONT_STYLE      FontStyle;
-  CHAR16                  FontName[1];
-} EFI_HII_SIBT_FONT_BLOCK;
-
-typedef struct _EFI_HII_SIBT_SKIP1_BLOCK {
-  EFI_HII_STRING_BLOCK    Header;
-  UINT8                   SkipCount;
-} EFI_HII_SIBT_SKIP1_BLOCK;
-
-typedef struct _EFI_HII_SIBT_SKIP2_BLOCK {
-  EFI_HII_STRING_BLOCK    Header;
-  UINT16                  SkipCount;
-} EFI_HII_SIBT_SKIP2_BLOCK;
-
-typedef struct _EFI_HII_SIBT_STRING_SCSU_BLOCK {
-  EFI_HII_STRING_BLOCK    Header;
-  UINT8                   StringText[1];
-} EFI_HII_SIBT_STRING_SCSU_BLOCK;
-
-typedef struct _EFI_HII_SIBT_STRING_SCSU_FONT_BLOCK {
-  EFI_HII_STRING_BLOCK    Header;
-  UINT8                   FontIdentifier;
-  UINT8                   StringText[1];
-} EFI_HII_SIBT_STRING_SCSU_FONT_BLOCK;
-
-typedef struct _EFI_HII_SIBT_STRINGS_SCSU_BLOCK {
-  EFI_HII_STRING_BLOCK    Header;
-  UINT16                  StringCount;
-  UINT8                   StringText[1];
-} EFI_HII_SIBT_STRINGS_SCSU_BLOCK;
-
-typedef struct _EFI_HII_SIBT_STRINGS_SCSU_FONT_BLOCK {
-  EFI_HII_STRING_BLOCK    Header;
-  UINT8                   FontIdentifier;
-  UINT16                  StringCount;
-  UINT8                   StringText[1];
-} EFI_HII_SIBT_STRINGS_SCSU_FONT_BLOCK;
-
-typedef struct _EFI_HII_SIBT_STRING_UCS2_BLOCK {
-  EFI_HII_STRING_BLOCK    Header;
-  CHAR16                  StringText[1];
-} EFI_HII_SIBT_STRING_UCS2_BLOCK;
-
-typedef struct _EFI_HII_SIBT_STRING_UCS2_FONT_BLOCK {
-  EFI_HII_STRING_BLOCK    Header;
-  UINT8                   FontIdentifier;
-  CHAR16                  StringText[1];
-} EFI_HII_SIBT_STRING_UCS2_FONT_BLOCK;
-
-typedef struct _EFI_HII_SIBT_STRINGS_UCS2_BLOCK {
-  EFI_HII_STRING_BLOCK    Header;
-  UINT16                  StringCount;
-  CHAR16                  StringText[1];
-} EFI_HII_SIBT_STRINGS_UCS2_BLOCK;
-
-typedef struct _EFI_HII_SIBT_STRINGS_UCS2_FONT_BLOCK {
-  EFI_HII_STRING_BLOCK    Header;
-  UINT8                   FontIdentifier;
-  UINT16                  StringCount;
-  CHAR16                  StringText[1];
-} EFI_HII_SIBT_STRINGS_UCS2_FONT_BLOCK;
-
-//
-// Definitions for Image Package
-// Section 27.3.7
-//
-
-typedef struct _EFI_HII_IMAGE_PACKAGE_HDR {
-  EFI_HII_PACKAGE_HEADER  Header;
-  UINT32                  ImageInfoOffset;
-  UINT32                  PaletteInfoOffset;
-} EFI_HII_IMAGE_PACKAGE_HDR;
-
-typedef struct _EFI_HII_IMAGE_BLOCK {
-  UINT8                   BlockType;
-} EFI_HII_IMAGE_BLOCK;
-
-//
-// Value of different image information block types
-//
-#define EFI_HII_IIBT_END               0x00
-#define EFI_HII_IIBT_IMAGE_1BIT        0x10
-#define EFI_HII_IIBT_IMAGE_1BIT_TRANS  0x11
-#define EFI_HII_IIBT_IMAGE_4BIT        0x12
-#define EFI_HII_IIBT_IMAGE_4BIT_TRANS  0x13
-#define EFI_HII_IIBT_IMAGE_8BIT        0x14
-#define EFI_HII_IIBT_IMAGE_8BIT_TRANS  0x15
-#define EFI_HII_IIBT_IMAGE_24BIT       0x16
-#define EFI_HII_IIBT_IMAGE_24BIT_TRANS 0x17
-#define EFI_HII_IIBT_IMAGE_JPEG        0x18
-#define EFI_HII_IIBT_DUPLICATE         0x20
-#define EFI_HII_IIBT_SKIP2             0x21
-#define EFI_HII_IIBT_SKIP1             0x22
-#define EFI_HII_IIBT_EXT1              0x30
-#define EFI_HII_IIBT_EXT2              0x31
-#define EFI_HII_IIBT_EXT4              0x32
-
-//
-// Definition of different image information block types
-//
-
-typedef struct _EFI_HII_IIBT_END_BLOCK {
-  EFI_HII_IMAGE_BLOCK          Header;
-} EFI_HII_IIBT_END_BLOCK;
-
-typedef struct _EFI_HII_IIBT_EXT1_BLOCK {
-  EFI_HII_IMAGE_BLOCK          Header;
-  UINT8                        BlockType2;
-  UINT8                        Length;
-} EFI_HII_IIBT_EXT1_BLOCK;
-
-typedef struct _EFI_HII_IIBT_EXT2_BLOCK {
-  EFI_HII_IMAGE_BLOCK          Header;
-  UINT8                        BlockType2;
-  UINT16                       Length;
-} EFI_HII_IIBT_EXT2_BLOCK;
-
-typedef struct _EFI_HII_IIBT_EXT4_BLOCK {
-  EFI_HII_IMAGE_BLOCK          Header;
-  UINT8                        BlockType2;
-  UINT32                       Length;
-} EFI_HII_IIBT_EXT4_BLOCK;
-
-typedef struct _EFI_HII_IIBT_IMAGE_1BIT_BASE {
-  UINT16                       Width;
-  UINT16                       Height;
-  UINT8                        Data[1];
-} EFI_HII_IIBT_IMAGE_1BIT_BASE;
-
-typedef struct _EFI_HII_IIBT_IMAGE_1BIT_BLOCK {
-  EFI_HII_IMAGE_BLOCK          Header;
-  UINT8                        PaletteIndex;
-  EFI_HII_IIBT_IMAGE_1BIT_BASE Bitmap;
-} EFI_HII_IIBT_IMAGE_1BIT_BLOCK;
-
-typedef struct _EFI_HII_IIBT_IMAGE_1BIT_TRANS_BLOCK {
-  EFI_HII_IMAGE_BLOCK          Header;
-  UINT8                        PaletteIndex;
-  EFI_HII_IIBT_IMAGE_1BIT_BASE Bitmap;
-} EFI_HII_IIBT_IMAGE_1BIT_TRANS_BLOCK;
-
-typedef struct _EFI_HII_RGB_PIXEL {
-  UINT8                        b;
-  UINT8                        g;
-  UINT8                        r;
-} EFI_HII_RGB_PIXEL;
-
-typedef struct _EFI_HII_IIBT_IMAGE_24BIT_BASE {
-  UINT16                       Width;
-  UINT16                       Height;
-  EFI_HII_RGB_PIXEL            Bitmap[1];
-} EFI_HII_IIBT_IMAGE_24BIT_BASE;
-
-typedef struct _EFI_HII_IIBT_IMAGE_24BIT_BLOCK {
-  EFI_HII_IMAGE_BLOCK           Header;
-  EFI_HII_IIBT_IMAGE_24BIT_BASE Bitmap;
-} EFI_HII_IIBT_IMAGE_24BIT_BLOCK;
-
-typedef struct _EFI_HII_IIBT_IMAGE_24BIT_TRANS_BLOCK {
-  EFI_HII_IMAGE_BLOCK           Header;
-  EFI_HII_IIBT_IMAGE_24BIT_BASE Bitmap;
-} EFI_HII_IIBT_IMAGE_24BIT_TRANS_BLOCK;
-
-typedef struct _EFI_HII_IIBT_IMAGE_4BIT_BASE {
-  UINT16                       Width;
-  UINT16                       Height;
-  UINT8                        Data[1];
-} EFI_HII_IIBT_IMAGE_4BIT_BASE;
-
-typedef struct _EFI_HII_IIBT_IMAGE_4BIT_BLOCK {
-  EFI_HII_IMAGE_BLOCK          Header;
-  UINT8                        PaletteIndex;
-  EFI_HII_IIBT_IMAGE_4BIT_BASE Bitmap;
-} EFI_HII_IIBT_IMAGE_4BIT_BLOCK;
-
-typedef struct _EFI_HII_IIBT_IMAGE_4BIT_TRANS_BLOCK {
-  EFI_HII_IMAGE_BLOCK          Header;
-  UINT8                        PaletteIndex;
-  EFI_HII_IIBT_IMAGE_4BIT_BASE Bitmap;
-} EFI_HII_IIBT_IMAGE_4BIT_TRANS_BLOCK;
-
-typedef struct _EFI_HII_IIBT_IMAGE_8BIT_BASE {
-  UINT16                       Width;
-  UINT16                       Height;
-  UINT8                        Data[1];
-} EFI_HII_IIBT_IMAGE_8BIT_BASE;
-
-typedef struct _EFI_HII_IIBT_IMAGE_8BIT_PALETTE_BLOCK {
-  EFI_HII_IMAGE_BLOCK          Header;
-  UINT8                        PaletteIndex;
-  EFI_HII_IIBT_IMAGE_8BIT_BASE Bitmap;
-} EFI_HII_IIBT_IMAGE_8BIT_BLOCK;
-
-typedef struct _EFI_HII_IIBT_IMAGE_8BIT_TRANS_BLOCK {
-  EFI_HII_IMAGE_BLOCK          Header;
-  UINT8                        PaletteIndex;
-  EFI_HII_IIBT_IMAGE_8BIT_BASE Bitmap;
-} EFI_HII_IIBT_IMAGE_8BIT_TRAN_BLOCK;
-
-typedef struct _EFI_HII_IIBT_DUPLICATE_BLOCK {
-  EFI_HII_IMAGE_BLOCK          Header;
-  EFI_IMAGE_ID                 ImageId;
-} EFI_HII_IIBT_DUPLICATE_BLOCK;
-
-typedef struct _EFI_HII_IIBT_JPEG_BLOCK {
-  EFI_HII_IMAGE_BLOCK          Header;
-  UINT32                       Size;
-  UINT8                        Data[1];
-} EFI_HII_IIBT_JPEG_BLOCK;
-
-typedef struct _EFI_HII_IIBT_SKIP1_BLOCK {
-  EFI_HII_IMAGE_BLOCK          Header;
-  UINT8                        SkipCount;
-} EFI_HII_IIBT_SKIP1_BLOCK;
-
-typedef struct _EFI_HII_IIBT_SKIP2_BLOCK {
-  EFI_HII_IMAGE_BLOCK          Header;
-  UINT16                       SkipCount;
-} EFI_HII_IIBT_SKIP2_BLOCK;
-
-//
-// Definitions for Palette Information
-//
-
-typedef struct _EFI_HII_IMAGE_PALETTE_INFO_HEADER {
-  UINT16                       PaletteCount;
-} EFI_HII_IMAGE_PALETTE_INFO_HEADER;
-
-typedef struct _EFI_HII_IMAGE_PALETTE_INFO {
-  UINT16                       PaletteSize;
-  EFI_HII_RGB_PIXEL            PaletteValue[1];
-} EFI_HII_IMAGE_PALETTE_INFO;
-
-//
-// Definitions for Forms Package
-// Section 27.3.8
-//
-
-///
-/// The Form package is used to carry form-based encoding data.
-///
-typedef struct _EFI_HII_FORM_PACKAGE_HDR {
-  EFI_HII_PACKAGE_HEADER       Header;
-  // EFI_IFR_OP_HEADER         OpCodeHeader;
-  // More op-codes follow
-} EFI_HII_FORM_PACKAGE_HDR;
-
-typedef struct {
-  UINT8 Hour;
-  UINT8 Minute;
-  UINT8 Second;
-} EFI_HII_TIME;
-
-typedef struct {
-  UINT16 Year;
-  UINT8  Month;
-  UINT8  Day;
-} EFI_HII_DATE;
-
-typedef struct {
-  EFI_QUESTION_ID QuestionId;
-  EFI_FORM_ID     FormId;
-  EFI_GUID        FormSetGuid;
-  EFI_STRING_ID   DevicePath;
-} EFI_HII_REF;
-
-typedef union {
-  UINT8           u8;
-  UINT16          u16;
-  UINT32          u32;
-  UINT64          u64;
-  BOOLEAN         b;
-  EFI_HII_TIME    time;
-  EFI_HII_DATE    date;
-  EFI_STRING_ID   string; ///< EFI_IFR_TYPE_STRING, EFI_IFR_TYPE_ACTION
-  EFI_HII_REF     ref;    ///< EFI_IFR_TYPE_REF
-  // UINT8 buffer[];      ///< EFI_IFR_TYPE_BUFFER
-} EFI_IFR_TYPE_VALUE;
-
-//
-// IFR Opcodes
-//
-#define EFI_IFR_FORM_OP                0x01
-#define EFI_IFR_SUBTITLE_OP            0x02
-#define EFI_IFR_TEXT_OP                0x03
-#define EFI_IFR_IMAGE_OP               0x04
-#define EFI_IFR_ONE_OF_OP              0x05
-#define EFI_IFR_CHECKBOX_OP            0x06
-#define EFI_IFR_NUMERIC_OP             0x07
-#define EFI_IFR_PASSWORD_OP            0x08
-#define EFI_IFR_ONE_OF_OPTION_OP       0x09
-#define EFI_IFR_SUPPRESS_IF_OP         0x0A
-#define EFI_IFR_LOCKED_OP              0x0B
-#define EFI_IFR_ACTION_OP              0x0C
-#define EFI_IFR_RESET_BUTTON_OP        0x0D
-#define EFI_IFR_FORM_SET_OP            0x0E
-#define EFI_IFR_REF_OP                 0x0F
-#define EFI_IFR_NO_SUBMIT_IF_OP        0x10
-#define EFI_IFR_INCONSISTENT_IF_OP     0x11
-#define EFI_IFR_EQ_ID_VAL_OP           0x12
-#define EFI_IFR_EQ_ID_ID_OP            0x13
-#define EFI_IFR_EQ_ID_VAL_LIST_OP      0x14
-#define EFI_IFR_AND_OP                 0x15
-#define EFI_IFR_OR_OP                  0x16
-#define EFI_IFR_NOT_OP                 0x17
-#define EFI_IFR_RULE_OP                0x18
-#define EFI_IFR_GRAY_OUT_IF_OP         0x19
-#define EFI_IFR_DATE_OP                0x1A
-#define EFI_IFR_TIME_OP                0x1B
-#define EFI_IFR_STRING_OP              0x1C
-#define EFI_IFR_REFRESH_OP             0x1D
-#define EFI_IFR_DISABLE_IF_OP          0x1E
-#define EFI_IFR_ANIMATION_OP           0x1F
-#define EFI_IFR_TO_LOWER_OP            0x20
-#define EFI_IFR_TO_UPPER_OP            0x21
-#define EFI_IFR_MAP_OP                 0x22
-#define EFI_IFR_ORDERED_LIST_OP        0x23
-#define EFI_IFR_VARSTORE_OP            0x24
-#define EFI_IFR_VARSTORE_NAME_VALUE_OP 0x25
-#define EFI_IFR_VARSTORE_EFI_OP        0x26
-#define EFI_IFR_VARSTORE_DEVICE_OP     0x27
-#define EFI_IFR_VERSION_OP             0x28
-#define EFI_IFR_END_OP                 0x29
-#define EFI_IFR_MATCH_OP               0x2A
-#define EFI_IFR_GET_OP                 0x2B
-#define EFI_IFR_SET_OP                 0x2C
-#define EFI_IFR_READ_OP                0x2D
-#define EFI_IFR_WRITE_OP               0x2E
-#define EFI_IFR_EQUAL_OP               0x2F
-#define EFI_IFR_NOT_EQUAL_OP           0x30
-#define EFI_IFR_GREATER_THAN_OP        0x31
-#define EFI_IFR_GREATER_EQUAL_OP       0x32
-#define EFI_IFR_LESS_THAN_OP           0x33
-#define EFI_IFR_LESS_EQUAL_OP          0x34
-#define EFI_IFR_BITWISE_AND_OP         0x35
-#define EFI_IFR_BITWISE_OR_OP          0x36
-#define EFI_IFR_BITWISE_NOT_OP         0x37
-#define EFI_IFR_SHIFT_LEFT_OP          0x38
-#define EFI_IFR_SHIFT_RIGHT_OP         0x39
-#define EFI_IFR_ADD_OP                 0x3A
-#define EFI_IFR_SUBTRACT_OP            0x3B
-#define EFI_IFR_MULTIPLY_OP            0x3C
-#define EFI_IFR_DIVIDE_OP              0x3D
-#define EFI_IFR_MODULO_OP              0x3E
-#define EFI_IFR_RULE_REF_OP            0x3F
-#define EFI_IFR_QUESTION_REF1_OP       0x40
-#define EFI_IFR_QUESTION_REF2_OP       0x41
-#define EFI_IFR_UINT8_OP               0x42
-#define EFI_IFR_UINT16_OP              0x43
-#define EFI_IFR_UINT32_OP              0x44
-#define EFI_IFR_UINT64_OP              0x45
-#define EFI_IFR_TRUE_OP                0x46
-#define EFI_IFR_FALSE_OP               0x47
-#define EFI_IFR_TO_UINT_OP             0x48
-#define EFI_IFR_TO_STRING_OP           0x49
-#define EFI_IFR_TO_BOOLEAN_OP          0x4A
-#define EFI_IFR_MID_OP                 0x4B
-#define EFI_IFR_FIND_OP                0x4C
-#define EFI_IFR_TOKEN_OP               0x4D
-#define EFI_IFR_STRING_REF1_OP         0x4E
-#define EFI_IFR_STRING_REF2_OP         0x4F
-#define EFI_IFR_CONDITIONAL_OP         0x50
-#define EFI_IFR_QUESTION_REF3_OP       0x51
-#define EFI_IFR_ZERO_OP                0x52
-#define EFI_IFR_ONE_OP                 0x53
-#define EFI_IFR_ONES_OP                0x54
-#define EFI_IFR_UNDEFINED_OP           0x55
-#define EFI_IFR_LENGTH_OP              0x56
-#define EFI_IFR_DUP_OP                 0x57
-#define EFI_IFR_THIS_OP                0x58
-#define EFI_IFR_SPAN_OP                0x59
-#define EFI_IFR_VALUE_OP               0x5A
-#define EFI_IFR_DEFAULT_OP             0x5B
-#define EFI_IFR_DEFAULTSTORE_OP        0x5C
-#define EFI_IFR_FORM_MAP_OP            0x5D
-#define EFI_IFR_CATENATE_OP            0x5E
-#define EFI_IFR_GUID_OP                0x5F
-#define EFI_IFR_SECURITY_OP            0x60
-#define EFI_IFR_MODAL_TAG_OP           0x61
-#define EFI_IFR_REFRESH_ID_OP          0x62
-#define EFI_IFR_WARNING_IF_OP          0x63
-
-//
-// Definitions of IFR Standard Headers
-// Section 27.3.8.2
-//
-
-typedef struct _EFI_IFR_OP_HEADER {
-  UINT8                    OpCode;
-  UINT8                    Length:7;
-  UINT8                    Scope:1;
-} EFI_IFR_OP_HEADER;
-
-typedef struct _EFI_IFR_STATEMENT_HEADER {
-  EFI_STRING_ID            Prompt;
-  EFI_STRING_ID            Help;
-} EFI_IFR_STATEMENT_HEADER;
-
-typedef struct _EFI_IFR_QUESTION_HEADER {
-  EFI_IFR_STATEMENT_HEADER Header;
-  EFI_QUESTION_ID          QuestionId;
-  EFI_VARSTORE_ID          VarStoreId;
-  union {
-    EFI_STRING_ID          VarName;
-    UINT16                 VarOffset;
-  }                        VarStoreInfo;
-  UINT8                    Flags;
-} EFI_IFR_QUESTION_HEADER;
-
-//
-// Flag values of EFI_IFR_QUESTION_HEADER
-//
-#define EFI_IFR_FLAG_READ_ONLY         0x01
-#define EFI_IFR_FLAG_CALLBACK          0x04
-#define EFI_IFR_FLAG_RESET_REQUIRED    0x10
-#define EFI_IFR_FLAG_OPTIONS_ONLY      0x80
-
-//
-// Definition for Opcode Reference
-// Section 27.3.8.3
-//
-typedef struct _EFI_IFR_DEFAULTSTORE {
-  EFI_IFR_OP_HEADER        Header;
-  EFI_STRING_ID            DefaultName;
-  UINT16                   DefaultId;
-} EFI_IFR_DEFAULTSTORE;
-
-//
-// Default Identifier of default store
-//
-#define EFI_HII_DEFAULT_CLASS_STANDARD       0x0000
-#define EFI_HII_DEFAULT_CLASS_MANUFACTURING  0x0001
-#define EFI_HII_DEFAULT_CLASS_SAFE           0x0002
-#define EFI_HII_DEFAULT_CLASS_PLATFORM_BEGIN 0x4000
-#define EFI_HII_DEFAULT_CLASS_PLATFORM_END   0x7fff
-#define EFI_HII_DEFAULT_CLASS_HARDWARE_BEGIN 0x8000
-#define EFI_HII_DEFAULT_CLASS_HARDWARE_END   0xbfff
-#define EFI_HII_DEFAULT_CLASS_FIRMWARE_BEGIN 0xc000
-#define EFI_HII_DEFAULT_CLASS_FIRMWARE_END   0xffff
-
-typedef struct _EFI_IFR_VARSTORE {
-  EFI_IFR_OP_HEADER        Header;
-  EFI_GUID                 Guid;
-  EFI_VARSTORE_ID          VarStoreId;
-  UINT16                   Size;
-  UINT8                    Name[1];
-} EFI_IFR_VARSTORE;
-
-typedef struct _EFI_IFR_VARSTORE_EFI {
-  EFI_IFR_OP_HEADER        Header;
-  EFI_VARSTORE_ID          VarStoreId;
-  EFI_GUID                 Guid;
-  UINT32                   Attributes;
-  UINT16                   Size;
-  UINT8                    Name[1];
-} EFI_IFR_VARSTORE_EFI;
-
-typedef struct _EFI_IFR_VARSTORE_NAME_VALUE {
-  EFI_IFR_OP_HEADER        Header;
-  EFI_VARSTORE_ID          VarStoreId;
-  EFI_GUID                 Guid;
-} EFI_IFR_VARSTORE_NAME_VALUE;
-
-typedef struct _EFI_IFR_FORM_SET {
-  EFI_IFR_OP_HEADER        Header;
-  EFI_GUID                 Guid;
-  EFI_STRING_ID            FormSetTitle;
-  EFI_STRING_ID            Help;
-  UINT8                    Flags;
-  // EFI_GUID              ClassGuid[];
-} EFI_IFR_FORM_SET;
-
-typedef struct _EFI_IFR_END {
-  EFI_IFR_OP_HEADER        Header;
-} EFI_IFR_END;
-
-typedef struct _EFI_IFR_FORM {
-  EFI_IFR_OP_HEADER        Header;
-  UINT16                   FormId;
-  EFI_STRING_ID            FormTitle;
-} EFI_IFR_FORM;
-
-typedef struct _EFI_IFR_IMAGE {
-  EFI_IFR_OP_HEADER        Header;
-  EFI_IMAGE_ID             Id;
-} EFI_IFR_IMAGE;
-
-typedef struct _EFI_IFR_MODAL_TAG {
-  EFI_IFR_OP_HEADER        Header;
-} EFI_IFR_MODAL_TAG;
-
-typedef struct _EFI_IFR_LOCKED {
-  EFI_IFR_OP_HEADER        Header;
-} EFI_IFR_LOCKED;
-
-typedef struct _EFI_IFR_RULE {
-  EFI_IFR_OP_HEADER        Header;
-  UINT8                    RuleId;
-} EFI_IFR_RULE;
-
-typedef struct _EFI_IFR_DEFAULT {
-  EFI_IFR_OP_HEADER        Header;
-  UINT16                   DefaultId;
-  UINT8                    Type;
-  EFI_IFR_TYPE_VALUE       Value;
-} EFI_IFR_DEFAULT;
-
-typedef struct _EFI_IFR_DEFAULT_2 {
-  EFI_IFR_OP_HEADER        Header;
-  UINT16                   DefaultId;
-  UINT8                    Type;
-} EFI_IFR_DEFAULT_2;
-
-typedef struct _EFI_IFR_VALUE {
-  EFI_IFR_OP_HEADER        Header;
-} EFI_IFR_VALUE;
-
-typedef struct _EFI_IFR_SUBTITLE {
-  EFI_IFR_OP_HEADER        Header;
-  EFI_IFR_STATEMENT_HEADER Statement;
-  UINT8                    Flags;
-} EFI_IFR_SUBTITLE;
-
-#define EFI_IFR_FLAGS_HORIZONTAL       0x01
-
-typedef struct _EFI_IFR_CHECKBOX {
-  EFI_IFR_OP_HEADER        Header;
-  EFI_IFR_QUESTION_HEADER  Question;
-  UINT8                    Flags;
-} EFI_IFR_CHECKBOX;
-
-#define EFI_IFR_CHECKBOX_DEFAULT       0x01
-#define EFI_IFR_CHECKBOX_DEFAULT_MFG   0x02
-
-typedef struct _EFI_IFR_TEXT {
-  EFI_IFR_OP_HEADER        Header;
-  EFI_IFR_STATEMENT_HEADER Statement;
-  EFI_STRING_ID            TextTwo;
-} EFI_IFR_TEXT;
-
-typedef struct _EFI_IFR_REF {
-  EFI_IFR_OP_HEADER        Header;
-  EFI_IFR_QUESTION_HEADER  Question;
-  EFI_FORM_ID              FormId;
-} EFI_IFR_REF;
-
-typedef struct _EFI_IFR_REF2 {
-  EFI_IFR_OP_HEADER        Header;
-  EFI_IFR_QUESTION_HEADER  Question;
-  EFI_FORM_ID              FormId;
-  EFI_QUESTION_ID          QuestionId;
-} EFI_IFR_REF2;
-
-typedef struct _EFI_IFR_REF3 {
-  EFI_IFR_OP_HEADER        Header;
-  EFI_IFR_QUESTION_HEADER  Question;
-  EFI_FORM_ID              FormId;
-  EFI_QUESTION_ID          QuestionId;
-  EFI_GUID                 FormSetId;
-} EFI_IFR_REF3;
-
-typedef struct _EFI_IFR_REF4 {
-  EFI_IFR_OP_HEADER        Header;
-  EFI_IFR_QUESTION_HEADER  Question;
-  EFI_FORM_ID              FormId;
-  EFI_QUESTION_ID          QuestionId;
-  EFI_GUID                 FormSetId;
-  EFI_STRING_ID            DevicePath;
-} EFI_IFR_REF4;
-
-typedef struct _EFI_IFR_REF5 {
-  EFI_IFR_OP_HEADER Header;
-  EFI_IFR_QUESTION_HEADER Question;
-} EFI_IFR_REF5;
-
-typedef struct _EFI_IFR_RESET_BUTTON {
-  EFI_IFR_OP_HEADER        Header;
-  EFI_IFR_STATEMENT_HEADER Statement;
-  EFI_DEFAULT_ID           DefaultId;
-} EFI_IFR_RESET_BUTTON;
-
-typedef struct _EFI_IFR_ACTION {
-  EFI_IFR_OP_HEADER        Header;
-  EFI_IFR_QUESTION_HEADER  Question;
-  EFI_STRING_ID            QuestionConfig;
-} EFI_IFR_ACTION;
-
-typedef struct _EFI_IFR_ACTION_1 {
-  EFI_IFR_OP_HEADER        Header;
-  EFI_IFR_QUESTION_HEADER  Question;
-} EFI_IFR_ACTION_1;
-
-typedef struct _EFI_IFR_DATE {
-  EFI_IFR_OP_HEADER        Header;
-  EFI_IFR_QUESTION_HEADER  Question;
-  UINT8                    Flags;
-} EFI_IFR_DATE;
-
-//
-// Flags that describe the behavior of the question.
-//
-#define EFI_QF_DATE_YEAR_SUPPRESS      0x01
-#define EFI_QF_DATE_MONTH_SUPPRESS     0x02
-#define EFI_QF_DATE_DAY_SUPPRESS       0x04
-
-#define EFI_QF_DATE_STORAGE            0x30
-#define     QF_DATE_STORAGE_NORMAL     0x00
-#define     QF_DATE_STORAGE_TIME       0x10
-#define     QF_DATE_STORAGE_WAKEUP     0x20
-
-typedef union {
-  struct {
-    UINT8 MinValue;
-    UINT8 MaxValue;
-    UINT8 Step;
-  } u8;
-  struct {
-    UINT16 MinValue;
-    UINT16 MaxValue;
-    UINT16 Step;
-  } u16;
-  struct {
-    UINT32 MinValue;
-    UINT32 MaxValue;
-    UINT32 Step;
-  } u32;
-  struct {
-    UINT64 MinValue;
-    UINT64 MaxValue;
-    UINT64 Step;
-  } u64;
-} MINMAXSTEP_DATA;
-
-typedef struct _EFI_IFR_NUMERIC {
-  EFI_IFR_OP_HEADER        Header;
-  EFI_IFR_QUESTION_HEADER  Question;
-  UINT8                    Flags;
-  MINMAXSTEP_DATA          data;
-} EFI_IFR_NUMERIC;
-
-//
-// Flags related to the numeric question
-//
-#define EFI_IFR_NUMERIC_SIZE           0x03
-#define   EFI_IFR_NUMERIC_SIZE_1       0x00
-#define   EFI_IFR_NUMERIC_SIZE_2       0x01
-#define   EFI_IFR_NUMERIC_SIZE_4       0x02
-#define   EFI_IFR_NUMERIC_SIZE_8       0x03
-
-#define EFI_IFR_DISPLAY                0x30
-#define   EFI_IFR_DISPLAY_INT_DEC      0x00
-#define   EFI_IFR_DISPLAY_UINT_DEC     0x10
-#define   EFI_IFR_DISPLAY_UINT_HEX     0x20
-
-typedef struct _EFI_IFR_ONE_OF {
-  EFI_IFR_OP_HEADER        Header;
-  EFI_IFR_QUESTION_HEADER  Question;
-  UINT8                    Flags;
-  MINMAXSTEP_DATA          data;
-} EFI_IFR_ONE_OF;
-
-typedef struct _EFI_IFR_STRING {
-  EFI_IFR_OP_HEADER        Header;
-  EFI_IFR_QUESTION_HEADER  Question;
-  UINT8                    MinSize;
-  UINT8                    MaxSize;
-  UINT8                    Flags;
-} EFI_IFR_STRING;
-
-#define EFI_IFR_STRING_MULTI_LINE      0x01
-
-typedef struct _EFI_IFR_PASSWORD {
-  EFI_IFR_OP_HEADER        Header;
-  EFI_IFR_QUESTION_HEADER  Question;
-  UINT16                   MinSize;
-  UINT16                   MaxSize;
-} EFI_IFR_PASSWORD;
-
-typedef struct _EFI_IFR_ORDERED_LIST {
-  EFI_IFR_OP_HEADER        Header;
-  EFI_IFR_QUESTION_HEADER  Question;
-  UINT8                    MaxContainers;
-  UINT8                    Flags;
-} EFI_IFR_ORDERED_LIST;
-
-#define EFI_IFR_UNIQUE_SET             0x01
-#define EFI_IFR_NO_EMPTY_SET           0x02
-
-typedef struct _EFI_IFR_TIME {
-  EFI_IFR_OP_HEADER        Header;
-  EFI_IFR_QUESTION_HEADER  Question;
-  UINT8                    Flags;
-} EFI_IFR_TIME;
-
-//
-// A bit-mask that determines which unique settings are active for this opcode.
-//
-#define QF_TIME_HOUR_SUPPRESS          0x01
-#define QF_TIME_MINUTE_SUPPRESS        0x02
-#define QF_TIME_SECOND_SUPPRESS        0x04
-
-#define QF_TIME_STORAGE                0x30
-#define   QF_TIME_STORAGE_NORMAL       0x00
-#define   QF_TIME_STORAGE_TIME         0x10
-#define   QF_TIME_STORAGE_WAKEUP       0x20
-
-typedef struct _EFI_IFR_DISABLE_IF {
-  EFI_IFR_OP_HEADER        Header;
-} EFI_IFR_DISABLE_IF;
-
-typedef struct _EFI_IFR_SUPPRESS_IF {
-  EFI_IFR_OP_HEADER        Header;
-} EFI_IFR_SUPPRESS_IF;
-
-typedef struct _EFI_IFR_GRAY_OUT_IF {
-  EFI_IFR_OP_HEADER        Header;
-} EFI_IFR_GRAY_OUT_IF;
-
-typedef struct _EFI_IFR_INCONSISTENT_IF {
-  EFI_IFR_OP_HEADER        Header;
-  EFI_STRING_ID            Error;
-} EFI_IFR_INCONSISTENT_IF;
-
-typedef struct _EFI_IFR_NO_SUBMIT_IF {
-  EFI_IFR_OP_HEADER        Header;
-  EFI_STRING_ID            Error;
-} EFI_IFR_NO_SUBMIT_IF;
-
-typedef struct _EFI_IFR_WARNING_IF {
-  EFI_IFR_OP_HEADER        Header;
-  EFI_STRING_ID            Warning;
-  UINT8                    TimeOut;
-} EFI_IFR_WARNING_IF;
-
-typedef struct _EFI_IFR_REFRESH {
-  EFI_IFR_OP_HEADER        Header;
-  UINT8                    RefreshInterval;
-} EFI_IFR_REFRESH;
-
-typedef struct _EFI_IFR_VARSTORE_DEVICE {
-  EFI_IFR_OP_HEADER        Header;
-  EFI_STRING_ID            DevicePath;
-} EFI_IFR_VARSTORE_DEVICE;
-
-typedef struct _EFI_IFR_ONE_OF_OPTION {
-  EFI_IFR_OP_HEADER        Header;
-  EFI_STRING_ID            Option;
-  UINT8                    Flags;
-  UINT8                    Type;
-  EFI_IFR_TYPE_VALUE       Value;
-} EFI_IFR_ONE_OF_OPTION;
-
-//
-// Types of the option's value.
-//
-#define EFI_IFR_TYPE_NUM_SIZE_8        0x00
-#define EFI_IFR_TYPE_NUM_SIZE_16       0x01
-#define EFI_IFR_TYPE_NUM_SIZE_32       0x02
-#define EFI_IFR_TYPE_NUM_SIZE_64       0x03
-#define EFI_IFR_TYPE_BOOLEAN           0x04
-#define EFI_IFR_TYPE_TIME              0x05
-#define EFI_IFR_TYPE_DATE              0x06
-#define EFI_IFR_TYPE_STRING            0x07
-#define EFI_IFR_TYPE_OTHER             0x08
-#define EFI_IFR_TYPE_UNDEFINED         0x09
-#define EFI_IFR_TYPE_ACTION            0x0A
-#define EFI_IFR_TYPE_BUFFER            0x0B
-#define EFI_IFR_TYPE_REF               0x0C
-
-#define EFI_IFR_OPTION_DEFAULT         0x10
-#define EFI_IFR_OPTION_DEFAULT_MFG     0x20
-
-typedef struct _EFI_IFR_GUID {
-  EFI_IFR_OP_HEADER        Header;
-  EFI_GUID                 Guid;
-  //Optional Data Follows
-} EFI_IFR_GUID;
-
-typedef struct _EFI_IFR_REFRESH_ID {
-  EFI_IFR_OP_HEADER Header;
-  EFI_GUID          RefreshEventGroupId;
-} EFI_IFR_REFRESH_ID;
-
-typedef struct _EFI_IFR_DUP {
-  EFI_IFR_OP_HEADER        Header;
-} EFI_IFR_DUP;
-
-typedef struct _EFI_IFR_EQ_ID_ID {
-  EFI_IFR_OP_HEADER        Header;
-  EFI_QUESTION_ID          QuestionId1;
-  EFI_QUESTION_ID          QuestionId2;
-} EFI_IFR_EQ_ID_ID;
-
-typedef struct _EFI_IFR_EQ_ID_VAL {
-  EFI_IFR_OP_HEADER        Header;
-  EFI_QUESTION_ID          QuestionId;
-  UINT16                   Value;
-} EFI_IFR_EQ_ID_VAL;
-
-typedef struct _EFI_IFR_EQ_ID_VAL_LIST {
-  EFI_IFR_OP_HEADER        Header;
-  EFI_QUESTION_ID          QuestionId;
-  UINT16                   ListLength;
-  UINT16                   ValueList[1];
-} EFI_IFR_EQ_ID_VAL_LIST;
-
-typedef struct _EFI_IFR_UINT8 {
-  EFI_IFR_OP_HEADER        Header;
-  UINT8 Value;
-} EFI_IFR_UINT8;
-
-typedef struct _EFI_IFR_UINT16 {
-  EFI_IFR_OP_HEADER        Header;
-  UINT16                   Value;
-} EFI_IFR_UINT16;
-
-typedef struct _EFI_IFR_UINT32 {
-  EFI_IFR_OP_HEADER        Header;
-  UINT32                   Value;
-} EFI_IFR_UINT32;
-
-typedef struct _EFI_IFR_UINT64 {
-  EFI_IFR_OP_HEADER        Header;
-  UINT64 Value;
-} EFI_IFR_UINT64;
-
-typedef struct _EFI_IFR_QUESTION_REF1 {
-  EFI_IFR_OP_HEADER        Header;
-  EFI_QUESTION_ID          QuestionId;
-} EFI_IFR_QUESTION_REF1;
-
-typedef struct _EFI_IFR_QUESTION_REF2 {
-  EFI_IFR_OP_HEADER        Header;
-} EFI_IFR_QUESTION_REF2;
-
-typedef struct _EFI_IFR_QUESTION_REF3 {
-  EFI_IFR_OP_HEADER        Header;
-} EFI_IFR_QUESTION_REF3;
-
-typedef struct _EFI_IFR_QUESTION_REF3_2 {
-  EFI_IFR_OP_HEADER        Header;
-  EFI_STRING_ID            DevicePath;
-} EFI_IFR_QUESTION_REF3_2;
-
-typedef struct _EFI_IFR_QUESTION_REF3_3 {
-  EFI_IFR_OP_HEADER        Header;
-  EFI_STRING_ID            DevicePath;
-  EFI_GUID                 Guid;
-} EFI_IFR_QUESTION_REF3_3;
-
-typedef struct _EFI_IFR_RULE_REF {
-  EFI_IFR_OP_HEADER        Header;
-  UINT8                    RuleId;
-} EFI_IFR_RULE_REF;
-
-typedef struct _EFI_IFR_STRING_REF1 {
-  EFI_IFR_OP_HEADER        Header;
-  EFI_STRING_ID            StringId;
-} EFI_IFR_STRING_REF1;
-
-typedef struct _EFI_IFR_STRING_REF2 {
-  EFI_IFR_OP_HEADER        Header;
-} EFI_IFR_STRING_REF2;
-
-typedef struct _EFI_IFR_THIS {
-  EFI_IFR_OP_HEADER        Header;
-} EFI_IFR_THIS;
-
-typedef struct _EFI_IFR_TRUE {
-  EFI_IFR_OP_HEADER        Header;
-} EFI_IFR_TRUE;
-
-typedef struct _EFI_IFR_FALSE {
-  EFI_IFR_OP_HEADER        Header;
-} EFI_IFR_FALSE;
-
-typedef struct _EFI_IFR_ONE {
-  EFI_IFR_OP_HEADER        Header;
-} EFI_IFR_ONE;
-
-typedef struct _EFI_IFR_ONES {
-  EFI_IFR_OP_HEADER        Header;
-} EFI_IFR_ONES;
-
-typedef struct _EFI_IFR_ZERO {
-  EFI_IFR_OP_HEADER        Header;
-} EFI_IFR_ZERO;
-
-typedef struct _EFI_IFR_UNDEFINED {
-  EFI_IFR_OP_HEADER        Header;
-} EFI_IFR_UNDEFINED;
-
-typedef struct _EFI_IFR_VERSION {
-  EFI_IFR_OP_HEADER        Header;
-} EFI_IFR_VERSION;
-
-typedef struct _EFI_IFR_LENGTH {
-  EFI_IFR_OP_HEADER        Header;
-} EFI_IFR_LENGTH;
-
-typedef struct _EFI_IFR_NOT {
-  EFI_IFR_OP_HEADER        Header;
-} EFI_IFR_NOT;
-
-typedef struct _EFI_IFR_BITWISE_NOT {
-  EFI_IFR_OP_HEADER        Header;
-} EFI_IFR_BITWISE_NOT;
-
-typedef struct _EFI_IFR_TO_BOOLEAN {
-  EFI_IFR_OP_HEADER        Header;
-} EFI_IFR_TO_BOOLEAN;
-
-///
-/// For EFI_IFR_TO_STRING, when converting from
-/// unsigned integers, these flags control the format:
-/// 0 = unsigned decimal.
-/// 1 = signed decimal.
-/// 2 = hexadecimal (lower-case alpha).
-/// 3 = hexadecimal (upper-case alpha).
-///@{
-#define EFI_IFR_STRING_UNSIGNED_DEC      0
-#define EFI_IFR_STRING_SIGNED_DEC        1
-#define EFI_IFR_STRING_LOWERCASE_HEX     2
-#define EFI_IFR_STRING_UPPERCASE_HEX     3
-///@}
-
-///
-/// When converting from a buffer, these flags control the format:
-/// 0 = ASCII.
-/// 8 = Unicode.
-///@{
-#define EFI_IFR_STRING_ASCII             0
-#define EFI_IFR_STRING_UNICODE           8
-///@}
-
-typedef struct _EFI_IFR_TO_STRING {
-  EFI_IFR_OP_HEADER        Header;
-  UINT8                    Format;
-} EFI_IFR_TO_STRING;
-
-typedef struct _EFI_IFR_TO_UINT {
-  EFI_IFR_OP_HEADER        Header;
-} EFI_IFR_TO_UINT;
-
-typedef struct _EFI_IFR_TO_UPPER {
-  EFI_IFR_OP_HEADER        Header;
-} EFI_IFR_TO_UPPER;
-
-typedef struct _EFI_IFR_TO_LOWER {
-  EFI_IFR_OP_HEADER        Header;
-} EFI_IFR_TO_LOWER;
-
-typedef struct _EFI_IFR_ADD {
-  EFI_IFR_OP_HEADER        Header;
-} EFI_IFR_ADD;
-
-typedef struct _EFI_IFR_AND {
-  EFI_IFR_OP_HEADER        Header;
-} EFI_IFR_AND;
-
-typedef struct _EFI_IFR_BITWISE_AND {
-  EFI_IFR_OP_HEADER        Header;
-} EFI_IFR_BITWISE_AND;
-
-typedef struct _EFI_IFR_BITWISE_OR {
-  EFI_IFR_OP_HEADER        Header;
-} EFI_IFR_BITWISE_OR;
-
-typedef struct _EFI_IFR_CATENATE {
-  EFI_IFR_OP_HEADER        Header;
-} EFI_IFR_CATENATE;
-
-typedef struct _EFI_IFR_DIVIDE {
-  EFI_IFR_OP_HEADER        Header;
-} EFI_IFR_DIVIDE;
-
-typedef struct _EFI_IFR_EQUAL {
-  EFI_IFR_OP_HEADER        Header;
-} EFI_IFR_EQUAL;
-
-typedef struct _EFI_IFR_GREATER_EQUAL {
-  EFI_IFR_OP_HEADER        Header;
-} EFI_IFR_GREATER_EQUAL;
-
-typedef struct _EFI_IFR_GREATER_THAN {
-  EFI_IFR_OP_HEADER        Header;
-} EFI_IFR_GREATER_THAN;
-
-typedef struct _EFI_IFR_LESS_EQUAL {
-  EFI_IFR_OP_HEADER        Header;
-} EFI_IFR_LESS_EQUAL;
-
-typedef struct _EFI_IFR_LESS_THAN {
-  EFI_IFR_OP_HEADER        Header;
-} EFI_IFR_LESS_THAN;
-
-typedef struct _EFI_IFR_MATCH {
-  EFI_IFR_OP_HEADER        Header;
-} EFI_IFR_MATCH;
-
-typedef struct _EFI_IFR_MULTIPLY {
-  EFI_IFR_OP_HEADER        Header;
-} EFI_IFR_MULTIPLY;
-
-typedef struct _EFI_IFR_MODULO {
-  EFI_IFR_OP_HEADER        Header;
-} EFI_IFR_MODULO;
-
-typedef struct _EFI_IFR_NOT_EQUAL {
-  EFI_IFR_OP_HEADER        Header;
-} EFI_IFR_NOT_EQUAL;
-
-typedef struct _EFI_IFR_OR {
-  EFI_IFR_OP_HEADER        Header;
-} EFI_IFR_OR;
-
-typedef struct _EFI_IFR_SHIFT_LEFT {
-  EFI_IFR_OP_HEADER        Header;
-} EFI_IFR_SHIFT_LEFT;
-
-typedef struct _EFI_IFR_SHIFT_RIGHT {
-  EFI_IFR_OP_HEADER        Header;
-} EFI_IFR_SHIFT_RIGHT;
-
-typedef struct _EFI_IFR_SUBTRACT {
-  EFI_IFR_OP_HEADER        Header;
-} EFI_IFR_SUBTRACT;
-
-typedef struct _EFI_IFR_CONDITIONAL {
-  EFI_IFR_OP_HEADER        Header;
-} EFI_IFR_CONDITIONAL;
-
-//
-// Flags governing the matching criteria of EFI_IFR_FIND
-//
-#define EFI_IFR_FF_CASE_SENSITIVE    0x00
-#define EFI_IFR_FF_CASE_INSENSITIVE  0x01
-
-typedef struct _EFI_IFR_FIND {
-  EFI_IFR_OP_HEADER        Header;
-  UINT8                    Format;
-} EFI_IFR_FIND;
-
-typedef struct _EFI_IFR_MID {
-  EFI_IFR_OP_HEADER        Header;
-} EFI_IFR_MID;
-
-typedef struct _EFI_IFR_TOKEN {
-  EFI_IFR_OP_HEADER        Header;
-} EFI_IFR_TOKEN;
-
-//
-// Flags specifying whether to find the first matching string
-// or the first non-matching string.
-//
-#define EFI_IFR_FLAGS_FIRST_MATCHING     0x00
-#define EFI_IFR_FLAGS_FIRST_NON_MATCHING 0x01
-
-typedef struct _EFI_IFR_SPAN {
-  EFI_IFR_OP_HEADER        Header;
-  UINT8                    Flags;
-} EFI_IFR_SPAN;
-
-typedef struct _EFI_IFR_SECURITY {
-  ///
-  /// Standard opcode header, where Header.Op = EFI_IFR_SECURITY_OP.
-  ///
-  EFI_IFR_OP_HEADER        Header;
-  ///
-  /// Security permission level.
-  ///
-  EFI_GUID                 Permissions;
-} EFI_IFR_SECURITY;
-
-typedef struct _EFI_IFR_FORM_MAP_METHOD {
-  ///
-  /// The string identifier which provides the human-readable name of
-  /// the configuration method for this standards map form.
-  ///
-  EFI_STRING_ID            MethodTitle;
-  ///
-  /// Identifier which uniquely specifies the configuration methods
-  /// associated with this standards map form.
-  ///
-  EFI_GUID                 MethodIdentifier;
-} EFI_IFR_FORM_MAP_METHOD;
-
-typedef struct _EFI_IFR_FORM_MAP {
-  ///
-  /// The sequence that defines the type of opcode as well as the length
-  /// of the opcode being defined. Header.OpCode = EFI_IFR_FORM_MAP_OP.
-  ///
-  EFI_IFR_OP_HEADER        Header;
-  ///
-  /// The unique identifier for this particular form.
-  ///
-  EFI_FORM_ID              FormId;
-  ///
-  /// One or more configuration method's name and unique identifier.
-  ///
-  // EFI_IFR_FORM_MAP_METHOD  Methods[];
-} EFI_IFR_FORM_MAP;
-
-typedef struct _EFI_IFR_SET {
-  ///
-  /// The sequence that defines the type of opcode as well as the length
-  /// of the opcode being defined. Header.OpCode = EFI_IFR_SET_OP.
-  ///
-  EFI_IFR_OP_HEADER  Header;
-  ///
-  /// Specifies the identifier of a previously declared variable store to
-  /// use when storing the question's value.
-  ///
-  EFI_VARSTORE_ID    VarStoreId;
-  union {
-    ///
-    /// A 16-bit Buffer Storage offset.
-    ///
-    EFI_STRING_ID    VarName;
-    ///
-    /// A Name Value or EFI Variable name (VarName).
-    ///
-    UINT16           VarOffset;
-  }                  VarStoreInfo;
-  ///
-  /// Specifies the type used for storage.
-  ///
-  UINT8              VarStoreType;
-} EFI_IFR_SET;
-
-typedef struct _EFI_IFR_GET {
-  ///
-  /// The sequence that defines the type of opcode as well as the length
-  /// of the opcode being defined. Header.OpCode = EFI_IFR_GET_OP.
-  ///
-  EFI_IFR_OP_HEADER  Header;
-  ///
-  /// Specifies the identifier of a previously declared variable store to
-  /// use when retrieving the value.
-  ///
-  EFI_VARSTORE_ID    VarStoreId;
-  union {
-    ///
-    /// A 16-bit Buffer Storage offset.
-    ///
-    EFI_STRING_ID    VarName;
-    ///
-    /// A Name Value or EFI Variable name (VarName).
-    ///
-    UINT16           VarOffset;
-  }                  VarStoreInfo;
-  ///
-  /// Specifies the type used for storage.
-  ///
-  UINT8              VarStoreType;
-} EFI_IFR_GET;
-
-typedef struct _EFI_IFR_READ {
-  EFI_IFR_OP_HEADER       Header;
-} EFI_IFR_READ;
-
-typedef struct _EFI_IFR_WRITE {
-  EFI_IFR_OP_HEADER      Header;
-} EFI_IFR_WRITE;
-
-typedef struct _EFI_IFR_MAP {
-  EFI_IFR_OP_HEADER      Header;
-} EFI_IFR_MAP;
-//
-// Definitions for Keyboard Package
-// Releated definitions are in Section of EFI_HII_DATABASE_PROTOCOL
-//
-
-///
-/// Each enumeration values maps a physical key on a keyboard.
-///
-typedef enum {
-  EfiKeyLCtrl,
-  EfiKeyA0,
-  EfiKeyLAlt,
-  EfiKeySpaceBar,
-  EfiKeyA2,
-  EfiKeyA3,
-  EfiKeyA4,
-  EfiKeyRCtrl,
-  EfiKeyLeftArrow,
-  EfiKeyDownArrow,
-  EfiKeyRightArrow,
-  EfiKeyZero,
-  EfiKeyPeriod,
-  EfiKeyEnter,
-  EfiKeyLShift,
-  EfiKeyB0,
-  EfiKeyB1,
-  EfiKeyB2,
-  EfiKeyB3,
-  EfiKeyB4,
-  EfiKeyB5,
-  EfiKeyB6,
-  EfiKeyB7,
-  EfiKeyB8,
-  EfiKeyB9,
-  EfiKeyB10,
-  EfiKeyRShift,
-  EfiKeyUpArrow,
-  EfiKeyOne,
-  EfiKeyTwo,
-  EfiKeyThree,
-  EfiKeyCapsLock,
-  EfiKeyC1,
-  EfiKeyC2,
-  EfiKeyC3,
-  EfiKeyC4,
-  EfiKeyC5,
-  EfiKeyC6,
-  EfiKeyC7,
-  EfiKeyC8,
-  EfiKeyC9,
-  EfiKeyC10,
-  EfiKeyC11,
-  EfiKeyC12,
-  EfiKeyFour,
-  EfiKeyFive,
-  EfiKeySix,
-  EfiKeyPlus,
-  EfiKeyTab,
-  EfiKeyD1,
-  EfiKeyD2,
-  EfiKeyD3,
-  EfiKeyD4,
-  EfiKeyD5,
-  EfiKeyD6,
-  EfiKeyD7,
-  EfiKeyD8,
-  EfiKeyD9,
-  EfiKeyD10,
-  EfiKeyD11,
-  EfiKeyD12,
-  EfiKeyD13,
-  EfiKeyDel,
-  EfiKeyEnd,
-  EfiKeyPgDn,
-  EfiKeySeven,
-  EfiKeyEight,
-  EfiKeyNine,
-  EfiKeyE0,
-  EfiKeyE1,
-  EfiKeyE2,
-  EfiKeyE3,
-  EfiKeyE4,
-  EfiKeyE5,
-  EfiKeyE6,
-  EfiKeyE7,
-  EfiKeyE8,
-  EfiKeyE9,
-  EfiKeyE10,
-  EfiKeyE11,
-  EfiKeyE12,
-  EfiKeyBackSpace,
-  EfiKeyIns,
-  EfiKeyHome,
-  EfiKeyPgUp,
-  EfiKeyNLck,
-  EfiKeySlash,
-  EfiKeyAsterisk,
-  EfiKeyMinus,
-  EfiKeyEsc,
-  EfiKeyF1,
-  EfiKeyF2,
-  EfiKeyF3,
-  EfiKeyF4,
-  EfiKeyF5,
-  EfiKeyF6,
-  EfiKeyF7,
-  EfiKeyF8,
-  EfiKeyF9,
-  EfiKeyF10,
-  EfiKeyF11,
-  EfiKeyF12,
-  EfiKeyPrint,
-  EfiKeySLck,
-  EfiKeyPause
-} EFI_KEY;
-
-typedef struct {
-  ///
-  /// Used to describe a physical key on a keyboard.
-  ///
-  EFI_KEY                 Key;
-  ///
-  /// Unicode character code for the Key.
-  ///
-  CHAR16                  Unicode;
-  ///
-  /// Unicode character code for the key with the shift key being held down.
-  ///
-  CHAR16                  ShiftedUnicode;
-  ///
-  /// Unicode character code for the key with the Alt-GR being held down.
-  ///
-  CHAR16                  AltGrUnicode;
-  ///
-  /// Unicode character code for the key with the Alt-GR and shift keys being held down.
-  ///
-  CHAR16                  ShiftedAltGrUnicode;
-  ///
-  /// Modifier keys are defined to allow for special functionality that is not necessarily
-  /// accomplished by a printable character. Many of these modifier keys are flags to toggle
-  /// certain state bits on and off inside of a keyboard driver.
-  ///
-  UINT16                  Modifier;
-  UINT16                  AffectedAttribute;
-} EFI_KEY_DESCRIPTOR;
-
-///
-/// A key which is affected by all the standard shift modifiers.
-/// Most keys would be expected to have this bit active.
-///
-#define EFI_AFFECTED_BY_STANDARD_SHIFT       0x0001
-
-///
-/// This key is affected by the caps lock so that if a keyboard driver
-/// would need to disambiguate between a key which had a "1" defined
-/// versus an "a" character.  Having this bit turned on would tell
-/// the keyboard driver to use the appropriate shifted state or not.
-///
-#define EFI_AFFECTED_BY_CAPS_LOCK            0x0002
-
-///
-/// Similar to the case of CAPS lock, if this bit is active, the key
-/// is affected by the num lock being turned on.
-///
-#define EFI_AFFECTED_BY_NUM_LOCK             0x0004
-
-typedef struct {
-  UINT16                  LayoutLength;
-  EFI_GUID                Guid;
-  UINT32                  LayoutDescriptorStringOffset;
-  UINT8                   DescriptorCount;
-  // EFI_KEY_DESCRIPTOR    Descriptors[];
-} EFI_HII_KEYBOARD_LAYOUT;
-
-typedef struct {
-  EFI_HII_PACKAGE_HEADER  Header;
-  UINT16                  LayoutCount;
-  // EFI_HII_KEYBOARD_LAYOUT Layout[];
-} EFI_HII_KEYBOARD_PACKAGE_HDR;
-
-//
-// Modifier values
-//
-#define EFI_NULL_MODIFIER                0x0000
-#define EFI_LEFT_CONTROL_MODIFIER        0x0001
-#define EFI_RIGHT_CONTROL_MODIFIER       0x0002
-#define EFI_LEFT_ALT_MODIFIER            0x0003
-#define EFI_RIGHT_ALT_MODIFIER           0x0004
-#define EFI_ALT_GR_MODIFIER              0x0005
-#define EFI_INSERT_MODIFIER              0x0006
-#define EFI_DELETE_MODIFIER              0x0007
-#define EFI_PAGE_DOWN_MODIFIER           0x0008
-#define EFI_PAGE_UP_MODIFIER             0x0009
-#define EFI_HOME_MODIFIER                0x000A
-#define EFI_END_MODIFIER                 0x000B
-#define EFI_LEFT_SHIFT_MODIFIER          0x000C
-#define EFI_RIGHT_SHIFT_MODIFIER         0x000D
-#define EFI_CAPS_LOCK_MODIFIER           0x000E
-#define EFI_NUM_LOCK_MODIFIER            0x000F
-#define EFI_LEFT_ARROW_MODIFIER          0x0010
-#define EFI_RIGHT_ARROW_MODIFIER         0x0011
-#define EFI_DOWN_ARROW_MODIFIER          0x0012
-#define EFI_UP_ARROW_MODIFIER            0x0013
-#define EFI_NS_KEY_MODIFIER              0x0014
-#define EFI_NS_KEY_DEPENDENCY_MODIFIER   0x0015
-#define EFI_FUNCTION_KEY_ONE_MODIFIER    0x0016
-#define EFI_FUNCTION_KEY_TWO_MODIFIER    0x0017
-#define EFI_FUNCTION_KEY_THREE_MODIFIER  0x0018
-#define EFI_FUNCTION_KEY_FOUR_MODIFIER   0x0019
-#define EFI_FUNCTION_KEY_FIVE_MODIFIER   0x001A
-#define EFI_FUNCTION_KEY_SIX_MODIFIER    0x001B
-#define EFI_FUNCTION_KEY_SEVEN_MODIFIER  0x001C
-#define EFI_FUNCTION_KEY_EIGHT_MODIFIER  0x001D
-#define EFI_FUNCTION_KEY_NINE_MODIFIER   0x001E
-#define EFI_FUNCTION_KEY_TEN_MODIFIER    0x001F
-#define EFI_FUNCTION_KEY_ELEVEN_MODIFIER 0x0020
-#define EFI_FUNCTION_KEY_TWELVE_MODIFIER 0x0021
-
-//
-// Keys that have multiple control functions based on modifier
-// settings are handled in the keyboard driver implementation.
-// For instance, PRINT_KEY might have a modifier held down and
-// is still a nonprinting character, but might have an alternate
-// control function like SYSREQUEST
-//
-#define EFI_PRINT_MODIFIER               0x0022
-#define EFI_SYS_REQUEST_MODIFIER         0x0023
-#define EFI_SCROLL_LOCK_MODIFIER         0x0024
-#define EFI_PAUSE_MODIFIER               0x0025
-#define EFI_BREAK_MODIFIER               0x0026
-
-#define EFI_LEFT_LOGO_MODIFIER           0x0027
-#define EFI_RIGHT_LOGO_MODIFIER          0x0028
-#define EFI_MENU_MODIFIER                0x0029
-
-///
-/// Animation IFR opcode
-///
-typedef struct _EFI_IFR_ANIMATION {
-  ///
-  /// Standard opcode header, where Header.OpCode is
-  /// EFI_IFR_ANIMATION_OP.
-  ///
-  EFI_IFR_OP_HEADER        Header;
-  ///
-  /// Animation identifier in the HII database.
-  ///
-  EFI_ANIMATION_ID         Id;
-} EFI_IFR_ANIMATION;
-
-///
-/// HII animation package header.
-///
-typedef struct _EFI_HII_ANIMATION_PACKAGE_HDR {
-  ///
-  /// Standard package header, where Header.Type = EFI_HII_PACKAGE_ANIMATIONS.
-  ///
-  EFI_HII_PACKAGE_HEADER  Header;
-  ///
-  /// Offset, relative to this header, of the animation information. If
-  /// this is zero, then there are no animation sequences in the package.
-  ///
-  UINT32                  AnimationInfoOffset;
-} EFI_HII_ANIMATION_PACKAGE_HDR;
-
-///
-/// Animation information is encoded as a series of blocks,
-/// with each block prefixed by a single byte header EFI_HII_ANIMATION_BLOCK.
-///
-typedef struct _EFI_HII_ANIMATION_BLOCK {
-  UINT8  BlockType;
-  //UINT8  BlockBody[];
-} EFI_HII_ANIMATION_BLOCK;
-
-///
-/// Animation block types.
-///
-#define EFI_HII_AIBT_END                 0x00
-#define EFI_HII_AIBT_OVERLAY_IMAGES      0x10
-#define EFI_HII_AIBT_CLEAR_IMAGES        0x11
-#define EFI_HII_AIBT_RESTORE_SCRN        0x12
-#define EFI_HII_AIBT_OVERLAY_IMAGES_LOOP 0x18
-#define EFI_HII_AIBT_CLEAR_IMAGES_LOOP   0x19
-#define EFI_HII_AIBT_RESTORE_SCRN_LOOP   0x1A
-#define EFI_HII_AIBT_DUPLICATE           0x20
-#define EFI_HII_AIBT_SKIP2               0x21
-#define EFI_HII_AIBT_SKIP1               0x22
-#define EFI_HII_AIBT_EXT1                0x30
-#define EFI_HII_AIBT_EXT2                0x31
-#define EFI_HII_AIBT_EXT4                0x32
-
-///
-/// Extended block headers used for variable sized animation records
-/// which need an explicit length.
-///
-
-typedef struct _EFI_HII_AIBT_EXT1_BLOCK  {
-  ///
-  /// Standard animation header, where Header.BlockType = EFI_HII_AIBT_EXT1.
-  ///
-  EFI_HII_ANIMATION_BLOCK  Header;
-  ///
-  /// The block type.
-  ///
-  UINT8                    BlockType2;
-  ///
-  /// Size of the animation block, in bytes, including the animation block header.
-  ///
-  UINT8                    Length;
-} EFI_HII_AIBT_EXT1_BLOCK;
-
-typedef struct _EFI_HII_AIBT_EXT2_BLOCK {
-  ///
-  /// Standard animation header, where Header.BlockType = EFI_HII_AIBT_EXT2.
-  ///
-  EFI_HII_ANIMATION_BLOCK  Header;
-  ///
-  /// The block type
-  ///
-  UINT8                    BlockType2;
-  ///
-  /// Size of the animation block, in bytes, including the animation block header.
-  ///
-  UINT16                   Length;
-} EFI_HII_AIBT_EXT2_BLOCK;
-
-typedef struct _EFI_HII_AIBT_EXT4_BLOCK {
-  ///
-  /// Standard animation header, where Header.BlockType = EFI_HII_AIBT_EXT4.
-  ///
-  EFI_HII_ANIMATION_BLOCK  Header;
-  ///
-  /// The block type
-  ///
-  UINT8                    BlockType2;
-  ///
-  /// Size of the animation block, in bytes, including the animation block header.
-  ///
-  UINT32                   Length;
-} EFI_HII_AIBT_EXT4_BLOCK;
-
-typedef struct _EFI_HII_ANIMATION_CELL {
-  ///
-  /// The X offset from the upper left hand corner of the logical
-  /// window to position the indexed image.
-  ///
-  UINT16                    OffsetX;
-  ///
-  /// The Y offset from the upper left hand corner of the logical
-  /// window to position the indexed image.
-  ///
-  UINT16                    OffsetY;
-  ///
-  /// The image to display at the specified offset from the upper left
-  /// hand corner of the logical window.
-  ///
-  EFI_IMAGE_ID              ImageId;
-  ///
-  /// The number of milliseconds to delay after displaying the indexed
-  /// image and before continuing on to the next linked image.  If value
-  /// is zero, no delay.
-  ///
-  UINT16                    Delay;
-} EFI_HII_ANIMATION_CELL;
-
-///
-/// An animation block to describe an animation sequence that does not cycle, and
-/// where one image is simply displayed over the previous image.
-///
-typedef struct _EFI_HII_AIBT_OVERLAY_IMAGES_BLOCK {
-  ///
-  /// This is image that is to be reference by the image protocols, if the
-  /// animation function is not supported or disabled. This image can
-  /// be one particular image from the animation sequence (if any one
-  /// of the animation frames has a complete image) or an alternate
-  /// image that can be displayed alone. If the value is zero, no image
-  /// is displayed.
-  ///
-  EFI_IMAGE_ID            DftImageId;
-  ///
-  /// The overall width of the set of images (logical window width).
-  ///
-  UINT16                  Width;
-  ///
-  /// The overall height of the set of images (logical window height).
-  ///
-  UINT16                  Height;
-  ///
-  /// The number of EFI_HII_ANIMATION_CELL contained in the
-  /// animation sequence.
-  ///
-  UINT16                  CellCount;
-  ///
-  /// An array of CellCount animation cells.
-  ///
-  EFI_HII_ANIMATION_CELL  AnimationCell[1];
-} EFI_HII_AIBT_OVERLAY_IMAGES_BLOCK;
-
-///
-/// An animation block to describe an animation sequence that does not cycle,
-/// and where the logical window is cleared to the specified color before
-/// the next image is displayed.
-///
-typedef struct _EFI_HII_AIBT_CLEAR_IMAGES_BLOCK {
-  ///
-  /// This is image that is to be reference by the image protocols, if the
-  /// animation function is not supported or disabled. This image can
-  /// be one particular image from the animation sequence (if any one
-  /// of the animation frames has a complete image) or an alternate
-  /// image that can be displayed alone. If the value is zero, no image
-  /// is displayed.
-  ///
-  EFI_IMAGE_ID       DftImageId;
-  ///
-  /// The overall width of the set of images (logical window width).
-  ///
-  UINT16             Width;
-  ///
-  /// The overall height of the set of images (logical window height).
-  ///
-  UINT16             Height;
-  ///
-  /// The number of EFI_HII_ANIMATION_CELL contained in the
-  /// animation sequence.
-  ///
-  UINT16             CellCount;
-  ///
-  /// The color to clear the logical window to before displaying the
-  /// indexed image.
-  ///
-  EFI_HII_RGB_PIXEL  BackgndColor;
-  ///
-  /// An array of CellCount animation cells.
-  ///
-  EFI_HII_ANIMATION_CELL AnimationCell[1];
-} EFI_HII_AIBT_CLEAR_IMAGES_BLOCK;
-
-///
-/// An animation block to describe an animation sequence that does not cycle,
-/// and where the screen is restored to the original state before the next
-/// image is displayed.
-///
-typedef struct _EFI_HII_AIBT_RESTORE_SCRN_BLOCK {
-  ///
-  /// This is image that is to be reference by the image protocols, if the
-  /// animation function is not supported or disabled. This image can
-  /// be one particular image from the animation sequence (if any one
-  /// of the animation frames has a complete image) or an alternate
-  /// image that can be displayed alone. If the value is zero, no image
-  /// is displayed.
-  ///
-  EFI_IMAGE_ID            DftImageId;
-  ///
-  /// The overall width of the set of images (logical window width).
-  ///
-  UINT16                  Width;
-  ///
-  /// The overall height of the set of images (logical window height).
-  ///
-  UINT16                  Height;
-  ///
-  /// The number of EFI_HII_ANIMATION_CELL contained in the
-  /// animation sequence.
-  ///
-  UINT16                  CellCount;
-  ///
-  /// An array of CellCount animation cells.
-  ///
-  EFI_HII_ANIMATION_CELL  AnimationCell[1];
-} EFI_HII_AIBT_RESTORE_SCRN_BLOCK;
-
-///
-/// An animation block to describe an animation sequence that continuously cycles,
-/// and where one image is simply displayed over the previous image.
-///
-typedef EFI_HII_AIBT_OVERLAY_IMAGES_BLOCK  EFI_HII_AIBT_OVERLAY_IMAGES_LOOP_BLOCK;
-
-///
-/// An animation block to describe an animation sequence that continuously cycles,
-/// and where the logical window is cleared to the specified color before
-/// the next image is displayed.
-///
-typedef EFI_HII_AIBT_CLEAR_IMAGES_BLOCK    EFI_HII_AIBT_CLEAR_IMAGES_LOOP_BLOCK;
-
-///
-/// An animation block to describe an animation sequence that continuously cycles,
-/// and where the screen is restored to the original state before
-/// the next image is displayed.
-///
-typedef EFI_HII_AIBT_RESTORE_SCRN_BLOCK    EFI_HII_AIBT_RESTORE_SCRN_LOOP_BLOCK;
-
-///
-/// Assigns a new character value to a previously defined animation sequence.
-///
-typedef struct _EFI_HII_AIBT_DUPLICATE_BLOCK {
-  ///
-  /// The previously defined animation ID with the exact same
-  /// animation information.
-  ///
-  EFI_ANIMATION_ID  AnimationId;
-} EFI_HII_AIBT_DUPLICATE_BLOCK;
-
-///
-/// Skips animation IDs.
-///
-typedef struct _EFI_HII_AIBT_SKIP1_BLOCK {
-  ///
-  /// The unsigned 8-bit value to add to AnimationIdCurrent.
-  ///
-  UINT8  SkipCount;
-} EFI_HII_AIBT_SKIP1_BLOCK;
-
-///
-/// Skips animation IDs.
-///
-typedef struct _EFI_HII_AIBT_SKIP2_BLOCK {
-  ///
-  /// The unsigned 16-bit value to add to AnimationIdCurrent.
-  ///
-  UINT16  SkipCount;
-} EFI_HII_AIBT_SKIP2_BLOCK;
-
-#pragma pack()
-
-
-
-///
-/// References to string tokens must use this macro to enable scanning for
-/// token usages.
-///
-///
-/// STRING_TOKEN is not defined in UEFI specification. But it is placed
-/// here for the easy access by C files and VFR source files.
-///
-#define STRING_TOKEN(t) t
-
-#endif
diff --git a/src/efi/Uefi/UefiMultiPhase.h b/src/efi/Uefi/UefiMultiPhase.h
deleted file mode 100644
index 33c383e..0000000
--- a/src/efi/Uefi/UefiMultiPhase.h
+++ /dev/null
@@ -1,193 +0,0 @@
-/** @file
-  This includes some definitions introduced in UEFI that will be used in both PEI and DXE phases.
-
-Copyright (c) 2006 - 2011, Intel Corporation. All rights reserved.<BR>
-This program and the accompanying materials are licensed and made available under
-the terms and conditions of the BSD License that accompanies this distribution.
-The full text of the license may be found at
-http://opensource.org/licenses/bsd-license.php.
-
-THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
-WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
-
-**/
-
-#ifndef __UEFI_MULTIPHASE_H__
-#define __UEFI_MULTIPHASE_H__
-
-#include "efi/Guid/WinCertificate.h"
-///
-/// Enumeration of memory types introduced in UEFI.
-///
-typedef enum {
-  ///
-  /// Not used.
-  ///
-  EfiReservedMemoryType,
-  ///
-  /// The code portions of a loaded application.
-  /// (Note that UEFI OS loaders are UEFI applications.)
-  ///
-  EfiLoaderCode,
-  ///
-  /// The data portions of a loaded application and the default data allocation
-  /// type used by an application to allocate pool memory.
-  ///
-  EfiLoaderData,
-  ///
-  /// The code portions of a loaded Boot Services Driver.
-  ///
-  EfiBootServicesCode,
-  ///
-  /// The data portions of a loaded Boot Serves Driver, and the default data
-  /// allocation type used by a Boot Services Driver to allocate pool memory.
-  ///
-  EfiBootServicesData,
-  ///
-  /// The code portions of a loaded Runtime Services Driver.
-  ///
-  EfiRuntimeServicesCode,
-  ///
-  /// The data portions of a loaded Runtime Services Driver and the default
-  /// data allocation type used by a Runtime Services Driver to allocate pool memory.
-  ///
-  EfiRuntimeServicesData,
-  ///
-  /// Free (unallocated) memory.
-  ///
-  EfiConventionalMemory,
-  ///
-  /// Memory in which errors have been detected.
-  ///
-  EfiUnusableMemory,
-  ///
-  /// Memory that holds the ACPI tables.
-  ///
-  EfiACPIReclaimMemory,
-  ///
-  /// Address space reserved for use by the firmware.
-  ///
-  EfiACPIMemoryNVS,
-  ///
-  /// Used by system firmware to request that a memory-mapped IO region
-  /// be mapped by the OS to a virtual address so it can be accessed by EFI runtime services.
-  ///
-  EfiMemoryMappedIO,
-  ///
-  /// System memory-mapped IO region that is used to translate memory
-  /// cycles to IO cycles by the processor.
-  ///
-  EfiMemoryMappedIOPortSpace,
-  ///
-  /// Address space reserved by the firmware for code that is part of the processor.
-  ///
-  EfiPalCode,
-  EfiMaxMemoryType
-} EFI_MEMORY_TYPE;
-
-///
-/// Data structure that precedes all of the standard EFI table types.
-///
-typedef struct {
-  ///
-  /// A 64-bit signature that identifies the type of table that follows.
-  /// Unique signatures have been generated for the EFI System Table,
-  /// the EFI Boot Services Table, and the EFI Runtime Services Table.
-  ///
-  UINT64  Signature;
-  ///
-  /// The revision of the EFI Specification to which this table
-  /// conforms. The upper 16 bits of this field contain the major
-  /// revision value, and the lower 16 bits contain the minor revision
-  /// value. The minor revision values are limited to the range of 00..99.
-  ///
-  UINT32  Revision;
-  ///
-  /// The size, in bytes, of the entire table including the EFI_TABLE_HEADER.
-  ///
-  UINT32  HeaderSize;
-  ///
-  /// The 32-bit CRC for the entire table. This value is computed by
-  /// setting this field to 0, and computing the 32-bit CRC for HeaderSize bytes.
-  ///
-  UINT32  CRC32;
-  ///
-  /// Reserved field that must be set to 0.
-  ///
-  UINT32  Reserved;
-} EFI_TABLE_HEADER;
-
-///
-/// Attributes of variable.
-///
-#define EFI_VARIABLE_NON_VOLATILE                            0x00000001
-#define EFI_VARIABLE_BOOTSERVICE_ACCESS                      0x00000002
-#define EFI_VARIABLE_RUNTIME_ACCESS                          0x00000004
-///
-/// This attribute is identified by the mnemonic 'HR'
-/// elsewhere in this specification.
-///
-#define EFI_VARIABLE_HARDWARE_ERROR_RECORD                   0x00000008
-///
-/// Attributes of Authenticated Variable
-///
-#define EFI_VARIABLE_AUTHENTICATED_WRITE_ACCESS              0x00000010
-#define EFI_VARIABLE_TIME_BASED_AUTHENTICATED_WRITE_ACCESS   0x00000020
-#define EFI_VARIABLE_APPEND_WRITE                            0x00000040
-
-
-///
-/// AuthInfo is a WIN_CERTIFICATE using the wCertificateType
-/// WIN_CERTIFICATE_UEFI_GUID and the CertType
-/// EFI_CERT_TYPE_RSA2048_SHA256_GUID. If the attribute specifies
-/// authenticated access, then the Data buffer should begin with an
-/// authentication descriptor prior to the data payload and DataSize
-/// should reflect the the data.and descriptor size. The caller
-/// shall digest the Monotonic Count value and the associated data
-/// for the variable update using the SHA-256 1-way hash algorithm.
-/// The ensuing the 32-byte digest will be signed using the private
-/// key associated w/ the public/private 2048-bit RSA key-pair. The
-/// WIN_CERTIFICATE shall be used to describe the signature of the
-/// Variable data *Data. In addition, the signature will also
-/// include the MonotonicCount value to guard against replay attacks.
-///
-typedef struct {
-  ///
-  /// Included in the signature of
-  /// AuthInfo.Used to ensure freshness/no
-  /// replay. Incremented during each
-  /// "Write" access.
-  ///
-  UINT64                      MonotonicCount;
-  ///
-  /// Provides the authorization for the variable
-  /// access. It is a signature across the
-  /// variable data and the  Monotonic Count
-  /// value. Caller uses Private key that is
-  /// associated with a public key that has been
-  /// provisioned via the key exchange.
-  ///
-  WIN_CERTIFICATE_UEFI_GUID   AuthInfo;
-} EFI_VARIABLE_AUTHENTICATION;
-
-///
-/// When the attribute EFI_VARIABLE_TIME_BASED_AUTHENTICATED_WRITE_ACCESS is
-/// set, then the Data buffer shall begin with an instance of a complete (and serialized)
-/// EFI_VARIABLE_AUTHENTICATION_2 descriptor. The descriptor shall be followed by the new
-/// variable value and DataSize shall reflect the combined size of the descriptor and the new
-/// variable value. The authentication descriptor is not part of the variable data and is not
-/// returned by subsequent calls to GetVariable().
-///
-typedef struct {
-  ///
-  /// For the TimeStamp value, components Pad1, Nanosecond, TimeZone, Daylight and
-  /// Pad2 shall be set to 0. This means that the time shall always be expressed in GMT.
-  ///
-  EFI_TIME                    TimeStamp;
-  ///
-  /// Only a CertType of  EFI_CERT_TYPE_PKCS7_GUID is accepted.
-  ///
-  WIN_CERTIFICATE_UEFI_GUID   AuthInfo;
- } EFI_VARIABLE_AUTHENTICATION_2;
-
-#endif
diff --git a/src/efi/Uefi/UefiPxe.h b/src/efi/Uefi/UefiPxe.h
deleted file mode 100644
index 15faf10..0000000
--- a/src/efi/Uefi/UefiPxe.h
+++ /dev/null
@@ -1,1772 +0,0 @@
-/** @file
-  This header file contains all of the PXE type definitions,
-  structure prototypes, global variables and constants that
-  are needed for porting PXE to EFI.
-
-Copyright (c) 2006 - 2013, Intel Corporation. All rights reserved.<BR>
-This program and the accompanying materials are licensed and made available under
-the terms and conditions of the BSD License that accompanies this distribution.
-The full text of the license may be found at
-http://opensource.org/licenses/bsd-license.php.
-
-THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
-WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
-
-  @par Revision Reference:
-  32/64-bit PXE specification:
-  alpha-4, 99-Dec-17.
-
-**/
-
-#ifndef __EFI_PXE_H__
-#define __EFI_PXE_H__
-
-#pragma pack(1)
-
-#define PXE_BUSTYPE(a, b, c, d) \
-    ( \
-      (((PXE_UINT32) (d) & 0xFF) << 24) | (((PXE_UINT32) (c) & 0xFF) << 16) | (((PXE_UINT32) (b) & 0xFF) << 8) | \
-        ((PXE_UINT32) (a) & 0xFF) \
-    )
-
-///
-/// UNDI ROM ID and devive ID signature.
-///
-#define PXE_BUSTYPE_PXE PXE_BUSTYPE ('!', 'P', 'X', 'E')
-
-///
-/// BUS ROM ID signatures.
-///
-#define PXE_BUSTYPE_PCI     PXE_BUSTYPE ('P', 'C', 'I', 'R')
-#define PXE_BUSTYPE_PC_CARD PXE_BUSTYPE ('P', 'C', 'C', 'R')
-#define PXE_BUSTYPE_USB     PXE_BUSTYPE ('U', 'S', 'B', 'R')
-#define PXE_BUSTYPE_1394    PXE_BUSTYPE ('1', '3', '9', '4')
-
-#define PXE_SWAP_UINT16(n)  ((((PXE_UINT16) (n) & 0x00FF) << 8) | (((PXE_UINT16) (n) & 0xFF00) >> 8))
-
-#define PXE_SWAP_UINT32(n) \
-  ((((PXE_UINT32)(n) & 0x000000FF) << 24) | \
-   (((PXE_UINT32)(n) & 0x0000FF00) << 8)  | \
-   (((PXE_UINT32)(n) & 0x00FF0000) >> 8)  | \
-   (((PXE_UINT32)(n) & 0xFF000000) >> 24))
-
-#define PXE_SWAP_UINT64(n) \
-  ((((PXE_UINT64)(n) & 0x00000000000000FFULL) << 56) | \
-   (((PXE_UINT64)(n) & 0x000000000000FF00ULL) << 40) | \
-   (((PXE_UINT64)(n) & 0x0000000000FF0000ULL) << 24) | \
-   (((PXE_UINT64)(n) & 0x00000000FF000000ULL) << 8)  | \
-   (((PXE_UINT64)(n) & 0x000000FF00000000ULL) >> 8)  | \
-   (((PXE_UINT64)(n) & 0x0000FF0000000000ULL) >> 24) | \
-   (((PXE_UINT64)(n) & 0x00FF000000000000ULL) >> 40) | \
-   (((PXE_UINT64)(n) & 0xFF00000000000000ULL) >> 56))
-
-
-#define PXE_CPBSIZE_NOT_USED  0               ///< zero
-#define PXE_DBSIZE_NOT_USED   0               ///< zero
-#define PXE_CPBADDR_NOT_USED  (PXE_UINT64) 0  ///< zero
-#define PXE_DBADDR_NOT_USED   (PXE_UINT64) 0  ///< zero
-#define PXE_CONST             CONST
-
-#define PXE_VOLATILE          volatile
-
-typedef VOID           PXE_VOID;
-typedef UINT8          PXE_UINT8;
-typedef UINT16         PXE_UINT16;
-typedef UINT32         PXE_UINT32;
-typedef UINTN          PXE_UINTN;
-
-///
-/// Typedef unsigned long PXE_UINT64.
-///
-typedef UINT64      PXE_UINT64;
-
-typedef PXE_UINT8 PXE_BOOL;
-#define PXE_FALSE 0            ///< zero
-#define PXE_TRUE  (!PXE_FALSE)
-
-typedef PXE_UINT16      PXE_OPCODE;
-
-///
-/// Return UNDI operational state.
-///
-#define PXE_OPCODE_GET_STATE  0x0000
-
-///
-/// Change UNDI operational state from Stopped to Started.
-///
-#define PXE_OPCODE_START  0x0001
-
-///
-/// Change UNDI operational state from Started to Stopped.
-///
-#define PXE_OPCODE_STOP 0x0002
-
-///
-/// Get UNDI initialization information.
-///
-#define PXE_OPCODE_GET_INIT_INFO  0x0003
-
-///
-/// Get NIC configuration information.
-///
-#define PXE_OPCODE_GET_CONFIG_INFO  0x0004
-
-///
-/// Changed UNDI operational state from Started to Initialized.
-///
-#define PXE_OPCODE_INITIALIZE 0x0005
-
-///
-/// Re-initialize the NIC H/W.
-///
-#define PXE_OPCODE_RESET  0x0006
-
-///
-/// Change the UNDI operational state from Initialized to Started.
-///
-#define PXE_OPCODE_SHUTDOWN 0x0007
-
-///
-/// Read & change state of external interrupt enables.
-///
-#define PXE_OPCODE_INTERRUPT_ENABLES  0x0008
-
-///
-/// Read & change state of packet receive filters.
-///
-#define PXE_OPCODE_RECEIVE_FILTERS  0x0009
-
-///
-/// Read & change station MAC address.
-///
-#define PXE_OPCODE_STATION_ADDRESS  0x000A
-
-///
-/// Read traffic statistics.
-///
-#define PXE_OPCODE_STATISTICS 0x000B
-
-///
-/// Convert multicast IP address to multicast MAC address.
-///
-#define PXE_OPCODE_MCAST_IP_TO_MAC  0x000C
-
-///
-/// Read or change non-volatile storage on the NIC.
-///
-#define PXE_OPCODE_NVDATA 0x000D
-
-///
-/// Get & clear interrupt status.
-///
-#define PXE_OPCODE_GET_STATUS 0x000E
-
-///
-/// Fill media header in packet for transmit.
-///
-#define PXE_OPCODE_FILL_HEADER  0x000F
-
-///
-/// Transmit packet(s).
-///
-#define PXE_OPCODE_TRANSMIT 0x0010
-
-///
-/// Receive packet.
-///
-#define PXE_OPCODE_RECEIVE  0x0011
-
-///
-/// Last valid PXE UNDI OpCode number.
-///
-#define PXE_OPCODE_LAST_VALID 0x0011
-
-typedef PXE_UINT16  PXE_OPFLAGS;
-
-#define PXE_OPFLAGS_NOT_USED  0x0000
-
-//
-// //////////////////////////////////////
-// UNDI Get State
-//
-// No OpFlags
-
-////////////////////////////////////////
-// UNDI Start
-//
-// No OpFlags
-
-////////////////////////////////////////
-// UNDI Stop
-//
-// No OpFlags
-
-////////////////////////////////////////
-// UNDI Get Init Info
-//
-// No Opflags
-
-////////////////////////////////////////
-// UNDI Get Config Info
-//
-// No Opflags
-
-///
-/// UNDI Initialize
-///
-#define PXE_OPFLAGS_INITIALIZE_CABLE_DETECT_MASK    0x0001
-#define PXE_OPFLAGS_INITIALIZE_DETECT_CABLE         0x0000
-#define PXE_OPFLAGS_INITIALIZE_DO_NOT_DETECT_CABLE  0x0001
-
-///
-///
-/// UNDI Reset
-///
-#define PXE_OPFLAGS_RESET_DISABLE_INTERRUPTS  0x0001
-#define PXE_OPFLAGS_RESET_DISABLE_FILTERS     0x0002
-
-///
-/// UNDI Shutdown.
-///
-/// No OpFlags.
-
-///
-/// UNDI Interrupt Enables.
-///
-///
-/// Select whether to enable or disable external interrupt signals.
-/// Setting both enable and disable will return PXE_STATCODE_INVALID_OPFLAGS.
-///
-#define PXE_OPFLAGS_INTERRUPT_OPMASK  0xC000
-#define PXE_OPFLAGS_INTERRUPT_ENABLE  0x8000
-#define PXE_OPFLAGS_INTERRUPT_DISABLE 0x4000
-#define PXE_OPFLAGS_INTERRUPT_READ    0x0000
-
-///
-/// Enable receive interrupts.  An external interrupt will be generated
-/// after a complete non-error packet has been received.
-///
-#define PXE_OPFLAGS_INTERRUPT_RECEIVE 0x0001
-
-///
-/// Enable transmit interrupts.  An external interrupt will be generated
-/// after a complete non-error packet has been transmitted.
-///
-#define PXE_OPFLAGS_INTERRUPT_TRANSMIT  0x0002
-
-///
-/// Enable command interrupts.  An external interrupt will be generated
-/// when command execution stops.
-///
-#define PXE_OPFLAGS_INTERRUPT_COMMAND 0x0004
-
-///
-/// Generate software interrupt.  Setting this bit generates an external
-/// interrupt, if it is supported by the hardware.
-///
-#define PXE_OPFLAGS_INTERRUPT_SOFTWARE  0x0008
-
-///
-/// UNDI Receive Filters.
-///
-///
-/// Select whether to enable or disable receive filters.
-/// Setting both enable and disable will return PXE_STATCODE_INVALID_OPCODE.
-///
-#define PXE_OPFLAGS_RECEIVE_FILTER_OPMASK   0xC000
-#define PXE_OPFLAGS_RECEIVE_FILTER_ENABLE   0x8000
-#define PXE_OPFLAGS_RECEIVE_FILTER_DISABLE  0x4000
-#define PXE_OPFLAGS_RECEIVE_FILTER_READ     0x0000
-
-///
-/// To reset the contents of the multicast MAC address filter list,
-/// set this OpFlag:
-///
-#define PXE_OPFLAGS_RECEIVE_FILTER_RESET_MCAST_LIST 0x2000
-
-///
-/// Enable unicast packet receiving.  Packets sent to the current station
-/// MAC address will be received.
-///
-#define PXE_OPFLAGS_RECEIVE_FILTER_UNICAST  0x0001
-
-///
-/// Enable broadcast packet receiving.  Packets sent to the broadcast
-/// MAC address will be received.
-///
-#define PXE_OPFLAGS_RECEIVE_FILTER_BROADCAST  0x0002
-
-///
-/// Enable filtered multicast packet receiving.  Packets sent to any
-/// of the multicast MAC addresses in the multicast MAC address filter
-/// list will be received.  If the filter list is empty, no multicast
-///
-#define PXE_OPFLAGS_RECEIVE_FILTER_FILTERED_MULTICAST 0x0004
-
-///
-/// Enable promiscuous packet receiving.  All packets will be received.
-///
-#define PXE_OPFLAGS_RECEIVE_FILTER_PROMISCUOUS  0x0008
-
-///
-/// Enable promiscuous multicast packet receiving.  All multicast
-/// packets will be received.
-///
-#define PXE_OPFLAGS_RECEIVE_FILTER_ALL_MULTICAST  0x0010
-
-///
-/// UNDI Station Address.
-///
-#define PXE_OPFLAGS_STATION_ADDRESS_READ   0x0000
-#define PXE_OPFLAGS_STATION_ADDRESS_WRITE  0x0000
-#define PXE_OPFLAGS_STATION_ADDRESS_RESET  0x0001
-
-///
-/// UNDI Statistics.
-///
-#define PXE_OPFLAGS_STATISTICS_READ   0x0000
-#define PXE_OPFLAGS_STATISTICS_RESET  0x0001
-
-///
-/// UNDI MCast IP to MAC.
-///
-///
-/// Identify the type of IP address in the CPB.
-///
-#define PXE_OPFLAGS_MCAST_IP_TO_MAC_OPMASK  0x0003
-#define PXE_OPFLAGS_MCAST_IPV4_TO_MAC       0x0000
-#define PXE_OPFLAGS_MCAST_IPV6_TO_MAC       0x0001
-
-///
-/// UNDI NvData.
-///
-///
-/// Select the type of non-volatile data operation.
-///
-#define PXE_OPFLAGS_NVDATA_OPMASK 0x0001
-#define PXE_OPFLAGS_NVDATA_READ   0x0000
-#define PXE_OPFLAGS_NVDATA_WRITE  0x0001
-
-///
-/// UNDI Get Status.
-///
-///
-/// Return current interrupt status.  This will also clear any interrupts
-/// that are currently set.  This can be used in a polling routine.  The
-/// interrupt flags are still set and cleared even when the interrupts
-/// are disabled.
-///
-#define PXE_OPFLAGS_GET_INTERRUPT_STATUS  0x0001
-
-///
-/// Return list of transmitted buffers for recycling.  Transmit buffers
-/// must not be changed or unallocated until they have recycled.  After
-/// issuing a transmit command, wait for a transmit complete interrupt.
-/// When a transmit complete interrupt is received, read the transmitted
-/// buffers.  Do not plan on getting one buffer per interrupt.  Some
-/// NICs and UNDIs may transmit multiple buffers per interrupt.
-///
-#define PXE_OPFLAGS_GET_TRANSMITTED_BUFFERS 0x0002
-
-///
-/// Return current media status.
-///
-#define PXE_OPFLAGS_GET_MEDIA_STATUS    0x0004
-
-///
-/// UNDI Fill Header.
-///
-#define PXE_OPFLAGS_FILL_HEADER_OPMASK      0x0001
-#define PXE_OPFLAGS_FILL_HEADER_FRAGMENTED  0x0001
-#define PXE_OPFLAGS_FILL_HEADER_WHOLE       0x0000
-
-///
-/// UNDI Transmit.
-///
-///
-/// S/W UNDI only.  Return after the packet has been transmitted.  A
-/// transmit complete interrupt will still be generated and the transmit
-/// buffer will have to be recycled.
-///
-#define PXE_OPFLAGS_SWUNDI_TRANSMIT_OPMASK  0x0001
-#define PXE_OPFLAGS_TRANSMIT_BLOCK          0x0001
-#define PXE_OPFLAGS_TRANSMIT_DONT_BLOCK     0x0000
-
-#define PXE_OPFLAGS_TRANSMIT_OPMASK     0x0002
-#define PXE_OPFLAGS_TRANSMIT_FRAGMENTED 0x0002
-#define PXE_OPFLAGS_TRANSMIT_WHOLE      0x0000
-
-///
-/// UNDI Receive.
-///
-/// No OpFlags.
-///
-
-///
-/// PXE STATFLAGS.
-///
-typedef PXE_UINT16  PXE_STATFLAGS;
-
-#define PXE_STATFLAGS_INITIALIZE  0x0000
-
-///
-/// Common StatFlags that can be returned by all commands.
-///
-///
-/// The COMMAND_COMPLETE and COMMAND_FAILED status flags must be
-/// implemented by all UNDIs.  COMMAND_QUEUED is only needed by UNDIs
-/// that support command queuing.
-///
-#define PXE_STATFLAGS_STATUS_MASK       0xC000
-#define PXE_STATFLAGS_COMMAND_COMPLETE  0xC000
-#define PXE_STATFLAGS_COMMAND_FAILED    0x8000
-#define PXE_STATFLAGS_COMMAND_QUEUED    0x4000
-
-///
-/// UNDI Get State.
-///
-#define PXE_STATFLAGS_GET_STATE_MASK        0x0003
-#define PXE_STATFLAGS_GET_STATE_INITIALIZED 0x0002
-#define PXE_STATFLAGS_GET_STATE_STARTED     0x0001
-#define PXE_STATFLAGS_GET_STATE_STOPPED     0x0000
-
-///
-/// UNDI Start.
-///
-/// No additional StatFlags.
-///
-
-///
-/// UNDI Get Init Info.
-///
-#define PXE_STATFLAGS_CABLE_DETECT_MASK           0x0001
-#define PXE_STATFLAGS_CABLE_DETECT_NOT_SUPPORTED  0x0000
-#define PXE_STATFLAGS_CABLE_DETECT_SUPPORTED      0x0001
-
-#define PXE_STATFLAGS_GET_STATUS_NO_MEDIA_MASK           0x0002
-#define PXE_STATFLAGS_GET_STATUS_NO_MEDIA_NOT_SUPPORTED  0x0000
-#define PXE_STATFLAGS_GET_STATUS_NO_MEDIA_SUPPORTED      0x0002
-
-///
-/// UNDI Initialize.
-///
-#define PXE_STATFLAGS_INITIALIZED_NO_MEDIA  0x0001
-
-///
-/// UNDI Reset.
-///
-#define PXE_STATFLAGS_RESET_NO_MEDIA  0x0001
-
-///
-/// UNDI Shutdown.
-///
-/// No additional StatFlags.
-
-///
-/// UNDI Interrupt Enables.
-///
-///
-/// If set, receive interrupts are enabled.
-///
-#define PXE_STATFLAGS_INTERRUPT_RECEIVE 0x0001
-
-///
-/// If set, transmit interrupts are enabled.
-///
-#define PXE_STATFLAGS_INTERRUPT_TRANSMIT  0x0002
-
-///
-/// If set, command interrupts are enabled.
-///
-#define PXE_STATFLAGS_INTERRUPT_COMMAND 0x0004
-
-///
-/// UNDI Receive Filters.
-///
-
-///
-/// If set, unicast packets will be received.
-///
-#define PXE_STATFLAGS_RECEIVE_FILTER_UNICAST  0x0001
-
-///
-/// If set, broadcast packets will be received.
-///
-#define PXE_STATFLAGS_RECEIVE_FILTER_BROADCAST  0x0002
-
-///
-/// If set, multicast packets that match up with the multicast address
-/// filter list will be received.
-///
-#define PXE_STATFLAGS_RECEIVE_FILTER_FILTERED_MULTICAST 0x0004
-
-///
-/// If set, all packets will be received.
-///
-#define PXE_STATFLAGS_RECEIVE_FILTER_PROMISCUOUS  0x0008
-
-///
-/// If set, all multicast packets will be received.
-///
-#define PXE_STATFLAGS_RECEIVE_FILTER_ALL_MULTICAST  0x0010
-
-///
-/// UNDI Station Address.
-///
-/// No additional StatFlags.
-///
-
-///
-/// UNDI Statistics.
-///
-/// No additional StatFlags.
-///
-
-///
-//// UNDI MCast IP to MAC.
-////
-//// No additional StatFlags.
-
-///
-/// UNDI NvData.
-///
-/// No additional StatFlags.
-///
-
-///
-/// UNDI Get Status.
-///
-
-///
-/// Use to determine if an interrupt has occurred.
-///
-#define PXE_STATFLAGS_GET_STATUS_INTERRUPT_MASK 0x000F
-#define PXE_STATFLAGS_GET_STATUS_NO_INTERRUPTS  0x0000
-
-///
-/// If set, at least one receive interrupt occurred.
-///
-#define PXE_STATFLAGS_GET_STATUS_RECEIVE  0x0001
-
-///
-/// If set, at least one transmit interrupt occurred.
-///
-#define PXE_STATFLAGS_GET_STATUS_TRANSMIT 0x0002
-
-///
-/// If set, at least one command interrupt occurred.
-///
-#define PXE_STATFLAGS_GET_STATUS_COMMAND  0x0004
-
-///
-/// If set, at least one software interrupt occurred.
-///
-#define PXE_STATFLAGS_GET_STATUS_SOFTWARE 0x0008
-
-///
-/// This flag is set if the transmitted buffer queue is empty.  This flag
-/// will be set if all transmitted buffer addresses get written into the DB.
-///
-#define PXE_STATFLAGS_GET_STATUS_TXBUF_QUEUE_EMPTY  0x0010
-
-///
-/// This flag is set if no transmitted buffer addresses were written
-/// into the DB.  (This could be because DBsize was too small.)
-///
-#define PXE_STATFLAGS_GET_STATUS_NO_TXBUFS_WRITTEN  0x0020
-
-///
-/// This flag is set if there is no media detected.
-///
-#define PXE_STATFLAGS_GET_STATUS_NO_MEDIA  0x0040
-
-///
-/// UNDI Fill Header.
-///
-/// No additional StatFlags.
-///
-
-///
-/// UNDI Transmit.
-///
-/// No additional StatFlags.
-
-///
-/// UNDI Receive
-///.
-
-///
-/// No additional StatFlags.
-///
-typedef PXE_UINT16  PXE_STATCODE;
-
-#define PXE_STATCODE_INITIALIZE 0x0000
-
-///
-/// Common StatCodes returned by all UNDI commands, UNDI protocol functions
-/// and BC protocol functions.
-///
-#define PXE_STATCODE_SUCCESS              0x0000
-
-#define PXE_STATCODE_INVALID_CDB          0x0001
-#define PXE_STATCODE_INVALID_CPB          0x0002
-#define PXE_STATCODE_BUSY                 0x0003
-#define PXE_STATCODE_QUEUE_FULL           0x0004
-#define PXE_STATCODE_ALREADY_STARTED      0x0005
-#define PXE_STATCODE_NOT_STARTED          0x0006
-#define PXE_STATCODE_NOT_SHUTDOWN         0x0007
-#define PXE_STATCODE_ALREADY_INITIALIZED  0x0008
-#define PXE_STATCODE_NOT_INITIALIZED      0x0009
-#define PXE_STATCODE_DEVICE_FAILURE       0x000A
-#define PXE_STATCODE_NVDATA_FAILURE       0x000B
-#define PXE_STATCODE_UNSUPPORTED          0x000C
-#define PXE_STATCODE_BUFFER_FULL          0x000D
-#define PXE_STATCODE_INVALID_PARAMETER    0x000E
-#define PXE_STATCODE_INVALID_UNDI         0x000F
-#define PXE_STATCODE_IPV4_NOT_SUPPORTED   0x0010
-#define PXE_STATCODE_IPV6_NOT_SUPPORTED   0x0011
-#define PXE_STATCODE_NOT_ENOUGH_MEMORY    0x0012
-#define PXE_STATCODE_NO_DATA              0x0013
-
-typedef PXE_UINT16  PXE_IFNUM;
-
-///
-/// This interface number must be passed to the S/W UNDI Start command.
-///
-#define PXE_IFNUM_START 0x0000
-
-///
-/// This interface number is returned by the S/W UNDI Get State and
-/// Start commands if information in the CDB, CPB or DB is invalid.
-///
-#define PXE_IFNUM_INVALID 0x0000
-
-typedef PXE_UINT16  PXE_CONTROL;
-
-///
-/// Setting this flag directs the UNDI to queue this command for later
-/// execution if the UNDI is busy and it supports command queuing.
-/// If queuing is not supported, a PXE_STATCODE_INVALID_CONTROL error
-/// is returned.  If the queue is full, a PXE_STATCODE_CDB_QUEUE_FULL
-/// error is returned.
-///
-#define PXE_CONTROL_QUEUE_IF_BUSY 0x0002
-
-///
-/// These two bit values are used to determine if there are more UNDI
-/// CDB structures following this one.  If the link bit is set, there
-/// must be a CDB structure following this one.  Execution will start
-/// on the next CDB structure as soon as this one completes successfully.
-/// If an error is generated by this command, execution will stop.
-///
-#define PXE_CONTROL_LINK              0x0001
-#define PXE_CONTROL_LAST_CDB_IN_LIST  0x0000
-
-typedef PXE_UINT8   PXE_FRAME_TYPE;
-
-#define PXE_FRAME_TYPE_NONE                     0x00
-#define PXE_FRAME_TYPE_UNICAST                  0x01
-#define PXE_FRAME_TYPE_BROADCAST                0x02
-#define PXE_FRAME_TYPE_FILTERED_MULTICAST       0x03
-#define PXE_FRAME_TYPE_PROMISCUOUS              0x04
-#define PXE_FRAME_TYPE_PROMISCUOUS_MULTICAST    0x05
-
-#define PXE_FRAME_TYPE_MULTICAST                PXE_FRAME_TYPE_FILTERED_MULTICAST
-
-typedef PXE_UINT32  PXE_IPV4;
-
-typedef PXE_UINT32  PXE_IPV6[4];
-#define PXE_MAC_LENGTH  32
-
-typedef PXE_UINT8   PXE_MAC_ADDR[PXE_MAC_LENGTH];
-
-typedef PXE_UINT8   PXE_IFTYPE;
-typedef UINT16      PXE_MEDIA_PROTOCOL;
-
-///
-/// This information is from the ARP section of RFC 1700.
-///
-///     1 Ethernet (10Mb)                                    [JBP]
-///     2 Experimental Ethernet (3Mb)                        [JBP]
-///     3 Amateur Radio AX.25                                [PXK]
-///     4 Proteon ProNET Token Ring                          [JBP]
-///     5 Chaos                                              [GXP]
-///     6 IEEE 802 Networks                                  [JBP]
-///     7 ARCNET                                             [JBP]
-///     8 Hyperchannel                                       [JBP]
-///     9 Lanstar                                             [TU]
-///    10 Autonet Short Address                             [MXB1]
-///    11 LocalTalk                                         [JKR1]
-///    12 LocalNet (IBM* PCNet or SYTEK* LocalNET)           [JXM]
-///    13 Ultra link                                        [RXD2]
-///    14 SMDS                                              [GXC1]
-///    15 Frame Relay                                        [AGM]
-///    16 Asynchronous Transmission Mode (ATM)              [JXB2]
-///    17 HDLC                                               [JBP]
-///    18 Fibre Channel                            [Yakov Rekhter]
-///    19 Asynchronous Transmission Mode (ATM)      [Mark Laubach]
-///    20 Serial Line                                        [JBP]
-///    21 Asynchronous Transmission Mode (ATM)              [MXB1]
-///
-/// * Other names and brands may be claimed as the property of others.
-///
-#define PXE_IFTYPE_ETHERNET       0x01
-#define PXE_IFTYPE_TOKENRING      0x04
-#define PXE_IFTYPE_FIBRE_CHANNEL  0x12
-
-typedef struct s_pxe_hw_undi {
-  PXE_UINT32  Signature;      ///< PXE_ROMID_SIGNATURE.
-  PXE_UINT8   Len;            ///< sizeof(PXE_HW_UNDI).
-  PXE_UINT8   Fudge;          ///< makes 8-bit cksum equal zero.
-  PXE_UINT8   Rev;            ///< PXE_ROMID_REV.
-  PXE_UINT8   IFcnt;          ///< physical connector count lower byte.
-  PXE_UINT8   MajorVer;       ///< PXE_ROMID_MAJORVER.
-  PXE_UINT8   MinorVer;       ///< PXE_ROMID_MINORVER.
-  PXE_UINT8   IFcntExt;       ///< physical connector count upper byte.
-  PXE_UINT8   reserved;       ///< zero, not used.
-  PXE_UINT32  Implementation; ///< implementation flags.
-  ///< reserved             ///< vendor use.
-  ///< UINT32 Status;       ///< status port.
-  ///< UINT32 Command;      ///< command port.
-  ///< UINT64 CDBaddr;      ///< CDB address port.
-  ///<
-} PXE_HW_UNDI;
-
-///
-/// Status port bit definitions.
-///
-
-///
-/// UNDI operation state.
-///
-#define PXE_HWSTAT_STATE_MASK   0xC0000000
-#define PXE_HWSTAT_BUSY         0xC0000000
-#define PXE_HWSTAT_INITIALIZED  0x80000000
-#define PXE_HWSTAT_STARTED      0x40000000
-#define PXE_HWSTAT_STOPPED      0x00000000
-
-///
-/// If set, last command failed.
-///
-#define PXE_HWSTAT_COMMAND_FAILED 0x20000000
-
-///
-/// If set, identifies enabled receive filters.
-///
-#define PXE_HWSTAT_PROMISCUOUS_MULTICAST_RX_ENABLED 0x00001000
-#define PXE_HWSTAT_PROMISCUOUS_RX_ENABLED           0x00000800
-#define PXE_HWSTAT_BROADCAST_RX_ENABLED             0x00000400
-#define PXE_HWSTAT_MULTICAST_RX_ENABLED             0x00000200
-#define PXE_HWSTAT_UNICAST_RX_ENABLED               0x00000100
-
-///
-/// If set, identifies enabled external interrupts.
-///
-#define PXE_HWSTAT_SOFTWARE_INT_ENABLED     0x00000080
-#define PXE_HWSTAT_TX_COMPLETE_INT_ENABLED  0x00000040
-#define PXE_HWSTAT_PACKET_RX_INT_ENABLED    0x00000020
-#define PXE_HWSTAT_CMD_COMPLETE_INT_ENABLED 0x00000010
-
-///
-/// If set, identifies pending interrupts.
-///
-#define PXE_HWSTAT_SOFTWARE_INT_PENDING     0x00000008
-#define PXE_HWSTAT_TX_COMPLETE_INT_PENDING  0x00000004
-#define PXE_HWSTAT_PACKET_RX_INT_PENDING    0x00000002
-#define PXE_HWSTAT_CMD_COMPLETE_INT_PENDING 0x00000001
-
-///
-/// Command port definitions.
-///
-
-///
-/// If set, CDB identified in CDBaddr port is given to UNDI.
-/// If not set, other bits in this word will be processed.
-///
-#define PXE_HWCMD_ISSUE_COMMAND   0x80000000
-#define PXE_HWCMD_INTS_AND_FILTS  0x00000000
-
-///
-/// Use these to enable/disable receive filters.
-///
-#define PXE_HWCMD_PROMISCUOUS_MULTICAST_RX_ENABLE 0x00001000
-#define PXE_HWCMD_PROMISCUOUS_RX_ENABLE           0x00000800
-#define PXE_HWCMD_BROADCAST_RX_ENABLE             0x00000400
-#define PXE_HWCMD_MULTICAST_RX_ENABLE             0x00000200
-#define PXE_HWCMD_UNICAST_RX_ENABLE               0x00000100
-
-///
-/// Use these to enable/disable external interrupts.
-///
-#define PXE_HWCMD_SOFTWARE_INT_ENABLE     0x00000080
-#define PXE_HWCMD_TX_COMPLETE_INT_ENABLE  0x00000040
-#define PXE_HWCMD_PACKET_RX_INT_ENABLE    0x00000020
-#define PXE_HWCMD_CMD_COMPLETE_INT_ENABLE 0x00000010
-
-///
-/// Use these to clear pending external interrupts.
-///
-#define PXE_HWCMD_CLEAR_SOFTWARE_INT      0x00000008
-#define PXE_HWCMD_CLEAR_TX_COMPLETE_INT   0x00000004
-#define PXE_HWCMD_CLEAR_PACKET_RX_INT     0x00000002
-#define PXE_HWCMD_CLEAR_CMD_COMPLETE_INT  0x00000001
-
-typedef struct s_pxe_sw_undi {
-  PXE_UINT32  Signature;      ///< PXE_ROMID_SIGNATURE.
-  PXE_UINT8   Len;            ///< sizeof(PXE_SW_UNDI).
-  PXE_UINT8   Fudge;          ///< makes 8-bit cksum zero.
-  PXE_UINT8   Rev;            ///< PXE_ROMID_REV.
-  PXE_UINT8   IFcnt;          ///< physical connector count lower byte.
-  PXE_UINT8   MajorVer;       ///< PXE_ROMID_MAJORVER.
-  PXE_UINT8   MinorVer;       ///< PXE_ROMID_MINORVER.
-  PXE_UINT8   IFcntExt;       ///< physical connector count upper byte.
-  PXE_UINT8   reserved1;      ///< zero, not used.
-  PXE_UINT32  Implementation; ///< Implementation flags.
-  PXE_UINT64  EntryPoint;     ///< API entry point.
-  PXE_UINT8   reserved2[3];   ///< zero, not used.
-  PXE_UINT8   BusCnt;         ///< number of bustypes supported.
-  PXE_UINT32  BusType[1];     ///< list of supported bustypes.
-} PXE_SW_UNDI;
-
-typedef union u_pxe_undi {
-  PXE_HW_UNDI hw;
-  PXE_SW_UNDI sw;
-} PXE_UNDI;
-
-///
-/// Signature of !PXE structure.
-///
-#define PXE_ROMID_SIGNATURE PXE_BUSTYPE ('!', 'P', 'X', 'E')
-
-///
-/// !PXE structure format revision
-///.
-#define PXE_ROMID_REV 0x02
-
-///
-/// UNDI command interface revision.  These are the values that get sent
-/// in option 94 (Client Network Interface Identifier) in the DHCP Discover
-/// and PXE Boot Server Request packets.
-///
-#define PXE_ROMID_MAJORVER    0x03
-#define PXE_ROMID_MINORVER    0x01
-
-///
-/// Implementation flags.
-///
-#define PXE_ROMID_IMP_HW_UNDI                             0x80000000
-#define PXE_ROMID_IMP_SW_VIRT_ADDR                        0x40000000
-#define PXE_ROMID_IMP_64BIT_DEVICE                        0x00010000
-#define PXE_ROMID_IMP_FRAG_SUPPORTED                      0x00008000
-#define PXE_ROMID_IMP_CMD_LINK_SUPPORTED                  0x00004000
-#define PXE_ROMID_IMP_CMD_QUEUE_SUPPORTED                 0x00002000
-#define PXE_ROMID_IMP_MULTI_FRAME_SUPPORTED               0x00001000
-#define PXE_ROMID_IMP_NVDATA_SUPPORT_MASK                 0x00000C00
-#define PXE_ROMID_IMP_NVDATA_BULK_WRITABLE                0x00000C00
-#define PXE_ROMID_IMP_NVDATA_SPARSE_WRITABLE              0x00000800
-#define PXE_ROMID_IMP_NVDATA_READ_ONLY                    0x00000400
-#define PXE_ROMID_IMP_NVDATA_NOT_AVAILABLE                0x00000000
-#define PXE_ROMID_IMP_STATISTICS_SUPPORTED                0x00000200
-#define PXE_ROMID_IMP_STATION_ADDR_SETTABLE               0x00000100
-#define PXE_ROMID_IMP_PROMISCUOUS_MULTICAST_RX_SUPPORTED  0x00000080
-#define PXE_ROMID_IMP_PROMISCUOUS_RX_SUPPORTED            0x00000040
-#define PXE_ROMID_IMP_BROADCAST_RX_SUPPORTED              0x00000020
-#define PXE_ROMID_IMP_FILTERED_MULTICAST_RX_SUPPORTED     0x00000010
-#define PXE_ROMID_IMP_SOFTWARE_INT_SUPPORTED              0x00000008
-#define PXE_ROMID_IMP_TX_COMPLETE_INT_SUPPORTED           0x00000004
-#define PXE_ROMID_IMP_PACKET_RX_INT_SUPPORTED             0x00000002
-#define PXE_ROMID_IMP_CMD_COMPLETE_INT_SUPPORTED          0x00000001
-
-typedef struct s_pxe_cdb {
-  PXE_OPCODE    OpCode;
-  PXE_OPFLAGS   OpFlags;
-  PXE_UINT16    CPBsize;
-  PXE_UINT16    DBsize;
-  PXE_UINT64    CPBaddr;
-  PXE_UINT64    DBaddr;
-  PXE_STATCODE  StatCode;
-  PXE_STATFLAGS StatFlags;
-  PXE_UINT16    IFnum;
-  PXE_CONTROL   Control;
-} PXE_CDB;
-
-typedef union u_pxe_ip_addr {
-  PXE_IPV6  IPv6;
-  PXE_IPV4  IPv4;
-} PXE_IP_ADDR;
-
-typedef union pxe_device {
-  ///
-  /// PCI and PC Card NICs are both identified using bus, device
-  /// and function numbers.  For PC Card, this may require PC
-  /// Card services to be loaded in the BIOS or preboot
-  /// environment.
-  ///
-  struct {
-    ///
-    /// See S/W UNDI ROMID structure definition for PCI and
-    /// PCC BusType definitions.
-    ///
-    PXE_UINT32  BusType;
-
-    ///
-    /// Bus, device & function numbers that locate this device.
-    ///
-    PXE_UINT16  Bus;
-    PXE_UINT8   Device;
-    PXE_UINT8   Function;
-  }
-  PCI, PCC;
-
-} PXE_DEVICE;
-
-///
-/// cpb and db definitions
-///
-#define MAX_PCI_CONFIG_LEN    64  ///< # of dwords.
-#define MAX_EEPROM_LEN        128 ///< # of dwords.
-#define MAX_XMIT_BUFFERS      32  ///< recycling Q length for xmit_done.
-#define MAX_MCAST_ADDRESS_CNT 8
-
-typedef struct s_pxe_cpb_start_30 {
-  ///
-  /// PXE_VOID Delay(UINTN microseconds);
-  ///
-  /// UNDI will never request a delay smaller than 10 microseconds
-  /// and will always request delays in increments of 10 microseconds.
-  /// The Delay() CallBack routine must delay between n and n + 10
-  /// microseconds before returning control to the UNDI.
-  ///
-  /// This field cannot be set to zero.
-  ///
-  UINT64  Delay;
-
-  ///
-  /// PXE_VOID Block(UINT32 enable);
-  ///
-  /// UNDI may need to block multi-threaded/multi-processor access to
-  /// critical code sections when programming or accessing the network
-  /// device.  To this end, a blocking service is needed by the UNDI.
-  /// When UNDI needs a block, it will call Block() passing a non-zero
-  /// value.  When UNDI no longer needs a block, it will call Block()
-  /// with a zero value.  When called, if the Block() is already enabled,
-  /// do not return control to the UNDI until the previous Block() is
-  /// disabled.
-  ///
-  /// This field cannot be set to zero.
-  ///
-  UINT64  Block;
-
-  ///
-  /// PXE_VOID Virt2Phys(UINT64 virtual, UINT64 physical_ptr);
-  ///
-  /// UNDI will pass the virtual address of a buffer and the virtual
-  /// address of a 64-bit physical buffer.  Convert the virtual address
-  /// to a physical address and write the result to the physical address
-  /// buffer.  If virtual and physical addresses are the same, just
-  /// copy the virtual address to the physical address buffer.
-  ///
-  /// This field can be set to zero if virtual and physical addresses
-  /// are equal.
-  ///
-  UINT64  Virt2Phys;
-  ///
-  /// PXE_VOID Mem_IO(UINT8 read_write, UINT8 len, UINT64 port,
-  ///              UINT64 buf_addr);
-  ///
-  /// UNDI will read or write the device io space using this call back
-  /// function. It passes the number of bytes as the len parameter and it
-  /// will be either 1,2,4 or 8.
-  ///
-  /// This field can not be set to zero.
-  ///
-  UINT64  Mem_IO;
-} PXE_CPB_START_30;
-
-typedef struct s_pxe_cpb_start_31 {
-  ///
-  /// PXE_VOID Delay(UINT64 UnqId, UINTN microseconds);
-  ///
-  /// UNDI will never request a delay smaller than 10 microseconds
-  /// and will always request delays in increments of 10 microseconds.
-  /// The Delay() CallBack routine must delay between n and n + 10
-  /// microseconds before returning control to the UNDI.
-  ///
-  /// This field cannot be set to zero.
-  ///
-  UINT64  Delay;
-
-  ///
-  /// PXE_VOID Block(UINT64 unq_id, UINT32 enable);
-  ///
-  /// UNDI may need to block multi-threaded/multi-processor access to
-  /// critical code sections when programming or accessing the network
-  /// device.  To this end, a blocking service is needed by the UNDI.
-  /// When UNDI needs a block, it will call Block() passing a non-zero
-  /// value.  When UNDI no longer needs a block, it will call Block()
-  /// with a zero value.  When called, if the Block() is already enabled,
-  /// do not return control to the UNDI until the previous Block() is
-  /// disabled.
-  ///
-  /// This field cannot be set to zero.
-  ///
-  UINT64  Block;
-
-  ///
-  /// PXE_VOID Virt2Phys(UINT64 UnqId, UINT64 virtual, UINT64 physical_ptr);
-  ///
-  /// UNDI will pass the virtual address of a buffer and the virtual
-  /// address of a 64-bit physical buffer.  Convert the virtual address
-  /// to a physical address and write the result to the physical address
-  /// buffer.  If virtual and physical addresses are the same, just
-  /// copy the virtual address to the physical address buffer.
-  ///
-  /// This field can be set to zero if virtual and physical addresses
-  /// are equal.
-  ///
-  UINT64  Virt2Phys;
-  ///
-  /// PXE_VOID Mem_IO(UINT64 UnqId, UINT8 read_write, UINT8 len, UINT64 port,
-  ///              UINT64 buf_addr);
-  ///
-  /// UNDI will read or write the device io space using this call back
-  /// function. It passes the number of bytes as the len parameter and it
-  /// will be either 1,2,4 or 8.
-  ///
-  /// This field can not be set to zero.
-  ///
-  UINT64  Mem_IO;
-  ///
-  /// PXE_VOID Map_Mem(UINT64 unq_id, UINT64 virtual_addr, UINT32 size,
-  ///                 UINT32 Direction, UINT64 mapped_addr);
-  ///
-  /// UNDI will pass the virtual address of a buffer, direction of the data
-  /// flow from/to the mapped buffer (the constants are defined below)
-  /// and a place holder (pointer) for the mapped address.
-  /// This call will Map the given address to a physical DMA address and write
-  /// the result to the mapped_addr pointer.  If there is no need to
-  /// map the given address to a lower address (i.e. the given address is
-  /// associated with a physical address that is already compatible to be
-  /// used with the DMA, it converts the given virtual address to it's
-  /// physical address and write that in the mapped address pointer.
-  ///
-  /// This field can be set to zero if there is no mapping service available.
-  ///
-  UINT64  Map_Mem;
-
-  ///
-  /// PXE_VOID UnMap_Mem(UINT64 unq_id, UINT64 virtual_addr, UINT32 size,
-  ///            UINT32 Direction, UINT64 mapped_addr);
-  ///
-  /// UNDI will pass the virtual and mapped addresses of a buffer.
-  /// This call will un map the given address.
-  ///
-  /// This field can be set to zero if there is no unmapping service available.
-  ///
-  UINT64  UnMap_Mem;
-
-  ///
-  /// PXE_VOID Sync_Mem(UINT64 unq_id, UINT64 virtual,
-  ///            UINT32 size, UINT32 Direction, UINT64 mapped_addr);
-  ///
-  /// UNDI will pass the virtual and mapped addresses of a buffer.
-  /// This call will synchronize the contents of both the virtual and mapped.
-  /// buffers for the given Direction.
-  ///
-  /// This field can be set to zero if there is no service available.
-  ///
-  UINT64  Sync_Mem;
-
-  ///
-  /// protocol driver can provide anything for this Unique_ID, UNDI remembers
-  /// that as just a 64bit value assocaited to the interface specified by
-  /// the ifnum and gives it back as a parameter to all the call-back routines
-  /// when calling for that interface!
-  ///
-  UINT64  Unique_ID;
-} PXE_CPB_START_31;
-
-#define TO_AND_FROM_DEVICE    0
-#define FROM_DEVICE           1
-#define TO_DEVICE             2
-
-#define PXE_DELAY_MILLISECOND 1000
-#define PXE_DELAY_SECOND      1000000
-#define PXE_IO_READ           0
-#define PXE_IO_WRITE          1
-#define PXE_MEM_READ          2
-#define PXE_MEM_WRITE         4
-
-typedef struct s_pxe_db_get_init_info {
-  ///
-  /// Minimum length of locked memory buffer that must be given to
-  /// the Initialize command. Giving UNDI more memory will generally
-  /// give better performance.
-  ///
-  /// If MemoryRequired is zero, the UNDI does not need and will not
-  /// use system memory to receive and transmit packets.
-  ///
-  PXE_UINT32  MemoryRequired;
-
-  ///
-  /// Maximum frame data length for Tx/Rx excluding the media header.
-  ///
-  PXE_UINT32  FrameDataLen;
-
-  ///
-  /// Supported link speeds are in units of mega bits.  Common ethernet
-  /// values are 10, 100 and 1000.  Unused LinkSpeeds[] entries are zero
-  /// filled.
-  ///
-  PXE_UINT32  LinkSpeeds[4];
-
-  ///
-  /// Number of non-volatile storage items.
-  ///
-  PXE_UINT32  NvCount;
-
-  ///
-  /// Width of non-volatile storage item in bytes.  0, 1, 2 or 4
-  ///
-  PXE_UINT16  NvWidth;
-
-  ///
-  /// Media header length.  This is the typical media header length for
-  /// this UNDI.  This information is needed when allocating receive
-  /// and transmit buffers.
-  ///
-  PXE_UINT16  MediaHeaderLen;
-
-  ///
-  /// Number of bytes in the NIC hardware (MAC) address.
-  ///
-  PXE_UINT16  HWaddrLen;
-
-  ///
-  /// Maximum number of multicast MAC addresses in the multicast
-  /// MAC address filter list.
-  ///
-  PXE_UINT16  MCastFilterCnt;
-
-  ///
-  /// Default number and size of transmit and receive buffers that will
-  /// be allocated by the UNDI.  If MemoryRequired is non-zero, this
-  /// allocation will come out of the memory buffer given to the Initialize
-  /// command.  If MemoryRequired is zero, this allocation will come out of
-  /// memory on the NIC.
-  ///
-  PXE_UINT16  TxBufCnt;
-  PXE_UINT16  TxBufSize;
-  PXE_UINT16  RxBufCnt;
-  PXE_UINT16  RxBufSize;
-
-  ///
-  /// Hardware interface types defined in the Assigned Numbers RFC
-  /// and used in DHCP and ARP packets.
-  /// See the PXE_IFTYPE typedef and PXE_IFTYPE_xxx macros.
-  ///
-  PXE_UINT8   IFtype;
-
-  ///
-  /// Supported duplex.  See PXE_DUPLEX_xxxxx #defines below.
-  ///
-  PXE_UINT8   SupportedDuplexModes;
-
-  ///
-  /// Supported loopback options.  See PXE_LOOPBACK_xxxxx #defines below.
-  ///
-  PXE_UINT8   SupportedLoopBackModes;
-} PXE_DB_GET_INIT_INFO;
-
-#define PXE_MAX_TXRX_UNIT_ETHER           1500
-
-#define PXE_HWADDR_LEN_ETHER              0x0006
-#define PXE_MAC_HEADER_LEN_ETHER          0x000E
-
-#define PXE_DUPLEX_ENABLE_FULL_SUPPORTED  1
-#define PXE_DUPLEX_FORCE_FULL_SUPPORTED   2
-
-#define PXE_LOOPBACK_INTERNAL_SUPPORTED   1
-#define PXE_LOOPBACK_EXTERNAL_SUPPORTED   2
-
-typedef struct s_pxe_pci_config_info {
-  ///
-  /// This is the flag field for the PXE_DB_GET_CONFIG_INFO union.
-  /// For PCI bus devices, this field is set to PXE_BUSTYPE_PCI.
-  ///
-  UINT32  BusType;
-
-  ///
-  /// This identifies the PCI network device that this UNDI interface.
-  /// is bound to.
-  ///
-  UINT16  Bus;
-  UINT8   Device;
-  UINT8   Function;
-
-  ///
-  /// This is a copy of the PCI configuration space for this
-  /// network device.
-  ///
-  union {
-    UINT8   Byte[256];
-    UINT16  Word[128];
-    UINT32  Dword[64];
-  } Config;
-} PXE_PCI_CONFIG_INFO;
-
-typedef struct s_pxe_pcc_config_info {
-  ///
-  /// This is the flag field for the PXE_DB_GET_CONFIG_INFO union.
-  /// For PCC bus devices, this field is set to PXE_BUSTYPE_PCC.
-  ///
-  PXE_UINT32  BusType;
-
-  ///
-  /// This identifies the PCC network device that this UNDI interface
-  /// is bound to.
-  ///
-  PXE_UINT16  Bus;
-  PXE_UINT8   Device;
-  PXE_UINT8   Function;
-
-  ///
-  /// This is a copy of the PCC configuration space for this
-  /// network device.
-  ///
-  union {
-    PXE_UINT8   Byte[256];
-    PXE_UINT16  Word[128];
-    PXE_UINT32  Dword[64];
-  } Config;
-} PXE_PCC_CONFIG_INFO;
-
-typedef union u_pxe_db_get_config_info {
-  PXE_PCI_CONFIG_INFO   pci;
-  PXE_PCC_CONFIG_INFO   pcc;
-} PXE_DB_GET_CONFIG_INFO;
-
-typedef struct s_pxe_cpb_initialize {
-  ///
-  /// Address of first (lowest) byte of the memory buffer.  This buffer must
-  /// be in contiguous physical memory and cannot be swapped out.  The UNDI
-  /// will be using this for transmit and receive buffering.
-  ///
-  PXE_UINT64  MemoryAddr;
-
-  ///
-  /// MemoryLength must be greater than or equal to MemoryRequired
-  /// returned by the Get Init Info command.
-  ///
-  PXE_UINT32  MemoryLength;
-
-  ///
-  /// Desired link speed in Mbit/sec.  Common ethernet values are 10, 100
-  /// and 1000.  Setting a value of zero will auto-detect and/or use the
-  /// default link speed (operation depends on UNDI/NIC functionality).
-  ///
-  PXE_UINT32  LinkSpeed;
-
-  ///
-  /// Suggested number and size of receive and transmit buffers to
-  /// allocate.  If MemoryAddr and MemoryLength are non-zero, this
-  /// allocation comes out of the supplied memory buffer.  If MemoryAddr
-  /// and MemoryLength are zero, this allocation comes out of memory
-  /// on the NIC.
-  ///
-  /// If these fields are set to zero, the UNDI will allocate buffer
-  /// counts and sizes as it sees fit.
-  ///
-  PXE_UINT16  TxBufCnt;
-  PXE_UINT16  TxBufSize;
-  PXE_UINT16  RxBufCnt;
-  PXE_UINT16  RxBufSize;
-
-  ///
-  /// The following configuration parameters are optional and must be zero
-  /// to use the default values.
-  ///
-  PXE_UINT8   DuplexMode;
-
-  PXE_UINT8   LoopBackMode;
-} PXE_CPB_INITIALIZE;
-
-#define PXE_DUPLEX_DEFAULT      0x00
-#define PXE_FORCE_FULL_DUPLEX   0x01
-#define PXE_ENABLE_FULL_DUPLEX  0x02
-#define PXE_FORCE_HALF_DUPLEX   0x04
-#define PXE_DISABLE_FULL_DUPLEX 0x08
-
-#define LOOPBACK_NORMAL         0
-#define LOOPBACK_INTERNAL       1
-#define LOOPBACK_EXTERNAL       2
-
-typedef struct s_pxe_db_initialize {
-  ///
-  /// Actual amount of memory used from the supplied memory buffer.  This
-  /// may be less that the amount of memory suppllied and may be zero if
-  /// the UNDI and network device do not use external memory buffers.
-  ///
-  /// Memory used by the UNDI and network device is allocated from the
-  /// lowest memory buffer address.
-  ///
-  PXE_UINT32  MemoryUsed;
-
-  ///
-  /// Actual number and size of receive and transmit buffers that were
-  /// allocated.
-  ///
-  PXE_UINT16  TxBufCnt;
-  PXE_UINT16  TxBufSize;
-  PXE_UINT16  RxBufCnt;
-  PXE_UINT16  RxBufSize;
-} PXE_DB_INITIALIZE;
-
-typedef struct s_pxe_cpb_receive_filters {
-  ///
-  /// List of multicast MAC addresses.  This list, if present, will
-  /// replace the existing multicast MAC address filter list.
-  ///
-  PXE_MAC_ADDR  MCastList[MAX_MCAST_ADDRESS_CNT];
-} PXE_CPB_RECEIVE_FILTERS;
-
-typedef struct s_pxe_db_receive_filters {
-  ///
-  /// Filtered multicast MAC address list.
-  ///
-  PXE_MAC_ADDR  MCastList[MAX_MCAST_ADDRESS_CNT];
-} PXE_DB_RECEIVE_FILTERS;
-
-typedef struct s_pxe_cpb_station_address {
-  ///
-  /// If supplied and supported, the current station MAC address
-  /// will be changed.
-  ///
-  PXE_MAC_ADDR  StationAddr;
-} PXE_CPB_STATION_ADDRESS;
-
-typedef struct s_pxe_dpb_station_address {
-  ///
-  /// Current station MAC address.
-  ///
-  PXE_MAC_ADDR  StationAddr;
-
-  ///
-  /// Station broadcast MAC address.
-  ///
-  PXE_MAC_ADDR  BroadcastAddr;
-
-  ///
-  /// Permanent station MAC address.
-  ///
-  PXE_MAC_ADDR  PermanentAddr;
-} PXE_DB_STATION_ADDRESS;
-
-typedef struct s_pxe_db_statistics {
-  ///
-  /// Bit field identifying what statistic data is collected by the
-  /// UNDI/NIC.
-  /// If bit 0x00 is set, Data[0x00] is collected.
-  /// If bit 0x01 is set, Data[0x01] is collected.
-  /// If bit 0x20 is set, Data[0x20] is collected.
-  /// If bit 0x21 is set, Data[0x21] is collected.
-  /// Etc.
-  ///
-  PXE_UINT64  Supported;
-
-  ///
-  /// Statistic data.
-  ///
-  PXE_UINT64  Data[64];
-} PXE_DB_STATISTICS;
-
-///
-/// Total number of frames received.  Includes frames with errors and
-/// dropped frames.
-///
-#define PXE_STATISTICS_RX_TOTAL_FRAMES  0x00
-
-///
-/// Number of valid frames received and copied into receive buffers.
-///
-#define PXE_STATISTICS_RX_GOOD_FRAMES 0x01
-
-///
-/// Number of frames below the minimum length for the media.
-/// This would be <64 for ethernet.
-///
-#define PXE_STATISTICS_RX_UNDERSIZE_FRAMES  0x02
-
-///
-/// Number of frames longer than the maxminum length for the
-/// media.  This would be >1500 for ethernet.
-///
-#define PXE_STATISTICS_RX_OVERSIZE_FRAMES 0x03
-
-///
-/// Valid frames that were dropped because receive buffers were full.
-///
-#define PXE_STATISTICS_RX_DROPPED_FRAMES  0x04
-
-///
-/// Number of valid unicast frames received and not dropped.
-///
-#define PXE_STATISTICS_RX_UNICAST_FRAMES  0x05
-
-///
-/// Number of valid broadcast frames received and not dropped.
-///
-#define PXE_STATISTICS_RX_BROADCAST_FRAMES  0x06
-
-///
-/// Number of valid mutlicast frames received and not dropped.
-///
-#define PXE_STATISTICS_RX_MULTICAST_FRAMES  0x07
-
-///
-/// Number of frames w/ CRC or alignment errors.
-///
-#define PXE_STATISTICS_RX_CRC_ERROR_FRAMES  0x08
-
-///
-/// Total number of bytes received.  Includes frames with errors
-/// and dropped frames.
-///
-#define PXE_STATISTICS_RX_TOTAL_BYTES 0x09
-
-///
-/// Transmit statistics.
-///
-#define PXE_STATISTICS_TX_TOTAL_FRAMES      0x0A
-#define PXE_STATISTICS_TX_GOOD_FRAMES       0x0B
-#define PXE_STATISTICS_TX_UNDERSIZE_FRAMES  0x0C
-#define PXE_STATISTICS_TX_OVERSIZE_FRAMES   0x0D
-#define PXE_STATISTICS_TX_DROPPED_FRAMES    0x0E
-#define PXE_STATISTICS_TX_UNICAST_FRAMES    0x0F
-#define PXE_STATISTICS_TX_BROADCAST_FRAMES  0x10
-#define PXE_STATISTICS_TX_MULTICAST_FRAMES  0x11
-#define PXE_STATISTICS_TX_CRC_ERROR_FRAMES  0x12
-#define PXE_STATISTICS_TX_TOTAL_BYTES       0x13
-
-///
-/// Number of collisions detection on this subnet.
-///
-#define PXE_STATISTICS_COLLISIONS 0x14
-
-///
-/// Number of frames destined for unsupported protocol.
-///
-#define PXE_STATISTICS_UNSUPPORTED_PROTOCOL 0x15
-
-typedef struct s_pxe_cpb_mcast_ip_to_mac {
-  ///
-  /// Multicast IP address to be converted to multicast MAC address.
-  ///
-  PXE_IP_ADDR IP;
-} PXE_CPB_MCAST_IP_TO_MAC;
-
-typedef struct s_pxe_db_mcast_ip_to_mac {
-  ///
-  /// Multicast MAC address.
-  ///
-  PXE_MAC_ADDR  MAC;
-} PXE_DB_MCAST_IP_TO_MAC;
-
-typedef struct s_pxe_cpb_nvdata_sparse {
-  ///
-  /// NvData item list.  Only items in this list will be updated.
-  ///
-  struct {
-    ///
-    ///  Non-volatile storage address to be changed.
-    ///
-    PXE_UINT32  Addr;
-
-    ///
-    /// Data item to write into above storage address.
-    ///
-    union {
-      PXE_UINT8   Byte;
-      PXE_UINT16  Word;
-      PXE_UINT32  Dword;
-    } Data;
-  } Item[MAX_EEPROM_LEN];
-} PXE_CPB_NVDATA_SPARSE;
-
-///
-/// When using bulk update, the size of the CPB structure must be
-/// the same size as the non-volatile NIC storage.
-///
-typedef union u_pxe_cpb_nvdata_bulk {
-  ///
-  /// Array of byte-wide data items.
-  ///
-  PXE_UINT8   Byte[MAX_EEPROM_LEN << 2];
-
-  ///
-  /// Array of word-wide data items.
-  ///
-  PXE_UINT16  Word[MAX_EEPROM_LEN << 1];
-
-  ///
-  /// Array of dword-wide data items.
-  ///
-  PXE_UINT32  Dword[MAX_EEPROM_LEN];
-} PXE_CPB_NVDATA_BULK;
-
-typedef struct s_pxe_db_nvdata {
-  ///
-  /// Arrays of data items from non-volatile storage.
-  ///
-  union {
-    ///
-    /// Array of byte-wide data items.
-    ///
-    PXE_UINT8   Byte[MAX_EEPROM_LEN << 2];
-
-    ///
-    /// Array of word-wide data items.
-    ///
-    PXE_UINT16  Word[MAX_EEPROM_LEN << 1];
-
-    ///
-    /// Array of dword-wide data items.
-    ///
-    PXE_UINT32  Dword[MAX_EEPROM_LEN];
-  } Data;
-} PXE_DB_NVDATA;
-
-typedef struct s_pxe_db_get_status {
-  ///
-  /// Length of next receive frame (header + data).  If this is zero,
-  /// there is no next receive frame available.
-  ///
-  PXE_UINT32  RxFrameLen;
-
-  ///
-  /// Reserved, set to zero.
-  ///
-  PXE_UINT32  reserved;
-
-  ///
-  ///  Addresses of transmitted buffers that need to be recycled.
-  ///
-  PXE_UINT64  TxBuffer[MAX_XMIT_BUFFERS];
-} PXE_DB_GET_STATUS;
-
-typedef struct s_pxe_cpb_fill_header {
-  ///
-  /// Source and destination MAC addresses.  These will be copied into
-  /// the media header without doing byte swapping.
-  ///
-  PXE_MAC_ADDR  SrcAddr;
-  PXE_MAC_ADDR  DestAddr;
-
-  ///
-  /// Address of first byte of media header.  The first byte of packet data
-  /// follows the last byte of the media header.
-  ///
-  PXE_UINT64        MediaHeader;
-
-  ///
-  /// Length of packet data in bytes (not including the media header).
-  ///
-  PXE_UINT32        PacketLen;
-
-  ///
-  /// Protocol type.  This will be copied into the media header without
-  /// doing byte swapping.  Protocol type numbers can be obtained from
-  /// the Assigned Numbers RFC 1700.
-  ///
-  PXE_UINT16        Protocol;
-
-  ///
-  /// Length of the media header in bytes.
-  ///
-  PXE_UINT16        MediaHeaderLen;
-} PXE_CPB_FILL_HEADER;
-
-#define PXE_PROTOCOL_ETHERNET_IP  0x0800
-#define PXE_PROTOCOL_ETHERNET_ARP 0x0806
-#define MAX_XMIT_FRAGMENTS        16
-
-typedef struct s_pxe_cpb_fill_header_fragmented {
-  ///
-  /// Source and destination MAC addresses.  These will be copied into
-  /// the media header without doing byte swapping.
-  ///
-  PXE_MAC_ADDR        SrcAddr;
-  PXE_MAC_ADDR        DestAddr;
-
-  ///
-  /// Length of packet data in bytes (not including the media header).
-  ///
-  PXE_UINT32          PacketLen;
-
-  ///
-  /// Protocol type.  This will be copied into the media header without
-  /// doing byte swapping.  Protocol type numbers can be obtained from
-  /// the Assigned Numbers RFC 1700.
-  ///
-  PXE_MEDIA_PROTOCOL  Protocol;
-
-  ///
-  /// Length of the media header in bytes.
-  ///
-  PXE_UINT16          MediaHeaderLen;
-
-  ///
-  /// Number of packet fragment descriptors.
-  ///
-  PXE_UINT16          FragCnt;
-
-  ///
-  /// Reserved, must be set to zero.
-  ///
-  PXE_UINT16          reserved;
-
-  ///
-  /// Array of packet fragment descriptors.  The first byte of the media
-  /// header is the first byte of the first fragment.
-  ///
-  struct {
-    ///
-    /// Address of this packet fragment.
-    ///
-    PXE_UINT64  FragAddr;
-
-    ///
-    /// Length of this packet fragment.
-    ///
-    PXE_UINT32  FragLen;
-
-    ///
-    /// Reserved, must be set to zero.
-    ///
-    PXE_UINT32  reserved;
-  } FragDesc[MAX_XMIT_FRAGMENTS];
-}
-PXE_CPB_FILL_HEADER_FRAGMENTED;
-
-typedef struct s_pxe_cpb_transmit {
-  ///
-  /// Address of first byte of frame buffer.  This is also the first byte
-  /// of the media header.
-  ///
-  PXE_UINT64  FrameAddr;
-
-  ///
-  /// Length of the data portion of the frame buffer in bytes.  Do not
-  /// include the length of the media header.
-  ///
-  PXE_UINT32  DataLen;
-
-  ///
-  /// Length of the media header in bytes.
-  ///
-  PXE_UINT16  MediaheaderLen;
-
-  ///
-  /// Reserved, must be zero.
-  ///
-  PXE_UINT16  reserved;
-} PXE_CPB_TRANSMIT;
-
-typedef struct s_pxe_cpb_transmit_fragments {
-  ///
-  /// Length of packet data in bytes (not including the media header).
-  ///
-  PXE_UINT32  FrameLen;
-
-  ///
-  /// Length of the media header in bytes.
-  ///
-  PXE_UINT16  MediaheaderLen;
-
-  ///
-  /// Number of packet fragment descriptors.
-  ///
-  PXE_UINT16  FragCnt;
-
-  ///
-  /// Array of frame fragment descriptors.  The first byte of the first
-  /// fragment is also the first byte of the media header.
-  ///
-  struct {
-    ///
-    /// Address of this frame fragment.
-    ///
-    PXE_UINT64  FragAddr;
-
-    ///
-    /// Length of this frame fragment.
-    ///
-    PXE_UINT32  FragLen;
-
-    ///
-    /// Reserved, must be set to zero.
-    ///
-    PXE_UINT32  reserved;
-  } FragDesc[MAX_XMIT_FRAGMENTS];
-}
-PXE_CPB_TRANSMIT_FRAGMENTS;
-
-typedef struct s_pxe_cpb_receive {
-  ///
-  /// Address of first byte of receive buffer.  This is also the first byte
-  /// of the frame header.
-  ///
-  PXE_UINT64  BufferAddr;
-
-  ///
-  /// Length of receive buffer.  This must be large enough to hold the
-  /// received frame (media header + data).  If the length of smaller than
-  /// the received frame, data will be lost.
-  ///
-  PXE_UINT32  BufferLen;
-
-  ///
-  /// Reserved, must be set to zero.
-  ///
-  PXE_UINT32  reserved;
-} PXE_CPB_RECEIVE;
-
-typedef struct s_pxe_db_receive {
-  ///
-  /// Source and destination MAC addresses from media header.
-  ///
-  PXE_MAC_ADDR        SrcAddr;
-  PXE_MAC_ADDR        DestAddr;
-
-  ///
-  /// Length of received frame.  May be larger than receive buffer size.
-  /// The receive buffer will not be overwritten.  This is how to tell
-  /// if data was lost because the receive buffer was too small.
-  ///
-  PXE_UINT32          FrameLen;
-
-  ///
-  /// Protocol type from media header.
-  ///
-  PXE_MEDIA_PROTOCOL  Protocol;
-
-  ///
-  /// Length of media header in received frame.
-  ///
-  PXE_UINT16          MediaHeaderLen;
-
-  ///
-  /// Type of receive frame.
-  ///
-  PXE_FRAME_TYPE      Type;
-
-  ///
-  /// Reserved, must be zero.
-  ///
-  PXE_UINT8           reserved[7];
-
-} PXE_DB_RECEIVE;
-
-#pragma pack()
-
-#endif
diff --git a/src/efi/Uefi/UefiSpec.h b/src/efi/Uefi/UefiSpec.h
deleted file mode 100644
index 7a7c0b3..0000000
--- a/src/efi/Uefi/UefiSpec.h
+++ /dev/null
@@ -1,2144 +0,0 @@
-/** @file
-  Include file that supports UEFI.
-
-  This include file must contain things defined in the UEFI 2.4 specification.
-  If a code construct is defined in the UEFI 2.4 specification it must be included
-  by this include file.
-
-Copyright (c) 2006 - 2014, Intel Corporation. All rights reserved.<BR>
-This program and the accompanying materials are licensed and made available under
-the terms and conditions of the BSD License that accompanies this distribution.
-The full text of the license may be found at
-http://opensource.org/licenses/bsd-license.php.
-
-THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
-WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
-
-**/
-
-#ifndef __UEFI_SPEC_H__
-#define __UEFI_SPEC_H__
-
-#include "efi/Uefi/UefiMultiPhase.h"
-
-#include "efi/Protocol/DevicePath.h"
-#include "efi/Protocol/SimpleTextIn.h"
-#include "efi/Protocol/SimpleTextInEx.h"
-#include "efi/Protocol/SimpleTextOut.h"
-
-///
-/// Enumeration of EFI memory allocation types.
-///
-typedef enum {
-  ///
-  /// Allocate any available range of pages that satisfies the request.
-  ///
-  AllocateAnyPages,
-  ///
-  /// Allocate any available range of pages whose uppermost address is less than
-  /// or equal to a specified maximum address.
-  ///
-  AllocateMaxAddress,
-  ///
-  /// Allocate pages at a specified address.
-  ///
-  AllocateAddress,
-  ///
-  /// Maximum enumeration value that may be used for bounds checking.
-  ///
-  MaxAllocateType
-} EFI_ALLOCATE_TYPE;
-
-//
-// Bit definitions for EFI_TIME.Daylight
-//
-#define EFI_TIME_ADJUST_DAYLIGHT  0x01
-#define EFI_TIME_IN_DAYLIGHT      0x02
-
-///
-/// Value definition for EFI_TIME.TimeZone.
-///
-#define EFI_UNSPECIFIED_TIMEZONE  0x07FF
-
-//
-// Memory cacheability attributes
-//
-#define EFI_MEMORY_UC   0x0000000000000001ULL
-#define EFI_MEMORY_WC   0x0000000000000002ULL
-#define EFI_MEMORY_WT   0x0000000000000004ULL
-#define EFI_MEMORY_WB   0x0000000000000008ULL
-#define EFI_MEMORY_UCE  0x0000000000000010ULL
-//
-// Physical memory protection attributes
-//
-#define EFI_MEMORY_WP   0x0000000000001000ULL
-#define EFI_MEMORY_RP   0x0000000000002000ULL
-#define EFI_MEMORY_XP   0x0000000000004000ULL
-//
-// Runtime memory attribute
-//
-#define EFI_MEMORY_RUNTIME  0x8000000000000000ULL
-
-///
-/// Memory descriptor version number.
-///
-#define EFI_MEMORY_DESCRIPTOR_VERSION 1
-
-///
-/// Definition of an EFI memory descriptor.
-///
-typedef struct {
-  ///
-  /// Type of the memory region.  See EFI_MEMORY_TYPE.
-  ///
-  UINT32                Type;
-  ///
-  /// Physical address of the first byte of the memory region.  Must aligned
-  /// on a 4 KB boundary.
-  ///
-  EFI_PHYSICAL_ADDRESS  PhysicalStart;
-  ///
-  /// Virtual address of the first byte of the memory region.  Must aligned
-  /// on a 4 KB boundary.
-  ///
-  EFI_VIRTUAL_ADDRESS   VirtualStart;
-  ///
-  /// Number of 4KB pages in the memory region.
-  ///
-  UINT64                NumberOfPages;
-  ///
-  /// Attributes of the memory region that describe the bit mask of capabilities
-  /// for that memory region, and not necessarily the current settings for that
-  /// memory region.
-  ///
-  UINT64                Attribute;
-} EFI_MEMORY_DESCRIPTOR;
-
-/**
-  Allocates memory pages from the system.
-
-  @param  Type        The type of allocation to perform.
-  @param  MemoryType  The type of memory to allocate.
-  @param  Pages       The number of contiguous 4 KB pages to allocate.
-  @param  Memory      The pointer to a physical address. On input, the way in which the address is
-                      used depends on the value of Type.
-
-  @retval EFI_SUCCESS           The requested pages were allocated.
-  @retval EFI_INVALID_PARAMETER 1) Type is not AllocateAnyPages or
-                                AllocateMaxAddress or AllocateAddress.
-                                2) MemoryType is in the range
-                                3) Memory is NULL.
-                                EfiMaxMemoryType..0x7FFFFFFF.
-  @retval EFI_OUT_OF_RESOURCES  The pages could not be allocated.
-  @retval EFI_NOT_FOUND         The requested pages could not be found.
-
-**/
-typedef
-EFI_STATUS
-(EFIAPI *EFI_ALLOCATE_PAGES)(
-  IN     EFI_ALLOCATE_TYPE            Type,
-  IN     EFI_MEMORY_TYPE              MemoryType,
-  IN     UINTN                        Pages,
-  IN OUT EFI_PHYSICAL_ADDRESS         *Memory
-  );
-
-/**
-  Frees memory pages.
-
-  @param  Memory      The base physical address of the pages to be freed.
-  @param  Pages       The number of contiguous 4 KB pages to free.
-
-  @retval EFI_SUCCESS           The requested pages were freed.
-  @retval EFI_INVALID_PARAMETER Memory is not a page-aligned address or Pages is invalid.
-  @retval EFI_NOT_FOUND         The requested memory pages were not allocated with
-                                AllocatePages().
-
-**/
-typedef
-EFI_STATUS
-(EFIAPI *EFI_FREE_PAGES)(
-  IN  EFI_PHYSICAL_ADDRESS         Memory,
-  IN  UINTN                        Pages
-  );
-
-/**
-  Returns the current memory map.
-
-  @param  MemoryMapSize         A pointer to the size, in bytes, of the MemoryMap buffer.
-                                On input, this is the size of the buffer allocated by the caller.
-                                On output, it is the size of the buffer returned by the firmware if
-                                the buffer was large enough, or the size of the buffer needed to contain
-                                the map if the buffer was too small.
-  @param  MemoryMap             A pointer to the buffer in which firmware places the current memory
-                                map.
-  @param  MapKey                A pointer to the location in which firmware returns the key for the
-                                current memory map.
-  @param  DescriptorSize        A pointer to the location in which firmware returns the size, in bytes, of
-                                an individual EFI_MEMORY_DESCRIPTOR.
-  @param  DescriptorVersion     A pointer to the location in which firmware returns the version number
-                                associated with the EFI_MEMORY_DESCRIPTOR.
-
-  @retval EFI_SUCCESS           The memory map was returned in the MemoryMap buffer.
-  @retval EFI_BUFFER_TOO_SMALL  The MemoryMap buffer was too small. The current buffer size
-                                needed to hold the memory map is returned in MemoryMapSize.
-  @retval EFI_INVALID_PARAMETER 1) MemoryMapSize is NULL.
-                                2) The MemoryMap buffer is not too small and MemoryMap is
-                                   NULL.
-
-**/
-typedef
-EFI_STATUS
-(EFIAPI *EFI_GET_MEMORY_MAP)(
-  IN OUT UINTN                       *MemoryMapSize,
-  IN OUT EFI_MEMORY_DESCRIPTOR       *MemoryMap,
-  OUT    UINTN                       *MapKey,
-  OUT    UINTN                       *DescriptorSize,
-  OUT    UINT32                      *DescriptorVersion
-  );
-
-/**
-  Allocates pool memory.
-
-  @param  PoolType              The type of pool to allocate.
-  @param  Size                  The number of bytes to allocate from the pool.
-  @param  Buffer                A pointer to a pointer to the allocated buffer if the call succeeds;
-                                undefined otherwise.
-
-  @retval EFI_SUCCESS           The requested number of bytes was allocated.
-  @retval EFI_OUT_OF_RESOURCES  The pool requested could not be allocated.
-  @retval EFI_INVALID_PARAMETER PoolType was invalid or Buffer is NULL.
-
-**/
-typedef
-EFI_STATUS
-(EFIAPI *EFI_ALLOCATE_POOL)(
-  IN  EFI_MEMORY_TYPE              PoolType,
-  IN  UINTN                        Size,
-  OUT VOID                         **Buffer
-  );
-
-/**
-  Returns pool memory to the system.
-
-  @param  Buffer                The pointer to the buffer to free.
-
-  @retval EFI_SUCCESS           The memory was returned to the system.
-  @retval EFI_INVALID_PARAMETER Buffer was invalid.
-
-**/
-typedef
-EFI_STATUS
-(EFIAPI *EFI_FREE_POOL)(
-  IN  VOID                         *Buffer
-  );
-
-/**
-  Changes the runtime addressing mode of EFI firmware from physical to virtual.
-
-  @param  MemoryMapSize         The size in bytes of VirtualMap.
-  @param  DescriptorSize        The size in bytes of an entry in the VirtualMap.
-  @param  DescriptorVersion     The version of the structure entries in VirtualMap.
-  @param  VirtualMap            An array of memory descriptors which contain new virtual
-                                address mapping information for all runtime ranges.
-
-  @retval EFI_SUCCESS           The virtual address map has been applied.
-  @retval EFI_UNSUPPORTED       EFI firmware is not at runtime, or the EFI firmware is already in
-                                virtual address mapped mode.
-  @retval EFI_INVALID_PARAMETER DescriptorSize or DescriptorVersion is invalid.
-  @retval EFI_NO_MAPPING        A virtual address was not supplied for a range in the memory
-                                map that requires a mapping.
-  @retval EFI_NOT_FOUND         A virtual address was supplied for an address that is not found
-                                in the memory map.
-
-**/
-typedef
-EFI_STATUS
-(EFIAPI *EFI_SET_VIRTUAL_ADDRESS_MAP)(
-  IN  UINTN                        MemoryMapSize,
-  IN  UINTN                        DescriptorSize,
-  IN  UINT32                       DescriptorVersion,
-  IN  EFI_MEMORY_DESCRIPTOR        *VirtualMap
-  );
-
-/**
-  Connects one or more drivers to a controller.
-
-  @param  ControllerHandle      The handle of the controller to which driver(s) are to be connected.
-  @param  DriverImageHandle     A pointer to an ordered list handles that support the
-                                EFI_DRIVER_BINDING_PROTOCOL.
-  @param  RemainingDevicePath   A pointer to the device path that specifies a child of the
-                                controller specified by ControllerHandle.
-  @param  Recursive             If TRUE, then ConnectController() is called recursively
-                                until the entire tree of controllers below the controller specified
-                                by ControllerHandle have been created. If FALSE, then
-                                the tree of controllers is only expanded one level.
-
-  @retval EFI_SUCCESS           1) One or more drivers were connected to ControllerHandle.
-                                2) No drivers were connected to ControllerHandle, but
-                                RemainingDevicePath is not NULL, and it is an End Device
-                                Path Node.
-  @retval EFI_INVALID_PARAMETER ControllerHandle is NULL.
-  @retval EFI_NOT_FOUND         1) There are no EFI_DRIVER_BINDING_PROTOCOL instances
-                                present in the system.
-                                2) No drivers were connected to ControllerHandle.
-  @retval EFI_SECURITY_VIOLATION
-                                The user has no permission to start UEFI device drivers on the device path
-                                associated with the ControllerHandle or specified by the RemainingDevicePath.
-**/
-typedef
-EFI_STATUS
-(EFIAPI *EFI_CONNECT_CONTROLLER)(
-  IN  EFI_HANDLE                    ControllerHandle,
-  IN  EFI_HANDLE                    *DriverImageHandle,   OPTIONAL
-  IN  EFI_DEVICE_PATH_PROTOCOL      *RemainingDevicePath, OPTIONAL
-  IN  BOOLEAN                       Recursive
-  );
-
-/**
-  Disconnects one or more drivers from a controller.
-
-  @param  ControllerHandle      The handle of the controller from which driver(s) are to be disconnected.
-  @param  DriverImageHandle     The driver to disconnect from ControllerHandle.
-                                If DriverImageHandle is NULL, then all the drivers currently managing
-                                ControllerHandle are disconnected from ControllerHandle.
-  @param  ChildHandle           The handle of the child to destroy.
-                                If ChildHandle is NULL, then all the children of ControllerHandle are
-                                destroyed before the drivers are disconnected from ControllerHandle.
-
-  @retval EFI_SUCCESS           1) One or more drivers were disconnected from the controller.
-                                2) On entry, no drivers are managing ControllerHandle.
-                                3) DriverImageHandle is not NULL, and on entry
-                                   DriverImageHandle is not managing ControllerHandle.
-  @retval EFI_INVALID_PARAMETER 1) ControllerHandle is NULL.
-                                2) DriverImageHandle is not NULL, and it is not a valid EFI_HANDLE.
-                                3) ChildHandle is not NULL, and it is not a valid EFI_HANDLE.
-                                4) DriverImageHandle does not support the EFI_DRIVER_BINDING_PROTOCOL.
-  @retval EFI_OUT_OF_RESOURCES  There are not enough resources available to disconnect any drivers from
-                                ControllerHandle.
-  @retval EFI_DEVICE_ERROR      The controller could not be disconnected because of a device error.
-
-**/
-typedef
-EFI_STATUS
-(EFIAPI *EFI_DISCONNECT_CONTROLLER)(
-  IN  EFI_HANDLE                     ControllerHandle,
-  IN  EFI_HANDLE                     DriverImageHandle, OPTIONAL
-  IN  EFI_HANDLE                     ChildHandle        OPTIONAL
-  );
-
-
-
-//
-// ConvertPointer DebugDisposition type.
-//
-#define EFI_OPTIONAL_PTR     0x00000001
-
-/**
-  Determines the new virtual address that is to be used on subsequent memory accesses.
-
-  @param  DebugDisposition      Supplies type information for the pointer being converted.
-  @param  Address               A pointer to a pointer that is to be fixed to be the value needed
-                                for the new virtual address mappings being applied.
-
-  @retval EFI_SUCCESS           The pointer pointed to by Address was modified.
-  @retval EFI_INVALID_PARAMETER 1) Address is NULL.
-                                2) *Address is NULL and DebugDisposition does
-                                not have the EFI_OPTIONAL_PTR bit set.
-  @retval EFI_NOT_FOUND         The pointer pointed to by Address was not found to be part
-                                of the current memory map. This is normally fatal.
-
-**/
-typedef
-EFI_STATUS
-(EFIAPI *EFI_CONVERT_POINTER)(
-  IN     UINTN                      DebugDisposition,
-  IN OUT VOID                       **Address
-  );
-
-
-//
-// These types can be ORed together as needed - for example,
-// EVT_TIMER might be Ored with EVT_NOTIFY_WAIT or
-// EVT_NOTIFY_SIGNAL.
-//
-#define EVT_TIMER                         0x80000000
-#define EVT_RUNTIME                       0x40000000
-#define EVT_NOTIFY_WAIT                   0x00000100
-#define EVT_NOTIFY_SIGNAL                 0x00000200
-
-#define EVT_SIGNAL_EXIT_BOOT_SERVICES     0x00000201
-#define EVT_SIGNAL_VIRTUAL_ADDRESS_CHANGE 0x60000202
-
-//
-// The event's NotifyContext pointer points to a runtime memory
-// address.
-// The event is deprecated in UEFI2.0 and later specifications.
-//
-#define EVT_RUNTIME_CONTEXT               0x20000000
-
-
-/**
-  Invoke a notification event
-
-  @param  Event                 Event whose notification function is being invoked.
-  @param  Context               The pointer to the notification function's context,
-                                which is implementation-dependent.
-
-**/
-typedef
-VOID
-(EFIAPI *EFI_EVENT_NOTIFY)(
-  IN  EFI_EVENT                Event,
-  IN  VOID                     *Context
-  );
-
-/**
-  Creates an event.
-
-  @param  Type                  The type of event to create and its mode and attributes.
-  @param  NotifyTpl             The task priority level of event notifications, if needed.
-  @param  NotifyFunction        The pointer to the event's notification function, if any.
-  @param  NotifyContext         The pointer to the notification function's context; corresponds to parameter
-                                Context in the notification function.
-  @param  Event                 The pointer to the newly created event if the call succeeds; undefined
-                                otherwise.
-
-  @retval EFI_SUCCESS           The event structure was created.
-  @retval EFI_INVALID_PARAMETER One or more parameters are invalid.
-  @retval EFI_OUT_OF_RESOURCES  The event could not be allocated.
-
-**/
-typedef
-EFI_STATUS
-(EFIAPI *EFI_CREATE_EVENT)(
-  IN  UINT32                       Type,
-  IN  EFI_TPL                      NotifyTpl,
-  IN  EFI_EVENT_NOTIFY             NotifyFunction,
-  IN  VOID                         *NotifyContext,
-  OUT EFI_EVENT                    *Event
-  );
-
-/**
-  Creates an event in a group.
-
-  @param  Type                  The type of event to create and its mode and attributes.
-  @param  NotifyTpl             The task priority level of event notifications,if needed.
-  @param  NotifyFunction        The pointer to the event's notification function, if any.
-  @param  NotifyContext         The pointer to the notification function's context; corresponds to parameter
-                                Context in the notification function.
-  @param  EventGroup            The pointer to the unique identifier of the group to which this event belongs.
-                                If this is NULL, then the function behaves as if the parameters were passed
-                                to CreateEvent.
-  @param  Event                 The pointer to the newly created event if the call succeeds; undefined
-                                otherwise.
-
-  @retval EFI_SUCCESS           The event structure was created.
-  @retval EFI_INVALID_PARAMETER One or more parameters are invalid.
-  @retval EFI_OUT_OF_RESOURCES  The event could not be allocated.
-
-**/
-typedef
-EFI_STATUS
-(EFIAPI *EFI_CREATE_EVENT_EX)(
-  IN       UINT32                 Type,
-  IN       EFI_TPL                NotifyTpl,
-  IN       EFI_EVENT_NOTIFY       NotifyFunction OPTIONAL,
-  IN CONST VOID                   *NotifyContext OPTIONAL,
-  IN CONST EFI_GUID               *EventGroup    OPTIONAL,
-  OUT      EFI_EVENT              *Event
-  );
-
-///
-/// Timer delay types
-///
-typedef enum {
-  ///
-  /// An event's timer settings is to be cancelled and not trigger time is to be set/
-  ///
-  TimerCancel,
-  ///
-  /// An event is to be signaled periodically at a specified interval from the current time.
-  ///
-  TimerPeriodic,
-  ///
-  /// An event is to be signaled once at a specified interval from the current time.
-  ///
-  TimerRelative
-} EFI_TIMER_DELAY;
-
-/**
-  Sets the type of timer and the trigger time for a timer event.
-
-  @param  Event                 The timer event that is to be signaled at the specified time.
-  @param  Type                  The type of time that is specified in TriggerTime.
-  @param  TriggerTime           The number of 100ns units until the timer expires.
-                                A TriggerTime of 0 is legal.
-                                If Type is TimerRelative and TriggerTime is 0, then the timer
-                                event will be signaled on the next timer tick.
-                                If Type is TimerPeriodic and TriggerTime is 0, then the timer
-                                event will be signaled on every timer tick.
-
-  @retval EFI_SUCCESS           The event has been set to be signaled at the requested time.
-  @retval EFI_INVALID_PARAMETER Event or Type is not valid.
-
-**/
-typedef
-EFI_STATUS
-(EFIAPI *EFI_SET_TIMER)(
-  IN  EFI_EVENT                Event,
-  IN  EFI_TIMER_DELAY          Type,
-  IN  UINT64                   TriggerTime
-  );
-
-/**
-  Signals an event.
-
-  @param  Event                 The event to signal.
-
-  @retval EFI_SUCCESS           The event has been signaled.
-
-**/
-typedef
-EFI_STATUS
-(EFIAPI *EFI_SIGNAL_EVENT)(
-  IN  EFI_EVENT                Event
-  );
-
-/**
-  Stops execution until an event is signaled.
-
-  @param  NumberOfEvents        The number of events in the Event array.
-  @param  Event                 An array of EFI_EVENT.
-  @param  Index                 The pointer to the index of the event which satisfied the wait condition.
-
-  @retval EFI_SUCCESS           The event indicated by Index was signaled.
-  @retval EFI_INVALID_PARAMETER 1) NumberOfEvents is 0.
-                                2) The event indicated by Index is of type
-                                   EVT_NOTIFY_SIGNAL.
-  @retval EFI_UNSUPPORTED       The current TPL is not TPL_APPLICATION.
-
-**/
-typedef
-EFI_STATUS
-(EFIAPI *EFI_WAIT_FOR_EVENT)(
-  IN  UINTN                    NumberOfEvents,
-  IN  EFI_EVENT                *Event,
-  OUT UINTN                    *Index
-  );
-
-/**
-  Closes an event.
-
-  @param  Event                 The event to close.
-
-  @retval EFI_SUCCESS           The event has been closed.
-
-**/
-typedef
-EFI_STATUS
-(EFIAPI *EFI_CLOSE_EVENT)(
-  IN EFI_EVENT                Event
-  );
-
-/**
-  Checks whether an event is in the signaled state.
-
-  @param  Event                 The event to check.
-
-  @retval EFI_SUCCESS           The event is in the signaled state.
-  @retval EFI_NOT_READY         The event is not in the signaled state.
-  @retval EFI_INVALID_PARAMETER Event is of type EVT_NOTIFY_SIGNAL.
-
-**/
-typedef
-EFI_STATUS
-(EFIAPI *EFI_CHECK_EVENT)(
-  IN EFI_EVENT                Event
-  );
-
-
-//
-// Task priority level
-//
-#define TPL_APPLICATION       4
-#define TPL_CALLBACK          8
-#define TPL_NOTIFY            16
-#define TPL_HIGH_LEVEL        31
-
-
-/**
-  Raises a task's priority level and returns its previous level.
-
-  @param  NewTpl                The new task priority level.
-
-  @return Previous task priority level
-
-**/
-typedef
-EFI_TPL
-(EFIAPI *EFI_RAISE_TPL)(
-  IN EFI_TPL      NewTpl
-  );
-
-/**
-  Restores a task's priority level to its previous value.
-
-  @param  OldTpl                The previous task priority level to restore.
-
-**/
-typedef
-VOID
-(EFIAPI *EFI_RESTORE_TPL)(
-  IN EFI_TPL      OldTpl
-  );
-
-/**
-  Returns the value of a variable.
-
-  @param  VariableName          A Null-terminated string that is the name of the vendor's
-                                variable.
-  @param  VendorGuid            A unique identifier for the vendor.
-  @param  Attributes            If not NULL, a pointer to the memory location to return the
-                                attributes bitmask for the variable.
-  @param  DataSize              On input, the size in bytes of the return Data buffer.
-                                On output the size of data returned in Data.
-  @param  Data                  The buffer to return the contents of the variable.
-
-  @retval EFI_SUCCESS            The function completed successfully.
-  @retval EFI_NOT_FOUND          The variable was not found.
-  @retval EFI_BUFFER_TOO_SMALL   The DataSize is too small for the result.
-  @retval EFI_INVALID_PARAMETER  VariableName is NULL.
-  @retval EFI_INVALID_PARAMETER  VendorGuid is NULL.
-  @retval EFI_INVALID_PARAMETER  DataSize is NULL.
-  @retval EFI_INVALID_PARAMETER  The DataSize is not too small and Data is NULL.
-  @retval EFI_DEVICE_ERROR       The variable could not be retrieved due to a hardware error.
-  @retval EFI_SECURITY_VIOLATION The variable could not be retrieved due to an authentication failure.
-
-**/
-typedef
-EFI_STATUS
-(EFIAPI *EFI_GET_VARIABLE)(
-  IN     CHAR16                      *VariableName,
-  IN     EFI_GUID                    *VendorGuid,
-  OUT    UINT32                      *Attributes,    OPTIONAL
-  IN OUT UINTN                       *DataSize,
-  OUT    VOID                        *Data
-  );
-
-/**
-  Enumerates the current variable names.
-
-  @param  VariableNameSize      The size of the VariableName buffer.
-  @param  VariableName          On input, supplies the last VariableName that was returned
-                                by GetNextVariableName(). On output, returns the Nullterminated
-                                string of the current variable.
-  @param  VendorGuid            On input, supplies the last VendorGuid that was returned by
-                                GetNextVariableName(). On output, returns the
-                                VendorGuid of the current variable.
-
-  @retval EFI_SUCCESS           The function completed successfully.
-  @retval EFI_NOT_FOUND         The next variable was not found.
-  @retval EFI_BUFFER_TOO_SMALL  The VariableNameSize is too small for the result.
-  @retval EFI_INVALID_PARAMETER VariableNameSize is NULL.
-  @retval EFI_INVALID_PARAMETER VariableName is NULL.
-  @retval EFI_INVALID_PARAMETER VendorGuid is NULL.
-  @retval EFI_DEVICE_ERROR      The variable could not be retrieved due to a hardware error.
-
-**/
-typedef
-EFI_STATUS
-(EFIAPI *EFI_GET_NEXT_VARIABLE_NAME)(
-  IN OUT UINTN                    *VariableNameSize,
-  IN OUT CHAR16                   *VariableName,
-  IN OUT EFI_GUID                 *VendorGuid
-  );
-
-/**
-  Sets the value of a variable.
-
-  @param  VariableName           A Null-terminated string that is the name of the vendor's variable.
-                                 Each VariableName is unique for each VendorGuid. VariableName must
-                                 contain 1 or more characters. If VariableName is an empty string,
-                                 then EFI_INVALID_PARAMETER is returned.
-  @param  VendorGuid             A unique identifier for the vendor.
-  @param  Attributes             Attributes bitmask to set for the variable.
-  @param  DataSize               The size in bytes of the Data buffer. Unless the EFI_VARIABLE_APPEND_WRITE,
-                                 EFI_VARIABLE_AUTHENTICATED_WRITE_ACCESS, or
-                                 EFI_VARIABLE_TIME_BASED_AUTHENTICATED_WRITE_ACCESS attribute is set, a size of zero
-                                 causes the variable to be deleted. When the EFI_VARIABLE_APPEND_WRITE attribute is
-                                 set, then a SetVariable() call with a DataSize of zero will not cause any change to
-                                 the variable value (the timestamp associated with the variable may be updated however
-                                 even if no new data value is provided,see the description of the
-                                 EFI_VARIABLE_AUTHENTICATION_2 descriptor below. In this case the DataSize will not
-                                 be zero since the EFI_VARIABLE_AUTHENTICATION_2 descriptor will be populated).
-  @param  Data                   The contents for the variable.
-
-  @retval EFI_SUCCESS            The firmware has successfully stored the variable and its data as
-                                 defined by the Attributes.
-  @retval EFI_INVALID_PARAMETER  An invalid combination of attribute bits, name, and GUID was supplied, or the
-                                 DataSize exceeds the maximum allowed.
-  @retval EFI_INVALID_PARAMETER  VariableName is an empty string.
-  @retval EFI_OUT_OF_RESOURCES   Not enough storage is available to hold the variable and its data.
-  @retval EFI_DEVICE_ERROR       The variable could not be retrieved due to a hardware error.
-  @retval EFI_WRITE_PROTECTED    The variable in question is read-only.
-  @retval EFI_WRITE_PROTECTED    The variable in question cannot be deleted.
-  @retval EFI_SECURITY_VIOLATION The variable could not be written due to EFI_VARIABLE_AUTHENTICATED_WRITE_ACCESS
-                                 or EFI_VARIABLE_TIME_BASED_AUTHENTICATED_WRITE_ACESS being set, but the AuthInfo
-                                 does NOT pass the validation check carried out by the firmware.
-
-  @retval EFI_NOT_FOUND          The variable trying to be updated or deleted was not found.
-
-**/
-typedef
-EFI_STATUS
-(EFIAPI *EFI_SET_VARIABLE)(
-  IN  CHAR16                       *VariableName,
-  IN  EFI_GUID                     *VendorGuid,
-  IN  UINT32                       Attributes,
-  IN  UINTN                        DataSize,
-  IN  VOID                         *Data
-  );
-
-
-///
-/// This provides the capabilities of the
-/// real time clock device as exposed through the EFI interfaces.
-///
-typedef struct {
-  ///
-  /// Provides the reporting resolution of the real-time clock device in
-  /// counts per second. For a normal PC-AT CMOS RTC device, this
-  /// value would be 1 Hz, or 1, to indicate that the device only reports
-  /// the time to the resolution of 1 second.
-  ///
-  UINT32    Resolution;
-  ///
-  /// Provides the timekeeping accuracy of the real-time clock in an
-  /// error rate of 1E-6 parts per million. For a clock with an accuracy
-  /// of 50 parts per million, the value in this field would be
-  /// 50,000,000.
-  ///
-  UINT32    Accuracy;
-  ///
-  /// A TRUE indicates that a time set operation clears the device's
-  /// time below the Resolution reporting level. A FALSE
-  /// indicates that the state below the Resolution level of the
-  /// device is not cleared when the time is set. Normal PC-AT CMOS
-  /// RTC devices set this value to FALSE.
-  ///
-  BOOLEAN   SetsToZero;
-} EFI_TIME_CAPABILITIES;
-
-/**
-  Returns the current time and date information, and the time-keeping capabilities
-  of the hardware platform.
-
-  @param  Time                  A pointer to storage to receive a snapshot of the current time.
-  @param  Capabilities          An optional pointer to a buffer to receive the real time clock
-                                device's capabilities.
-
-  @retval EFI_SUCCESS           The operation completed successfully.
-  @retval EFI_INVALID_PARAMETER Time is NULL.
-  @retval EFI_DEVICE_ERROR      The time could not be retrieved due to hardware error.
-
-**/
-typedef
-EFI_STATUS
-(EFIAPI *EFI_GET_TIME)(
-  OUT  EFI_TIME                    *Time,
-  OUT  EFI_TIME_CAPABILITIES       *Capabilities OPTIONAL
-  );
-
-/**
-  Sets the current local time and date information.
-
-  @param  Time                  A pointer to the current time.
-
-  @retval EFI_SUCCESS           The operation completed successfully.
-  @retval EFI_INVALID_PARAMETER A time field is out of range.
-  @retval EFI_DEVICE_ERROR      The time could not be set due due to hardware error.
-
-**/
-typedef
-EFI_STATUS
-(EFIAPI *EFI_SET_TIME)(
-  IN  EFI_TIME                     *Time
-  );
-
-/**
-  Returns the current wakeup alarm clock setting.
-
-  @param  Enabled               Indicates if the alarm is currently enabled or disabled.
-  @param  Pending               Indicates if the alarm signal is pending and requires acknowledgement.
-  @param  Time                  The current alarm setting.
-
-  @retval EFI_SUCCESS           The alarm settings were returned.
-  @retval EFI_INVALID_PARAMETER Enabled is NULL.
-  @retval EFI_INVALID_PARAMETER Pending is NULL.
-  @retval EFI_INVALID_PARAMETER Time is NULL.
-  @retval EFI_DEVICE_ERROR      The wakeup time could not be retrieved due to a hardware error.
-  @retval EFI_UNSUPPORTED       A wakeup timer is not supported on this platform.
-
-**/
-typedef
-EFI_STATUS
-(EFIAPI *EFI_GET_WAKEUP_TIME)(
-  OUT BOOLEAN                     *Enabled,
-  OUT BOOLEAN                     *Pending,
-  OUT EFI_TIME                    *Time
-  );
-
-/**
-  Sets the system wakeup alarm clock time.
-
-  @param  Enabled               Enable or disable the wakeup alarm.
-  @param  Time                  If Enable is TRUE, the time to set the wakeup alarm for.
-                                If Enable is FALSE, then this parameter is optional, and may be NULL.
-
-  @retval EFI_SUCCESS           If Enable is TRUE, then the wakeup alarm was enabled. If
-                                Enable is FALSE, then the wakeup alarm was disabled.
-  @retval EFI_INVALID_PARAMETER A time field is out of range.
-  @retval EFI_DEVICE_ERROR      The wakeup time could not be set due to a hardware error.
-  @retval EFI_UNSUPPORTED       A wakeup timer is not supported on this platform.
-
-**/
-typedef
-EFI_STATUS
-(EFIAPI *EFI_SET_WAKEUP_TIME)(
-  IN  BOOLEAN                      Enable,
-  IN  EFI_TIME                     *Time   OPTIONAL
-  );
-
-/**
-  Loads an EFI image into memory.
-
-  @param  BootPolicy            If TRUE, indicates that the request originates from the boot
-                                manager, and that the boot manager is attempting to load
-                                FilePath as a boot selection. Ignored if SourceBuffer is
-                                not NULL.
-  @param  ParentImageHandle     The caller's image handle.
-  @param  DevicePath            The DeviceHandle specific file path from which the image is
-                                loaded.
-  @param  SourceBuffer          If not NULL, a pointer to the memory location containing a copy
-                                of the image to be loaded.
-  @param  SourceSize            The size in bytes of SourceBuffer. Ignored if SourceBuffer is NULL.
-  @param  ImageHandle           The pointer to the returned image handle that is created when the
-                                image is successfully loaded.
-
-  @retval EFI_SUCCESS           Image was loaded into memory correctly.
-  @retval EFI_NOT_FOUND         Both SourceBuffer and DevicePath are NULL.
-  @retval EFI_INVALID_PARAMETER One or more parametes are invalid.
-  @retval EFI_UNSUPPORTED       The image type is not supported.
-  @retval EFI_OUT_OF_RESOURCES  Image was not loaded due to insufficient resources.
-  @retval EFI_LOAD_ERROR        Image was not loaded because the image format was corrupt or not
-                                understood.
-  @retval EFI_DEVICE_ERROR      Image was not loaded because the device returned a read error.
-  @retval EFI_ACCESS_DENIED     Image was not loaded because the platform policy prohibits the
-                                image from being loaded. NULL is returned in *ImageHandle.
-  @retval EFI_SECURITY_VIOLATION Image was loaded and an ImageHandle was created with a
-                                valid EFI_LOADED_IMAGE_PROTOCOL. However, the current
-                                platform policy specifies that the image should not be started.
-**/
-typedef
-EFI_STATUS
-(EFIAPI *EFI_IMAGE_LOAD)(
-  IN  BOOLEAN                      BootPolicy,
-  IN  EFI_HANDLE                   ParentImageHandle,
-  IN  EFI_DEVICE_PATH_PROTOCOL     *DevicePath,
-  IN  VOID                         *SourceBuffer OPTIONAL,
-  IN  UINTN                        SourceSize,
-  OUT EFI_HANDLE                   *ImageHandle
-  );
-
-/**
-  Transfers control to a loaded image's entry point.
-
-  @param  ImageHandle           Handle of image to be started.
-  @param  ExitDataSize          The pointer to the size, in bytes, of ExitData.
-  @param  ExitData              The pointer to a pointer to a data buffer that includes a Null-terminated
-                                string, optionally followed by additional binary data.
-
-  @retval EFI_INVALID_PARAMETER  ImageHandle is either an invalid image handle or the image
-                                 has already been initialized with StartImage.
-  @retval EFI_SECURITY_VIOLATION The current platform policy specifies that the image should not be started.
-  @return Exit code from image
-
-**/
-typedef
-EFI_STATUS
-(EFIAPI *EFI_IMAGE_START)(
-  IN  EFI_HANDLE                  ImageHandle,
-  OUT UINTN                       *ExitDataSize,
-  OUT CHAR16                      **ExitData    OPTIONAL
-  );
-
-/**
-  Terminates a loaded EFI image and returns control to boot services.
-
-  @param  ImageHandle           Handle that identifies the image. This parameter is passed to the
-                                image on entry.
-  @param  ExitStatus            The image's exit code.
-  @param  ExitDataSize          The size, in bytes, of ExitData. Ignored if ExitStatus is EFI_SUCCESS.
-  @param  ExitData              The pointer to a data buffer that includes a Null-terminated string,
-                                optionally followed by additional binary data. The string is a
-                                description that the caller may use to further indicate the reason
-                                for the image's exit. ExitData is only valid if ExitStatus
-                                is something other than EFI_SUCCESS. The ExitData buffer
-                                must be allocated by calling AllocatePool().
-
-  @retval EFI_SUCCESS           The image specified by ImageHandle was unloaded.
-  @retval EFI_INVALID_PARAMETER The image specified by ImageHandle has been loaded and
-                                started with LoadImage() and StartImage(), but the
-                                image is not the currently executing image.
-
-**/
-typedef
-EFI_STATUS
-(EFIAPI *EFI_EXIT)(
-  IN  EFI_HANDLE                   ImageHandle,
-  IN  EFI_STATUS                   ExitStatus,
-  IN  UINTN                        ExitDataSize,
-  IN  CHAR16                       *ExitData     OPTIONAL
-  );
-
-/**
-  Unloads an image.
-
-  @param  ImageHandle           Handle that identifies the image to be unloaded.
-
-  @retval EFI_SUCCESS           The image has been unloaded.
-  @retval EFI_INVALID_PARAMETER ImageHandle is not a valid image handle.
-
-**/
-typedef
-EFI_STATUS
-(EFIAPI *EFI_IMAGE_UNLOAD)(
-  IN  EFI_HANDLE                   ImageHandle
-  );
-
-/**
-  Terminates all boot services.
-
-  @param  ImageHandle           Handle that identifies the exiting image.
-  @param  MapKey                Key to the latest memory map.
-
-  @retval EFI_SUCCESS           Boot services have been terminated.
-  @retval EFI_INVALID_PARAMETER MapKey is incorrect.
-
-**/
-typedef
-EFI_STATUS
-(EFIAPI *EFI_EXIT_BOOT_SERVICES)(
-  IN  EFI_HANDLE                   ImageHandle,
-  IN  UINTN                        MapKey
-  );
-
-/**
-  Induces a fine-grained stall.
-
-  @param  Microseconds          The number of microseconds to stall execution.
-
-  @retval EFI_SUCCESS           Execution was stalled at least the requested number of
-                                Microseconds.
-
-**/
-typedef
-EFI_STATUS
-(EFIAPI *EFI_STALL)(
-  IN  UINTN                    Microseconds
-  );
-
-/**
-  Sets the system's watchdog timer.
-
-  @param  Timeout               The number of seconds to set the watchdog timer to.
-  @param  WatchdogCode          The numeric code to log on a watchdog timer timeout event.
-  @param  DataSize              The size, in bytes, of WatchdogData.
-  @param  WatchdogData          A data buffer that includes a Null-terminated string, optionally
-                                followed by additional binary data.
-
-  @retval EFI_SUCCESS           The timeout has been set.
-  @retval EFI_INVALID_PARAMETER The supplied WatchdogCode is invalid.
-  @retval EFI_UNSUPPORTED       The system does not have a watchdog timer.
-  @retval EFI_DEVICE_ERROR      The watchdog timer could not be programmed due to a hardware
-                                error.
-
-**/
-typedef
-EFI_STATUS
-(EFIAPI *EFI_SET_WATCHDOG_TIMER)(
-  IN UINTN                    Timeout,
-  IN UINT64                   WatchdogCode,
-  IN UINTN                    DataSize,
-  IN CHAR16                   *WatchdogData OPTIONAL
-  );
-
-///
-/// Enumeration of reset types.
-///
-typedef enum {
-  ///
-  /// Used to induce a system-wide reset. This sets all circuitry within the
-  /// system to its initial state.  This type of reset is asynchronous to system
-  /// operation and operates withgout regard to cycle boundaries.  EfiColdReset
-  /// is tantamount to a system power cycle.
-  ///
-  EfiResetCold,
-  ///
-  /// Used to induce a system-wide initialization. The processors are set to their
-  /// initial state, and pending cycles are not corrupted.  If the system does
-  /// not support this reset type, then an EfiResetCold must be performed.
-  ///
-  EfiResetWarm,
-  ///
-  /// Used to induce an entry into a power state equivalent to the ACPI G2/S5 or G3
-  /// state.  If the system does not support this reset type, then when the system
-  /// is rebooted, it should exhibit the EfiResetCold attributes.
-  ///
-  EfiResetShutdown,
-  ///
-  /// Used to induce a system-wide reset. The exact type of the reset is defined by
-  /// the EFI_GUID that follows the Null-terminated Unicode string passed into
-  /// ResetData. If the platform does not recognize the EFI_GUID in ResetData the
-  /// platform must pick a supported reset type to perform. The platform may
-  /// optionally log the parameters from any non-normal reset that occurs.
-  ///
-  EfiResetPlatformSpecific
-} EFI_RESET_TYPE;
-
-/**
-  Resets the entire platform.
-
-  @param  ResetType             The type of reset to perform.
-  @param  ResetStatus           The status code for the reset.
-  @param  DataSize              The size, in bytes, of WatchdogData.
-  @param  ResetData             For a ResetType of EfiResetCold, EfiResetWarm, or
-                                EfiResetShutdown the data buffer starts with a Null-terminated
-                                string, optionally followed by additional binary data.
-
-**/
-typedef
-VOID
-(EFIAPI *EFI_RESET_SYSTEM)(
-  IN EFI_RESET_TYPE           ResetType,
-  IN EFI_STATUS               ResetStatus,
-  IN UINTN                    DataSize,
-  IN VOID                     *ResetData OPTIONAL
-  );
-
-/**
-  Returns a monotonically increasing count for the platform.
-
-  @param  Count                 The pointer to returned value.
-
-  @retval EFI_SUCCESS           The next monotonic count was returned.
-  @retval EFI_INVALID_PARAMETER Count is NULL.
-  @retval EFI_DEVICE_ERROR      The device is not functioning properly.
-
-**/
-typedef
-EFI_STATUS
-(EFIAPI *EFI_GET_NEXT_MONOTONIC_COUNT)(
-  OUT UINT64                  *Count
-  );
-
-/**
-  Returns the next high 32 bits of the platform's monotonic counter.
-
-  @param  HighCount             The pointer to returned value.
-
-  @retval EFI_SUCCESS           The next high monotonic count was returned.
-  @retval EFI_INVALID_PARAMETER HighCount is NULL.
-  @retval EFI_DEVICE_ERROR      The device is not functioning properly.
-
-**/
-typedef
-EFI_STATUS
-(EFIAPI *EFI_GET_NEXT_HIGH_MONO_COUNT)(
-  OUT UINT32                  *HighCount
-  );
-
-/**
-  Computes and returns a 32-bit CRC for a data buffer.
-
-  @param  Data                  A pointer to the buffer on which the 32-bit CRC is to be computed.
-  @param  DataSize              The number of bytes in the buffer Data.
-  @param  Crc32                 The 32-bit CRC that was computed for the data buffer specified by Data
-                                and DataSize.
-
-  @retval EFI_SUCCESS           The 32-bit CRC was computed for the data buffer and returned in
-                                Crc32.
-  @retval EFI_INVALID_PARAMETER Data is NULL.
-  @retval EFI_INVALID_PARAMETER Crc32 is NULL.
-  @retval EFI_INVALID_PARAMETER DataSize is 0.
-
-**/
-typedef
-EFI_STATUS
-(EFIAPI *EFI_CALCULATE_CRC32)(
-  IN  VOID                              *Data,
-  IN  UINTN                             DataSize,
-  OUT UINT32                            *Crc32
-  );
-
-/**
-  Copies the contents of one buffer to another buffer.
-
-  @param  Destination           The pointer to the destination buffer of the memory copy.
-  @param  Source                The pointer to the source buffer of the memory copy.
-  @param  Length                Number of bytes to copy from Source to Destination.
-
-**/
-typedef
-VOID
-(EFIAPI *EFI_COPY_MEM)(
-  IN VOID     *Destination,
-  IN VOID     *Source,
-  IN UINTN    Length
-  );
-
-/**
-  The SetMem() function fills a buffer with a specified value.
-
-  @param  Buffer                The pointer to the buffer to fill.
-  @param  Size                  Number of bytes in Buffer to fill.
-  @param  Value                 Value to fill Buffer with.
-
-**/
-typedef
-VOID
-(EFIAPI *EFI_SET_MEM)(
-  IN VOID     *Buffer,
-  IN UINTN    Size,
-  IN UINT8    Value
-  );
-
-///
-/// Enumeration of EFI Interface Types
-///
-typedef enum {
-  ///
-  /// Indicates that the supplied protocol interface is supplied in native form.
-  ///
-  EFI_NATIVE_INTERFACE
-} EFI_INTERFACE_TYPE;
-
-/**
-  Installs a protocol interface on a device handle. If the handle does not exist, it is created and added
-  to the list of handles in the system. InstallMultipleProtocolInterfaces() performs
-  more error checking than InstallProtocolInterface(), so it is recommended that
-  InstallMultipleProtocolInterfaces() be used in place of
-  InstallProtocolInterface()
-
-  @param  Handle                A pointer to the EFI_HANDLE on which the interface is to be installed.
-  @param  Protocol              The numeric ID of the protocol interface.
-  @param  InterfaceType         Indicates whether Interface is supplied in native form.
-  @param  Interface             A pointer to the protocol interface.
-
-  @retval EFI_SUCCESS           The protocol interface was installed.
-  @retval EFI_OUT_OF_RESOURCES  Space for a new handle could not be allocated.
-  @retval EFI_INVALID_PARAMETER Handle is NULL.
-  @retval EFI_INVALID_PARAMETER Protocol is NULL.
-  @retval EFI_INVALID_PARAMETER InterfaceType is not EFI_NATIVE_INTERFACE.
-  @retval EFI_INVALID_PARAMETER Protocol is already installed on the handle specified by Handle.
-
-**/
-typedef
-EFI_STATUS
-(EFIAPI *EFI_INSTALL_PROTOCOL_INTERFACE)(
-  IN OUT EFI_HANDLE               *Handle,
-  IN     EFI_GUID                 *Protocol,
-  IN     EFI_INTERFACE_TYPE       InterfaceType,
-  IN     VOID                     *Interface
-  );
-
-/**
-  Installs one or more protocol interfaces into the boot services environment.
-
-  @param  Handle                The pointer to a handle to install the new protocol interfaces on,
-                                or a pointer to NULL if a new handle is to be allocated.
-  @param  ...                   A variable argument list containing pairs of protocol GUIDs and protocol
-                                interfaces.
-
-  @retval EFI_SUCCESS           All the protocol interface was installed.
-  @retval EFI_OUT_OF_RESOURCES  There was not enough memory in pool to install all the protocols.
-  @retval EFI_ALREADY_STARTED   A Device Path Protocol instance was passed in that is already present in
-                                the handle database.
-  @retval EFI_INVALID_PARAMETER Handle is NULL.
-  @retval EFI_INVALID_PARAMETER Protocol is already installed on the handle specified by Handle.
-
-**/
-typedef
-EFI_STATUS
-(EFIAPI *EFI_INSTALL_MULTIPLE_PROTOCOL_INTERFACES)(
-  IN OUT EFI_HANDLE           *Handle,
-  ...
-  );
-
-/**
-  Reinstalls a protocol interface on a device handle.
-
-  @param  Handle                Handle on which the interface is to be reinstalled.
-  @param  Protocol              The numeric ID of the interface.
-  @param  OldInterface          A pointer to the old interface. NULL can be used if a structure is not
-                                associated with Protocol.
-  @param  NewInterface          A pointer to the new interface.
-
-  @retval EFI_SUCCESS           The protocol interface was reinstalled.
-  @retval EFI_NOT_FOUND         The OldInterface on the handle was not found.
-  @retval EFI_ACCESS_DENIED     The protocol interface could not be reinstalled,
-                                because OldInterface is still being used by a
-                                driver that will not release it.
-  @retval EFI_INVALID_PARAMETER Handle is NULL.
-  @retval EFI_INVALID_PARAMETER Protocol is NULL.
-
-**/
-typedef
-EFI_STATUS
-(EFIAPI *EFI_REINSTALL_PROTOCOL_INTERFACE)(
-  IN EFI_HANDLE               Handle,
-  IN EFI_GUID                 *Protocol,
-  IN VOID                     *OldInterface,
-  IN VOID                     *NewInterface
-  );
-
-/**
-  Removes a protocol interface from a device handle. It is recommended that
-  UninstallMultipleProtocolInterfaces() be used in place of
-  UninstallProtocolInterface().
-
-  @param  Handle                The handle on which the interface was installed.
-  @param  Protocol              The numeric ID of the interface.
-  @param  Interface             A pointer to the interface.
-
-  @retval EFI_SUCCESS           The interface was removed.
-  @retval EFI_NOT_FOUND         The interface was not found.
-  @retval EFI_ACCESS_DENIED     The interface was not removed because the interface
-                                is still being used by a driver.
-  @retval EFI_INVALID_PARAMETER Handle is NULL.
-  @retval EFI_INVALID_PARAMETER Protocol is NULL.
-
-**/
-typedef
-EFI_STATUS
-(EFIAPI *EFI_UNINSTALL_PROTOCOL_INTERFACE)(
-  IN EFI_HANDLE               Handle,
-  IN EFI_GUID                 *Protocol,
-  IN VOID                     *Interface
-  );
-
-/**
-  Removes one or more protocol interfaces into the boot services environment.
-
-  @param  Handle                The handle to remove the protocol interfaces from.
-  @param  ...                   A variable argument list containing pairs of protocol GUIDs and
-                                protocol interfaces.
-
-  @retval EFI_SUCCESS           All the protocol interfaces were removed.
-  @retval EFI_INVALID_PARAMETER One of the protocol interfaces was not previously installed on Handle.
-
-**/
-typedef
-EFI_STATUS
-(EFIAPI *EFI_UNINSTALL_MULTIPLE_PROTOCOL_INTERFACES)(
-  IN EFI_HANDLE           Handle,
-  ...
-  );
-
-/**
-  Queries a handle to determine if it supports a specified protocol.
-
-  @param  Handle                The handle being queried.
-  @param  Protocol              The published unique identifier of the protocol.
-  @param  Interface             Supplies the address where a pointer to the corresponding Protocol
-                                Interface is returned.
-
-  @retval EFI_SUCCESS           The interface information for the specified protocol was returned.
-  @retval EFI_UNSUPPORTED       The device does not support the specified protocol.
-  @retval EFI_INVALID_PARAMETER Handle is NULL.
-  @retval EFI_INVALID_PARAMETER Protocol is NULL.
-  @retval EFI_INVALID_PARAMETER Interface is NULL.
-
-**/
-typedef
-EFI_STATUS
-(EFIAPI *EFI_HANDLE_PROTOCOL)(
-  IN  EFI_HANDLE               Handle,
-  IN  EFI_GUID                 *Protocol,
-  OUT VOID                     **Interface
-  );
-
-#define EFI_OPEN_PROTOCOL_BY_HANDLE_PROTOCOL  0x00000001
-#define EFI_OPEN_PROTOCOL_GET_PROTOCOL        0x00000002
-#define EFI_OPEN_PROTOCOL_TEST_PROTOCOL       0x00000004
-#define EFI_OPEN_PROTOCOL_BY_CHILD_CONTROLLER 0x00000008
-#define EFI_OPEN_PROTOCOL_BY_DRIVER           0x00000010
-#define EFI_OPEN_PROTOCOL_EXCLUSIVE           0x00000020
-
-/**
-  Queries a handle to determine if it supports a specified protocol. If the protocol is supported by the
-  handle, it opens the protocol on behalf of the calling agent.
-
-  @param  Handle                The handle for the protocol interface that is being opened.
-  @param  Protocol              The published unique identifier of the protocol.
-  @param  Interface             Supplies the address where a pointer to the corresponding Protocol
-                                Interface is returned.
-  @param  AgentHandle           The handle of the agent that is opening the protocol interface
-                                specified by Protocol and Interface.
-  @param  ControllerHandle      If the agent that is opening a protocol is a driver that follows the
-                                UEFI Driver Model, then this parameter is the controller handle
-                                that requires the protocol interface. If the agent does not follow
-                                the UEFI Driver Model, then this parameter is optional and may
-                                be NULL.
-  @param  Attributes            The open mode of the protocol interface specified by Handle
-                                and Protocol.
-
-  @retval EFI_SUCCESS           An item was added to the open list for the protocol interface, and the
-                                protocol interface was returned in Interface.
-  @retval EFI_UNSUPPORTED       Handle does not support Protocol.
-  @retval EFI_INVALID_PARAMETER One or more parameters are invalid.
-  @retval EFI_ACCESS_DENIED     Required attributes can't be supported in current environment.
-  @retval EFI_ALREADY_STARTED   Item on the open list already has requierd attributes whose agent
-                                handle is the same as AgentHandle.
-
-**/
-typedef
-EFI_STATUS
-(EFIAPI *EFI_OPEN_PROTOCOL)(
-  IN  EFI_HANDLE                Handle,
-  IN  EFI_GUID                  *Protocol,
-  OUT VOID                      **Interface, OPTIONAL
-  IN  EFI_HANDLE                AgentHandle,
-  IN  EFI_HANDLE                ControllerHandle,
-  IN  UINT32                    Attributes
-  );
-
-
-/**
-  Closes a protocol on a handle that was opened using OpenProtocol().
-
-  @param  Handle                The handle for the protocol interface that was previously opened
-                                with OpenProtocol(), and is now being closed.
-  @param  Protocol              The published unique identifier of the protocol.
-  @param  AgentHandle           The handle of the agent that is closing the protocol interface.
-  @param  ControllerHandle      If the agent that opened a protocol is a driver that follows the
-                                UEFI Driver Model, then this parameter is the controller handle
-                                that required the protocol interface.
-
-  @retval EFI_SUCCESS           The protocol instance was closed.
-  @retval EFI_INVALID_PARAMETER 1) Handle is NULL.
-                                2) AgentHandle is NULL.
-                                3) ControllerHandle is not NULL and ControllerHandle is not a valid EFI_HANDLE.
-                                4) Protocol is NULL.
-  @retval EFI_NOT_FOUND         1) Handle does not support the protocol specified by Protocol.
-                                2) The protocol interface specified by Handle and Protocol is not
-                                   currently open by AgentHandle and ControllerHandle.
-
-**/
-typedef
-EFI_STATUS
-(EFIAPI *EFI_CLOSE_PROTOCOL)(
-  IN EFI_HANDLE               Handle,
-  IN EFI_GUID                 *Protocol,
-  IN EFI_HANDLE               AgentHandle,
-  IN EFI_HANDLE               ControllerHandle
-  );
-
-///
-/// EFI Oprn Protocol Information Entry
-///
-typedef struct {
-  EFI_HANDLE  AgentHandle;
-  EFI_HANDLE  ControllerHandle;
-  UINT32      Attributes;
-  UINT32      OpenCount;
-} EFI_OPEN_PROTOCOL_INFORMATION_ENTRY;
-
-/**
-  Retrieves the list of agents that currently have a protocol interface opened.
-
-  @param  Handle                The handle for the protocol interface that is being queried.
-  @param  Protocol              The published unique identifier of the protocol.
-  @param  EntryBuffer           A pointer to a buffer of open protocol information in the form of
-                                EFI_OPEN_PROTOCOL_INFORMATION_ENTRY structures.
-  @param  EntryCount            A pointer to the number of entries in EntryBuffer.
-
-  @retval EFI_SUCCESS           The open protocol information was returned in EntryBuffer, and the
-                                number of entries was returned EntryCount.
-  @retval EFI_OUT_OF_RESOURCES  There are not enough resources available to allocate EntryBuffer.
-  @retval EFI_NOT_FOUND         Handle does not support the protocol specified by Protocol.
-
-**/
-typedef
-EFI_STATUS
-(EFIAPI *EFI_OPEN_PROTOCOL_INFORMATION)(
-  IN  EFI_HANDLE                          Handle,
-  IN  EFI_GUID                            *Protocol,
-  OUT EFI_OPEN_PROTOCOL_INFORMATION_ENTRY **EntryBuffer,
-  OUT UINTN                               *EntryCount
-  );
-
-/**
-  Retrieves the list of protocol interface GUIDs that are installed on a handle in a buffer allocated
-  from pool.
-
-  @param  Handle                The handle from which to retrieve the list of protocol interface
-                                GUIDs.
-  @param  ProtocolBuffer        A pointer to the list of protocol interface GUID pointers that are
-                                installed on Handle.
-  @param  ProtocolBufferCount   A pointer to the number of GUID pointers present in
-                                ProtocolBuffer.
-
-  @retval EFI_SUCCESS           The list of protocol interface GUIDs installed on Handle was returned in
-                                ProtocolBuffer. The number of protocol interface GUIDs was
-                                returned in ProtocolBufferCount.
-  @retval EFI_OUT_OF_RESOURCES  There is not enough pool memory to store the results.
-  @retval EFI_INVALID_PARAMETER Handle is NULL.
-  @retval EFI_INVALID_PARAMETER Handle is not a valid EFI_HANDLE.
-  @retval EFI_INVALID_PARAMETER ProtocolBuffer is NULL.
-  @retval EFI_INVALID_PARAMETER ProtocolBufferCount is NULL.
-
-**/
-typedef
-EFI_STATUS
-(EFIAPI *EFI_PROTOCOLS_PER_HANDLE)(
-  IN  EFI_HANDLE      Handle,
-  OUT EFI_GUID        ***ProtocolBuffer,
-  OUT UINTN           *ProtocolBufferCount
-  );
-
-/**
-  Creates an event that is to be signaled whenever an interface is installed for a specified protocol.
-
-  @param  Protocol              The numeric ID of the protocol for which the event is to be registered.
-  @param  Event                 Event that is to be signaled whenever a protocol interface is registered
-                                for Protocol.
-  @param  Registration          A pointer to a memory location to receive the registration value.
-
-  @retval EFI_SUCCESS           The notification event has been registered.
-  @retval EFI_OUT_OF_RESOURCES  Space for the notification event could not be allocated.
-  @retval EFI_INVALID_PARAMETER Protocol is NULL.
-  @retval EFI_INVALID_PARAMETER Event is NULL.
-  @retval EFI_INVALID_PARAMETER Registration is NULL.
-
-**/
-typedef
-EFI_STATUS
-(EFIAPI *EFI_REGISTER_PROTOCOL_NOTIFY)(
-  IN  EFI_GUID                 *Protocol,
-  IN  EFI_EVENT                Event,
-  OUT VOID                     **Registration
-  );
-
-///
-/// Enumeration of EFI Locate Search Types
-///
-typedef enum {
-  ///
-  /// Retrieve all the handles in the handle database.
-  ///
-  AllHandles,
-  ///
-  /// Retrieve the next handle fron a RegisterProtocolNotify() event.
-  ///
-  ByRegisterNotify,
-  ///
-  /// Retrieve the set of handles from the handle database that support a
-  /// specified protocol.
-  ///
-  ByProtocol
-} EFI_LOCATE_SEARCH_TYPE;
-
-/**
-  Returns an array of handles that support a specified protocol.
-
-  @param  SearchType            Specifies which handle(s) are to be returned.
-  @param  Protocol              Specifies the protocol to search by.
-  @param  SearchKey             Specifies the search key.
-  @param  BufferSize            On input, the size in bytes of Buffer. On output, the size in bytes of
-                                the array returned in Buffer (if the buffer was large enough) or the
-                                size, in bytes, of the buffer needed to obtain the array (if the buffer was
-                                not large enough).
-  @param  Buffer                The buffer in which the array is returned.
-
-  @retval EFI_SUCCESS           The array of handles was returned.
-  @retval EFI_NOT_FOUND         No handles match the search.
-  @retval EFI_BUFFER_TOO_SMALL  The BufferSize is too small for the result.
-  @retval EFI_INVALID_PARAMETER SearchType is not a member of EFI_LOCATE_SEARCH_TYPE.
-  @retval EFI_INVALID_PARAMETER SearchType is ByRegisterNotify and SearchKey is NULL.
-  @retval EFI_INVALID_PARAMETER SearchType is ByProtocol and Protocol is NULL.
-  @retval EFI_INVALID_PARAMETER One or more matches are found and BufferSize is NULL.
-  @retval EFI_INVALID_PARAMETER BufferSize is large enough for the result and Buffer is NULL.
-
-**/
-typedef
-EFI_STATUS
-(EFIAPI *EFI_LOCATE_HANDLE)(
-  IN     EFI_LOCATE_SEARCH_TYPE   SearchType,
-  IN     EFI_GUID                 *Protocol,    OPTIONAL
-  IN     VOID                     *SearchKey,   OPTIONAL
-  IN OUT UINTN                    *BufferSize,
-  OUT    EFI_HANDLE               *Buffer
-  );
-
-/**
-  Locates the handle to a device on the device path that supports the specified protocol.
-
-  @param  Protocol              Specifies the protocol to search for.
-  @param  DevicePath            On input, a pointer to a pointer to the device path. On output, the device
-                                path pointer is modified to point to the remaining part of the device
-                                path.
-  @param  Device                A pointer to the returned device handle.
-
-  @retval EFI_SUCCESS           The resulting handle was returned.
-  @retval EFI_NOT_FOUND         No handles match the search.
-  @retval EFI_INVALID_PARAMETER Protocol is NULL.
-  @retval EFI_INVALID_PARAMETER DevicePath is NULL.
-  @retval EFI_INVALID_PARAMETER A handle matched the search and Device is NULL.
-
-**/
-typedef
-EFI_STATUS
-(EFIAPI *EFI_LOCATE_DEVICE_PATH)(
-  IN     EFI_GUID                         *Protocol,
-  IN OUT EFI_DEVICE_PATH_PROTOCOL         **DevicePath,
-  OUT    EFI_HANDLE                       *Device
-  );
-
-/**
-  Adds, updates, or removes a configuration table entry from the EFI System Table.
-
-  @param  Guid                  A pointer to the GUID for the entry to add, update, or remove.
-  @param  Table                 A pointer to the configuration table for the entry to add, update, or
-                                remove. May be NULL.
-
-  @retval EFI_SUCCESS           The (Guid, Table) pair was added, updated, or removed.
-  @retval EFI_NOT_FOUND         An attempt was made to delete a nonexistent entry.
-  @retval EFI_INVALID_PARAMETER Guid is NULL.
-  @retval EFI_OUT_OF_RESOURCES  There is not enough memory available to complete the operation.
-
-**/
-typedef
-EFI_STATUS
-(EFIAPI *EFI_INSTALL_CONFIGURATION_TABLE)(
-  IN EFI_GUID                 *Guid,
-  IN VOID                     *Table
-  );
-
-/**
-  Returns an array of handles that support the requested protocol in a buffer allocated from pool.
-
-  @param  SearchType            Specifies which handle(s) are to be returned.
-  @param  Protocol              Provides the protocol to search by.
-                                This parameter is only valid for a SearchType of ByProtocol.
-  @param  SearchKey             Supplies the search key depending on the SearchType.
-  @param  NoHandles             The number of handles returned in Buffer.
-  @param  Buffer                A pointer to the buffer to return the requested array of handles that
-                                support Protocol.
-
-  @retval EFI_SUCCESS           The array of handles was returned in Buffer, and the number of
-                                handles in Buffer was returned in NoHandles.
-  @retval EFI_NOT_FOUND         No handles match the search.
-  @retval EFI_OUT_OF_RESOURCES  There is not enough pool memory to store the matching results.
-  @retval EFI_INVALID_PARAMETER NoHandles is NULL.
-  @retval EFI_INVALID_PARAMETER Buffer is NULL.
-
-**/
-typedef
-EFI_STATUS
-(EFIAPI *EFI_LOCATE_HANDLE_BUFFER)(
-  IN     EFI_LOCATE_SEARCH_TYPE       SearchType,
-  IN     EFI_GUID                     *Protocol,      OPTIONAL
-  IN     VOID                         *SearchKey,     OPTIONAL
-  IN OUT UINTN                        *NoHandles,
-  OUT    EFI_HANDLE                   **Buffer
-  );
-
-/**
-  Returns the first protocol instance that matches the given protocol.
-
-  @param  Protocol              Provides the protocol to search for.
-  @param  Registration          Optional registration key returned from
-                                RegisterProtocolNotify().
-  @param  Interface             On return, a pointer to the first interface that matches Protocol and
-                                Registration.
-
-  @retval EFI_SUCCESS           A protocol instance matching Protocol was found and returned in
-                                Interface.
-  @retval EFI_NOT_FOUND         No protocol instances were found that match Protocol and
-                                Registration.
-  @retval EFI_INVALID_PARAMETER Interface is NULL.
-
-**/
-typedef
-EFI_STATUS
-(EFIAPI *EFI_LOCATE_PROTOCOL)(
-  IN  EFI_GUID  *Protocol,
-  IN  VOID      *Registration, OPTIONAL
-  OUT VOID      **Interface
-  );
-
-///
-/// EFI Capsule Block Descriptor
-///
-typedef struct {
-  ///
-  /// Length in bytes of the data pointed to by DataBlock/ContinuationPointer.
-  ///
-  UINT64                  Length;
-  union {
-    ///
-    /// Physical address of the data block. This member of the union is
-    /// used if Length is not equal to zero.
-    ///
-    EFI_PHYSICAL_ADDRESS  DataBlock;
-    ///
-    /// Physical address of another block of
-    /// EFI_CAPSULE_BLOCK_DESCRIPTOR structures. This
-    /// member of the union is used if Length is equal to zero. If
-    /// ContinuationPointer is zero this entry represents the end of the list.
-    ///
-    EFI_PHYSICAL_ADDRESS  ContinuationPointer;
-  } Union;
-} EFI_CAPSULE_BLOCK_DESCRIPTOR;
-
-///
-/// EFI Capsule Header.
-///
-typedef struct {
-  ///
-  /// A GUID that defines the contents of a capsule.
-  ///
-  EFI_GUID          CapsuleGuid;
-  ///
-  /// The size of the capsule header. This may be larger than the size of
-  /// the EFI_CAPSULE_HEADER since CapsuleGuid may imply
-  /// extended header entries
-  ///
-  UINT32            HeaderSize;
-  ///
-  /// Bit-mapped list describing the capsule attributes. The Flag values
-  /// of 0x0000 - 0xFFFF are defined by CapsuleGuid. Flag values
-  /// of 0x10000 - 0xFFFFFFFF are defined by this specification
-  ///
-  UINT32            Flags;
-  ///
-  /// Size in bytes of the capsule.
-  ///
-  UINT32            CapsuleImageSize;
-} EFI_CAPSULE_HEADER;
-
-///
-/// The EFI System Table entry must point to an array of capsules
-/// that contain the same CapsuleGuid value. The array must be
-/// prefixed by a UINT32 that represents the size of the array of capsules.
-///
-typedef struct {
-  ///
-  /// the size of the array of capsules.
-  ///
-  UINT32   CapsuleArrayNumber;
-  ///
-  /// Point to an array of capsules that contain the same CapsuleGuid value.
-  ///
-  VOID*    CapsulePtr[1];
-} EFI_CAPSULE_TABLE;
-
-#define CAPSULE_FLAGS_PERSIST_ACROSS_RESET          0x00010000
-#define CAPSULE_FLAGS_POPULATE_SYSTEM_TABLE         0x00020000
-#define CAPSULE_FLAGS_INITIATE_RESET                0x00040000
-
-/**
-  Passes capsules to the firmware with both virtual and physical mapping. Depending on the intended
-  consumption, the firmware may process the capsule immediately. If the payload should persist
-  across a system reset, the reset value returned from EFI_QueryCapsuleCapabilities must
-  be passed into ResetSystem() and will cause the capsule to be processed by the firmware as
-  part of the reset process.
-
-  @param  CapsuleHeaderArray    Virtual pointer to an array of virtual pointers to the capsules
-                                being passed into update capsule.
-  @param  CapsuleCount          Number of pointers to EFI_CAPSULE_HEADER in
-                                CaspuleHeaderArray.
-  @param  ScatterGatherList     Physical pointer to a set of
-                                EFI_CAPSULE_BLOCK_DESCRIPTOR that describes the
-                                location in physical memory of a set of capsules.
-
-  @retval EFI_SUCCESS           Valid capsule was passed. If
-                                CAPSULE_FLAGS_PERSIT_ACROSS_RESET is not set, the
-                                capsule has been successfully processed by the firmware.
-  @retval EFI_INVALID_PARAMETER CapsuleSize is NULL, or an incompatible set of flags were
-                                set in the capsule header.
-  @retval EFI_INVALID_PARAMETER CapsuleCount is 0.
-  @retval EFI_DEVICE_ERROR      The capsule update was started, but failed due to a device error.
-  @retval EFI_UNSUPPORTED       The capsule type is not supported on this platform.
-  @retval EFI_OUT_OF_RESOURCES  When ExitBootServices() has been previously called this error indicates the capsule
-                                is compatible with this platform but is not capable of being submitted or processed
-                                in runtime. The caller may resubmit the capsule prior to ExitBootServices().
-  @retval EFI_OUT_OF_RESOURCES  When ExitBootServices() has not been previously called then this error indicates
-                                the capsule is compatible with this platform but there are insufficient resources to process.
-
-**/
-typedef
-EFI_STATUS
-(EFIAPI *EFI_UPDATE_CAPSULE)(
-  IN EFI_CAPSULE_HEADER     **CapsuleHeaderArray,
-  IN UINTN                  CapsuleCount,
-  IN EFI_PHYSICAL_ADDRESS   ScatterGatherList   OPTIONAL
-  );
-
-/**
-  Returns if the capsule can be supported via UpdateCapsule().
-
-  @param  CapsuleHeaderArray    Virtual pointer to an array of virtual pointers to the capsules
-                                being passed into update capsule.
-  @param  CapsuleCount          Number of pointers to EFI_CAPSULE_HEADER in
-                                CaspuleHeaderArray.
-  @param  MaxiumCapsuleSize     On output the maximum size that UpdateCapsule() can
-                                support as an argument to UpdateCapsule() via
-                                CapsuleHeaderArray and ScatterGatherList.
-  @param  ResetType             Returns the type of reset required for the capsule update.
-
-  @retval EFI_SUCCESS           Valid answer returned.
-  @retval EFI_UNSUPPORTED       The capsule type is not supported on this platform, and
-                                MaximumCapsuleSize and ResetType are undefined.
-  @retval EFI_INVALID_PARAMETER MaximumCapsuleSize is NULL.
-  @retval EFI_OUT_OF_RESOURCES  When ExitBootServices() has been previously called this error indicates the capsule
-                                is compatible with this platform but is not capable of being submitted or processed
-                                in runtime. The caller may resubmit the capsule prior to ExitBootServices().
-  @retval EFI_OUT_OF_RESOURCES  When ExitBootServices() has not been previously called then this error indicates
-                                the capsule is compatible with this platform but there are insufficient resources to process.
-
-**/
-typedef
-EFI_STATUS
-(EFIAPI *EFI_QUERY_CAPSULE_CAPABILITIES)(
-  IN  EFI_CAPSULE_HEADER     **CapsuleHeaderArray,
-  IN  UINTN                  CapsuleCount,
-  OUT UINT64                 *MaximumCapsuleSize,
-  OUT EFI_RESET_TYPE         *ResetType
-  );
-
-/**
-  Returns information about the EFI variables.
-
-  @param  Attributes                   Attributes bitmask to specify the type of variables on
-                                       which to return information.
-  @param  MaximumVariableStorageSize   On output the maximum size of the storage space
-                                       available for the EFI variables associated with the
-                                       attributes specified.
-  @param  RemainingVariableStorageSize Returns the remaining size of the storage space
-                                       available for the EFI variables associated with the
-                                       attributes specified.
-  @param  MaximumVariableSize          Returns the maximum size of the individual EFI
-                                       variables associated with the attributes specified.
-
-  @retval EFI_SUCCESS                  Valid answer returned.
-  @retval EFI_INVALID_PARAMETER        An invalid combination of attribute bits was supplied
-  @retval EFI_UNSUPPORTED              The attribute is not supported on this platform, and the
-                                       MaximumVariableStorageSize,
-                                       RemainingVariableStorageSize, MaximumVariableSize
-                                       are undefined.
-
-**/
-typedef
-EFI_STATUS
-(EFIAPI *EFI_QUERY_VARIABLE_INFO)(
-  IN  UINT32            Attributes,
-  OUT UINT64            *MaximumVariableStorageSize,
-  OUT UINT64            *RemainingVariableStorageSize,
-  OUT UINT64            *MaximumVariableSize
-  );
-
-//
-// Firmware should stop at a firmware user interface on next boot
-//
-#define EFI_OS_INDICATIONS_BOOT_TO_FW_UI                    0x0000000000000001
-#define EFI_OS_INDICATIONS_TIMESTAMP_REVOCATION             0x0000000000000002
-#define EFI_OS_INDICATIONS_FILE_CAPSULE_DELIVERY_SUPPORTED  0x0000000000000004
-#define EFI_OS_INDICATIONS_FMP_CAPSULE_SUPPORTED            0x0000000000000008
-#define EFI_OS_INDICATIONS_CAPSULE_RESULT_VAR_SUPPORTED     0x0000000000000010
-
-//
-// EFI Runtime Services Table
-//
-#define EFI_SYSTEM_TABLE_SIGNATURE      SIGNATURE_64 ('I','B','I',' ','S','Y','S','T')
-#define EFI_2_40_SYSTEM_TABLE_REVISION  ((2 << 16) | (40))
-#define EFI_2_31_SYSTEM_TABLE_REVISION  ((2 << 16) | (31))
-#define EFI_2_30_SYSTEM_TABLE_REVISION  ((2 << 16) | (30))
-#define EFI_2_20_SYSTEM_TABLE_REVISION  ((2 << 16) | (20))
-#define EFI_2_10_SYSTEM_TABLE_REVISION  ((2 << 16) | (10))
-#define EFI_2_00_SYSTEM_TABLE_REVISION  ((2 << 16) | (00))
-#define EFI_1_10_SYSTEM_TABLE_REVISION  ((1 << 16) | (10))
-#define EFI_1_02_SYSTEM_TABLE_REVISION  ((1 << 16) | (02))
-#define EFI_SYSTEM_TABLE_REVISION       EFI_2_40_SYSTEM_TABLE_REVISION
-#define EFI_SPECIFICATION_VERSION       EFI_SYSTEM_TABLE_REVISION
-
-#define EFI_RUNTIME_SERVICES_SIGNATURE  SIGNATURE_64 ('R','U','N','T','S','E','R','V')
-#define EFI_RUNTIME_SERVICES_REVISION   EFI_SPECIFICATION_VERSION
-
-///
-/// EFI Runtime Services Table.
-///
-typedef struct {
-  ///
-  /// The table header for the EFI Runtime Services Table.
-  ///
-  EFI_TABLE_HEADER                Hdr;
-
-  //
-  // Time Services
-  //
-  EFI_GET_TIME                    GetTime;
-  EFI_SET_TIME                    SetTime;
-  EFI_GET_WAKEUP_TIME             GetWakeupTime;
-  EFI_SET_WAKEUP_TIME             SetWakeupTime;
-
-  //
-  // Virtual Memory Services
-  //
-  EFI_SET_VIRTUAL_ADDRESS_MAP     SetVirtualAddressMap;
-  EFI_CONVERT_POINTER             ConvertPointer;
-
-  //
-  // Variable Services
-  //
-  EFI_GET_VARIABLE                GetVariable;
-  EFI_GET_NEXT_VARIABLE_NAME      GetNextVariableName;
-  EFI_SET_VARIABLE                SetVariable;
-
-  //
-  // Miscellaneous Services
-  //
-  EFI_GET_NEXT_HIGH_MONO_COUNT    GetNextHighMonotonicCount;
-  EFI_RESET_SYSTEM                ResetSystem;
-
-  //
-  // UEFI 2.0 Capsule Services
-  //
-  EFI_UPDATE_CAPSULE              UpdateCapsule;
-  EFI_QUERY_CAPSULE_CAPABILITIES  QueryCapsuleCapabilities;
-
-  //
-  // Miscellaneous UEFI 2.0 Service
-  //
-  EFI_QUERY_VARIABLE_INFO         QueryVariableInfo;
-} EFI_RUNTIME_SERVICES;
-
-
-#define EFI_BOOT_SERVICES_SIGNATURE   SIGNATURE_64 ('B','O','O','T','S','E','R','V')
-#define EFI_BOOT_SERVICES_REVISION    EFI_SPECIFICATION_VERSION
-
-///
-/// EFI Boot Services Table.
-///
-typedef struct {
-  ///
-  /// The table header for the EFI Boot Services Table.
-  ///
-  EFI_TABLE_HEADER                Hdr;
-
-  //
-  // Task Priority Services
-  //
-  EFI_RAISE_TPL                   RaiseTPL;
-  EFI_RESTORE_TPL                 RestoreTPL;
-
-  //
-  // Memory Services
-  //
-  EFI_ALLOCATE_PAGES              AllocatePages;
-  EFI_FREE_PAGES                  FreePages;
-  EFI_GET_MEMORY_MAP              GetMemoryMap;
-  EFI_ALLOCATE_POOL               AllocatePool;
-  EFI_FREE_POOL                   FreePool;
-
-  //
-  // Event & Timer Services
-  //
-  EFI_CREATE_EVENT                  CreateEvent;
-  EFI_SET_TIMER                     SetTimer;
-  EFI_WAIT_FOR_EVENT                WaitForEvent;
-  EFI_SIGNAL_EVENT                  SignalEvent;
-  EFI_CLOSE_EVENT                   CloseEvent;
-  EFI_CHECK_EVENT                   CheckEvent;
-
-  //
-  // Protocol Handler Services
-  //
-  EFI_INSTALL_PROTOCOL_INTERFACE    InstallProtocolInterface;
-  EFI_REINSTALL_PROTOCOL_INTERFACE  ReinstallProtocolInterface;
-  EFI_UNINSTALL_PROTOCOL_INTERFACE  UninstallProtocolInterface;
-  EFI_HANDLE_PROTOCOL               HandleProtocol;
-  VOID                              *Reserved;
-  EFI_REGISTER_PROTOCOL_NOTIFY      RegisterProtocolNotify;
-  EFI_LOCATE_HANDLE                 LocateHandle;
-  EFI_LOCATE_DEVICE_PATH            LocateDevicePath;
-  EFI_INSTALL_CONFIGURATION_TABLE   InstallConfigurationTable;
-
-  //
-  // Image Services
-  //
-  EFI_IMAGE_LOAD                    LoadImage;
-  EFI_IMAGE_START                   StartImage;
-  EFI_EXIT                          Exit;
-  EFI_IMAGE_UNLOAD                  UnloadImage;
-  EFI_EXIT_BOOT_SERVICES            ExitBootServices;
-
-  //
-  // Miscellaneous Services
-  //
-  EFI_GET_NEXT_MONOTONIC_COUNT      GetNextMonotonicCount;
-  EFI_STALL                         Stall;
-  EFI_SET_WATCHDOG_TIMER            SetWatchdogTimer;
-
-  //
-  // DriverSupport Services
-  //
-  EFI_CONNECT_CONTROLLER            ConnectController;
-  EFI_DISCONNECT_CONTROLLER         DisconnectController;
-
-  //
-  // Open and Close Protocol Services
-  //
-  EFI_OPEN_PROTOCOL                 OpenProtocol;
-  EFI_CLOSE_PROTOCOL                CloseProtocol;
-  EFI_OPEN_PROTOCOL_INFORMATION     OpenProtocolInformation;
-
-  //
-  // Library Services
-  //
-  EFI_PROTOCOLS_PER_HANDLE          ProtocolsPerHandle;
-  EFI_LOCATE_HANDLE_BUFFER          LocateHandleBuffer;
-  EFI_LOCATE_PROTOCOL               LocateProtocol;
-  EFI_INSTALL_MULTIPLE_PROTOCOL_INTERFACES    InstallMultipleProtocolInterfaces;
-  EFI_UNINSTALL_MULTIPLE_PROTOCOL_INTERFACES  UninstallMultipleProtocolInterfaces;
-
-  //
-  // 32-bit CRC Services
-  //
-  EFI_CALCULATE_CRC32               CalculateCrc32;
-
-  //
-  // Miscellaneous Services
-  //
-  EFI_COPY_MEM                      CopyMem;
-  EFI_SET_MEM                       SetMem;
-  EFI_CREATE_EVENT_EX               CreateEventEx;
-} EFI_BOOT_SERVICES;
-
-///
-/// Contains a set of GUID/pointer pairs comprised of the ConfigurationTable field in the
-/// EFI System Table.
-///
-typedef struct {
-  ///
-  /// The 128-bit GUID value that uniquely identifies the system configuration table.
-  ///
-  EFI_GUID                          VendorGuid;
-  ///
-  /// A pointer to the table associated with VendorGuid.
-  ///
-  VOID                              *VendorTable;
-} EFI_CONFIGURATION_TABLE;
-
-///
-/// EFI System Table
-///
-typedef struct {
-  ///
-  /// The table header for the EFI System Table.
-  ///
-  EFI_TABLE_HEADER                  Hdr;
-  ///
-  /// A pointer to a null terminated string that identifies the vendor
-  /// that produces the system firmware for the platform.
-  ///
-  CHAR16                            *FirmwareVendor;
-  ///
-  /// A firmware vendor specific value that identifies the revision
-  /// of the system firmware for the platform.
-  ///
-  UINT32                            FirmwareRevision;
-  ///
-  /// The handle for the active console input device. This handle must support
-  /// EFI_SIMPLE_TEXT_INPUT_PROTOCOL and EFI_SIMPLE_TEXT_INPUT_EX_PROTOCOL.
-  ///
-  EFI_HANDLE                        ConsoleInHandle;
-  ///
-  /// A pointer to the EFI_SIMPLE_TEXT_INPUT_PROTOCOL interface that is
-  /// associated with ConsoleInHandle.
-  ///
-  EFI_SIMPLE_TEXT_INPUT_PROTOCOL    *ConIn;
-  ///
-  /// The handle for the active console output device.
-  ///
-  EFI_HANDLE                        ConsoleOutHandle;
-  ///
-  /// A pointer to the EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL interface
-  /// that is associated with ConsoleOutHandle.
-  ///
-  EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL   *ConOut;
-  ///
-  /// The handle for the active standard error console device.
-  /// This handle must support the EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL.
-  ///
-  EFI_HANDLE                        StandardErrorHandle;
-  ///
-  /// A pointer to the EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL interface
-  /// that is associated with StandardErrorHandle.
-  ///
-  EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL   *StdErr;
-  ///
-  /// A pointer to the EFI Runtime Services Table.
-  ///
-  EFI_RUNTIME_SERVICES              *RuntimeServices;
-  ///
-  /// A pointer to the EFI Boot Services Table.
-  ///
-  EFI_BOOT_SERVICES                 *BootServices;
-  ///
-  /// The number of system configuration tables in the buffer ConfigurationTable.
-  ///
-  UINTN                             NumberOfTableEntries;
-  ///
-  /// A pointer to the system configuration tables.
-  /// The number of entries in the table is NumberOfTableEntries.
-  ///
-  EFI_CONFIGURATION_TABLE           *ConfigurationTable;
-} EFI_SYSTEM_TABLE;
-
-/**
-  This is the declaration of an EFI image entry point. This entry point is
-  the same for UEFI Applications, UEFI OS Loaders, and UEFI Drivers including
-  both device drivers and bus drivers.
-
-  @param  ImageHandle           The firmware allocated handle for the UEFI image.
-  @param  SystemTable           A pointer to the EFI System Table.
-
-  @retval EFI_SUCCESS           The operation completed successfully.
-  @retval Others                An unexpected error occurred.
-**/
-typedef
-EFI_STATUS
-(EFIAPI *EFI_IMAGE_ENTRY_POINT)(
-  IN  EFI_HANDLE                   ImageHandle,
-  IN  EFI_SYSTEM_TABLE             *SystemTable
-  );
-
-//
-// EFI Load Options Attributes
-//
-#define LOAD_OPTION_ACTIVE            0x00000001
-#define LOAD_OPTION_FORCE_RECONNECT   0x00000002
-#define LOAD_OPTION_HIDDEN            0x00000008
-#define LOAD_OPTION_CATEGORY          0x00001F00
-
-#define LOAD_OPTION_CATEGORY_BOOT     0x00000000
-#define LOAD_OPTION_CATEGORY_APP      0x00000100
-
-#define EFI_BOOT_OPTION_SUPPORT_KEY   0x00000001
-#define EFI_BOOT_OPTION_SUPPORT_APP   0x00000002
-#define EFI_BOOT_OPTION_SUPPORT_COUNT 0x00000300
-
-///
-/// EFI Boot Key Data
-///
-typedef union {
-  struct {
-    ///
-    /// Indicates the revision of the EFI_KEY_OPTION structure. This revision level should be 0.
-    ///
-    UINT32  Revision        : 8;
-    ///
-    /// Either the left or right Shift keys must be pressed (1) or must not be pressed (0).
-    ///
-    UINT32  ShiftPressed    : 1;
-    ///
-    /// Either the left or right Control keys must be pressed (1) or must not be pressed (0).
-    ///
-    UINT32  ControlPressed  : 1;
-    ///
-    /// Either the left or right Alt keys must be pressed (1) or must not be pressed (0).
-    ///
-    UINT32  AltPressed      : 1;
-    ///
-    /// Either the left or right Logo keys must be pressed (1) or must not be pressed (0).
-    ///
-    UINT32  LogoPressed     : 1;
-    ///
-    /// The Menu key must be pressed (1) or must not be pressed (0).
-    ///
-    UINT32  MenuPressed     : 1;
-    ///
-    /// The SysReq key must be pressed (1) or must not be pressed (0).
-    ///
-    UINT32  SysReqPressed    : 1;
-    UINT32  Reserved        : 16;
-    ///
-    /// Specifies the actual number of entries in EFI_KEY_OPTION.Keys, from 0-3. If
-    /// zero, then only the shift state is considered. If more than one, then the boot option will
-    /// only be launched if all of the specified keys are pressed with the same shift state.
-    ///
-    UINT32  InputKeyCount   : 2;
-  } Options;
-  UINT32  PackedValue;
-} EFI_BOOT_KEY_DATA;
-
-///
-/// EFI Key Option.
-///
-#pragma pack(1)
-typedef struct {
-  ///
-  /// Specifies options about how the key will be processed.
-  ///
-  EFI_BOOT_KEY_DATA  KeyData;
-  ///
-  /// The CRC-32 which should match the CRC-32 of the entire EFI_LOAD_OPTION to
-  /// which BootOption refers. If the CRC-32s do not match this value, then this key
-  /// option is ignored.
-  ///
-  UINT32             BootOptionCrc;
-  ///
-  /// The Boot#### option which will be invoked if this key is pressed and the boot option
-  /// is active (LOAD_OPTION_ACTIVE is set).
-  ///
-  UINT16             BootOption;
-  ///
-  /// The key codes to compare against those returned by the
-  /// EFI_SIMPLE_TEXT_INPUT and EFI_SIMPLE_TEXT_INPUT_EX protocols.
-  /// The number of key codes (0-3) is specified by the EFI_KEY_CODE_COUNT field in KeyOptions.
-  ///
-  //EFI_INPUT_KEY      Keys[];
-} EFI_KEY_OPTION;
-#pragma pack()
-
-//
-// EFI File location to boot from on removable media devices
-//
-#define EFI_REMOVABLE_MEDIA_FILE_NAME_IA32    L"\\EFI\\BOOT\\BOOTIA32.EFI"
-#define EFI_REMOVABLE_MEDIA_FILE_NAME_IA64    L"\\EFI\\BOOT\\BOOTIA64.EFI"
-#define EFI_REMOVABLE_MEDIA_FILE_NAME_X64     L"\\EFI\\BOOT\\BOOTX64.EFI"
-#define EFI_REMOVABLE_MEDIA_FILE_NAME_ARM     L"\\EFI\\BOOT\\BOOTARM.EFI"
-#define EFI_REMOVABLE_MEDIA_FILE_NAME_AARCH64 L"\\EFI\\BOOT\\BOOTAA64.EFI"
-
-#if   defined (MDE_CPU_IA32)
-  #define EFI_REMOVABLE_MEDIA_FILE_NAME   EFI_REMOVABLE_MEDIA_FILE_NAME_IA32
-#elif defined (MDE_CPU_IPF)
-  #define EFI_REMOVABLE_MEDIA_FILE_NAME   EFI_REMOVABLE_MEDIA_FILE_NAME_IA64
-#elif defined (MDE_CPU_X64)
-  #define EFI_REMOVABLE_MEDIA_FILE_NAME   EFI_REMOVABLE_MEDIA_FILE_NAME_X64
-#elif defined (MDE_CPU_EBC)
-#elif defined (MDE_CPU_ARM)
-  #define EFI_REMOVABLE_MEDIA_FILE_NAME   EFI_REMOVABLE_MEDIA_FILE_NAME_ARM
-#elif defined (MDE_CPU_AARCH64)
-  #define EFI_REMOVABLE_MEDIA_FILE_NAME   EFI_REMOVABLE_MEDIA_FILE_NAME_AARCH64
-#else
-  #error Unknown Processor Type
-#endif
-
-#include "efi/Uefi/UefiPxe.h"
-#include "efi/Uefi/UefiGpt.h"
-#include "efi/Uefi/UefiInternalFormRepresentation.h"
-
-#endif
diff --git a/src/efi/X64/ProcessorBind.h b/src/efi/X64/ProcessorBind.h
deleted file mode 100644
index 9b4c61b..0000000
--- a/src/efi/X64/ProcessorBind.h
+++ /dev/null
@@ -1,294 +0,0 @@
-/** @file
-  Processor or Compiler specific defines and types x64 (Intel 64, AMD64).
-
-  Copyright (c) 2006 - 2013, Intel Corporation. All rights reserved.<BR>
-  This program and the accompanying materials
-  are licensed and made available under the terms and conditions of the BSD License
-  which accompanies this distribution.  The full text of the license may be found at
-  http://opensource.org/licenses/bsd-license.php
-
-  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
-  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
-
-**/
-
-#ifndef __PROCESSOR_BIND_H__
-#define __PROCESSOR_BIND_H__
-
-///
-/// Define the processor type so other code can make processor based choices
-///
-#define MDE_CPU_X64
-
-//
-// Make sure we are using the correct packing rules per EFI specification
-//
-#if !defined(__GNUC__)
-#pragma pack()
-#endif
-
-
-#if defined(__INTEL_COMPILER)
-//
-// Disable ICC's remark #869: "Parameter" was never referenced warning.
-// This is legal ANSI C code so we disable the remark that is turned on with -Wall
-//
-#pragma warning ( disable : 869 )
-
-//
-// Disable ICC's remark #1418: external function definition with no prior declaration.
-// This is legal ANSI C code so we disable the remark that is turned on with /W4
-//
-#pragma warning ( disable : 1418 )
-
-//
-// Disable ICC's remark #1419: external declaration in primary source file
-// This is legal ANSI C code so we disable the remark that is turned on with /W4
-//
-#pragma warning ( disable : 1419 )
-
-//
-// Disable ICC's remark #593: "Variable" was set but never used.
-// This is legal ANSI C code so we disable the remark that is turned on with /W4
-//
-#pragma warning ( disable : 593 )
-
-#endif
-
-
-#if defined(_MSC_EXTENSIONS)
-
-//
-// Disable warning that make it impossible to compile at /W4
-// This only works for Microsoft* tools
-//
-
-//
-// Disabling bitfield type checking warnings.
-//
-#pragma warning ( disable : 4214 )
-
-//
-// Disabling the unreferenced formal parameter warnings.
-//
-#pragma warning ( disable : 4100 )
-
-//
-// Disable slightly different base types warning as CHAR8 * can not be set
-// to a constant string.
-//
-#pragma warning ( disable : 4057 )
-
-//
-// ASSERT(FALSE) or while (TRUE) are legal constructes so supress this warning
-//
-#pragma warning ( disable : 4127 )
-
-//
-// This warning is caused by functions defined but not used. For precompiled header only.
-//
-#pragma warning ( disable : 4505 )
-
-//
-// This warning is caused by empty (after preprocessing) source file. For precompiled header only.
-//
-#pragma warning ( disable : 4206 )
-
-#endif
-
-
-#if defined(_MSC_EXTENSIONS)
-  //
-  // use Microsoft C complier dependent integer width types
-  //
-
-  ///
-  /// 8-byte unsigned value
-  ///
-  typedef unsigned __int64    UINT64;
-  ///
-  /// 8-byte signed value
-  ///
-  typedef __int64             INT64;
-  ///
-  /// 4-byte unsigned value
-  ///
-  typedef unsigned __int32    UINT32;
-  ///
-  /// 4-byte signed value
-  ///
-  typedef __int32             INT32;
-  ///
-  /// 2-byte unsigned value
-  ///
-  typedef unsigned short      UINT16;
-  ///
-  /// 2-byte Character.  Unless otherwise specified all strings are stored in the
-  /// UTF-16 encoding format as defined by Unicode 2.1 and ISO/IEC 10646 standards.
-  ///
-  typedef unsigned short      CHAR16;
-  ///
-  /// 2-byte signed value
-  ///
-  typedef short               INT16;
-  ///
-  /// Logical Boolean.  1-byte value containing 0 for FALSE or a 1 for TRUE.  Other
-  /// values are undefined.
-  ///
-  typedef unsigned char       BOOLEAN;
-  ///
-  /// 1-byte unsigned value
-  ///
-  typedef unsigned char       UINT8;
-  ///
-  /// 1-byte Character
-  ///
-  typedef char                CHAR8;
-  ///
-  /// 1-byte signed value
-  ///
-  typedef signed char         INT8;
-#else
-  ///
-  /// 8-byte unsigned value
-  ///
-  typedef unsigned long long  UINT64;
-  ///
-  /// 8-byte signed value
-  ///
-  typedef long long           INT64;
-  ///
-  /// 4-byte unsigned value
-  ///
-  typedef unsigned int        UINT32;
-  ///
-  /// 4-byte signed value
-  ///
-  typedef int                 INT32;
-  ///
-  /// 2-byte unsigned value
-  ///
-  typedef unsigned short      UINT16;
-  ///
-  /// 2-byte Character.  Unless otherwise specified all strings are stored in the
-  /// UTF-16 encoding format as defined by Unicode 2.1 and ISO/IEC 10646 standards.
-  ///
-  typedef unsigned short      CHAR16;
-  ///
-  /// 2-byte signed value
-  ///
-  typedef short               INT16;
-  ///
-  /// Logical Boolean.  1-byte value containing 0 for FALSE or a 1 for TRUE.  Other
-  /// values are undefined.
-  ///
-  typedef unsigned char       BOOLEAN;
-  ///
-  /// 1-byte unsigned value
-  ///
-  typedef unsigned char       UINT8;
-  ///
-  /// 1-byte Character
-  ///
-  typedef char                CHAR8;
-  ///
-  /// 1-byte signed value
-  ///
-  typedef signed char         INT8;
-#endif
-
-///
-/// Unsigned value of native width.  (4 bytes on supported 32-bit processor instructions,
-/// 8 bytes on supported 64-bit processor instructions)
-///
-typedef UINT64  UINTN;
-///
-/// Signed value of native width.  (4 bytes on supported 32-bit processor instructions,
-/// 8 bytes on supported 64-bit processor instructions)
-///
-typedef INT64   INTN;
-
-
-//
-// Processor specific defines
-//
-
-///
-/// A value of native width with the highest bit set.
-///
-#define MAX_BIT     0x8000000000000000ULL
-///
-/// A value of native width with the two highest bits set.
-///
-#define MAX_2_BITS  0xC000000000000000ULL
-
-///
-/// Maximum legal x64 address
-///
-#define MAX_ADDRESS   0xFFFFFFFFFFFFFFFFULL
-
-///
-/// Maximum legal x64 INTN and UINTN values.
-///
-#define MAX_INTN   ((INTN)0x7FFFFFFFFFFFFFFFULL)
-#define MAX_UINTN  ((UINTN)0xFFFFFFFFFFFFFFFFULL)
-
-///
-/// The stack alignment required for x64
-///
-#define CPU_STACK_ALIGNMENT   16
-
-//
-// Modifier to ensure that all protocol member functions and EFI intrinsics
-// use the correct C calling convention. All protocol member functions and
-// EFI intrinsics are required to modify their member functions with EFIAPI.
-//
-#ifdef EFIAPI
-  ///
-  /// If EFIAPI is already defined, then we use that definition.
-  ///
-#elif defined(_MSC_EXTENSIONS)
-  ///
-  /// Microsoft* compiler specific method for EFIAPI calling convension
-  ///
-  #define EFIAPI __cdecl
-#elif defined(__GNUC__)
-  ///
-  /// Define the standard calling convention reguardless of optimization level.
-  /// The GCC support assumes a GCC compiler that supports the EFI ABI. The EFI
-  /// ABI is much closer to the x64 Microsoft* ABI than standard x64 (x86-64)
-  /// GCC ABI. Thus a standard x64 (x86-64) GCC compiler can not be used for
-  /// x64. Warning the assembly code in the MDE x64 does not follow the correct
-  /// ABI for the standard x64 (x86-64) GCC.
-  ///
-  #define EFIAPI
-#else
-  ///
-  /// The default for a non Microsoft* or GCC compiler is to assume the EFI ABI
-  /// is the standard.
-  ///
-  #define EFIAPI
-#endif
-
-#if defined(__GNUC__)
-  ///
-  /// For GNU assembly code, .global or .globl can declare global symbols.
-  /// Define this macro to unify the usage.
-  ///
-  #define ASM_GLOBAL .globl
-#endif
-
-/**
-  Return the pointer to the first instruction of a function given a function pointer.
-  On x64 CPU architectures, these two pointer values are the same,
-  so the implementation of this macro is very simple.
-
-  @param  FunctionPointer   A pointer to a function.
-
-  @return The pointer to the first instruction of a function given a function pointer.
-
-**/
-#define FUNCTION_ENTRY_POINT(FunctionPointer) (VOID *)(UINTN)(FunctionPointer)
-
-#endif
-
diff --git a/src/efi/import.pl b/src/efi/import.pl
deleted file mode 100755
index 2369ce3..0000000
--- a/src/efi/import.pl
+++ /dev/null
@@ -1,120 +0,0 @@
-#!/usr/bin/perl -w
-
-=head1 NAME
-
-import.pl
-
-=head1 SYNOPSIS
-
-import.pl [options] /path/to/edk2/edk2
-
-Options:
-
-    -h,--help		Display brief help message
-    -v,--verbose	Increase verbosity
-    -q,--quiet		Decrease verbosity
-
-=cut
-
-use File::Spec::Functions qw ( :ALL );
-use File::Find;
-use File::Path;
-use Getopt::Long;
-use Pod::Usage;
-use FindBin;
-use strict;
-use warnings;
-
-my $verbosity = 0;
-
-sub try_import_file {
-  my $wimbootdir = shift;
-  my $edktop = shift;
-  my $edkdirs = shift;
-  my $filename = shift;
-
-  # Skip everything except headers
-  return unless $filename =~ /\.h$/;
-
-  # Skip files that are wimboot native headers
-  my $outfile = catfile ( $wimbootdir, $filename );
-  if ( -s $outfile ) {
-    open my $outfh, "<$outfile" or die "Could not open $outfile: $!\n";
-    my $line = <$outfh>;
-    close $outfh;
-    chomp $line;
-    return if $line =~ /^\#ifndef\s+_WIMBOOT_\S+_H$/;
-  }
-
-  # Search for importable header
-  foreach my $edkdir ( @$edkdirs ) {
-    my $infile = catfile ( $edktop, $edkdir, $filename );
-    if ( -e $infile ) {
-      # We have found a matching source file - import it
-      print "$filename <- ".catfile ( $edkdir, $filename )."\n"
-	  if $verbosity >= 1;
-      open my $infh, "<$infile" or die "Could not open $infile: $!\n";
-      ( undef, my $outdir, undef ) = splitpath ( $outfile );
-      mkpath ( $outdir );
-      open my $outfh, ">$outfile" or die "Could not open $outfile: $!\n";
-      my @dependencies = ();
-      while ( <$infh> ) {
-	# Strip CR and trailing whitespace
-	s/\r//g;
-	s/\s*$//g;
-	chomp;
-	# Update include lines, and record included files
-	if ( s/^\#include\s+[<\"](\S+)[>\"]/\#include "efi\/$1"/ ) {
-	  push @dependencies, $1;
-	}
-	# Write out line
-	print $outfh "$_\n";
-      }
-      close $outfh;
-      close $infh;
-      # Recurse to handle any included files that we don't already have
-      foreach my $dependency ( @dependencies ) {
-	if ( ! -e catfile ( $wimbootdir, $dependency ) ) {
-	  print "...following dependency on $dependency\n" if $verbosity >= 1;
-	  try_import_file ( $wimbootdir, $edktop, $edkdirs, $dependency );
-	}
-      }
-      return;
-    }
-  }
-  die "$filename has no equivalent in $edktop\n";
-}
-
-# Parse command-line options
-Getopt::Long::Configure ( 'bundling', 'auto_abbrev' );
-GetOptions (
-  'verbose|v+' => sub { $verbosity++; },
-  'quiet|q+' => sub { $verbosity--; },
-  'help|h' => sub { pod2usage ( 1 ); },
-) or die "Could not parse command-line options\n";
-pod2usage ( 1 ) unless @ARGV == 1;
-my $edktop = shift;
-
-# Identify edk import directories
-my $edkdirs = [ "MdePkg/Include", "IntelFrameworkPkg/Include",
-		"MdeModulePkg/Include", "EdkCompatibilityPkg/Foundation" ];
-foreach my $edkdir ( @$edkdirs ) {
-  die "Directory \"$edktop\" does not appear to contain the EFI EDK2 "
-      ."(missing \"$edkdir\")\n" unless -d catdir ( $edktop, $edkdir );
-}
-
-# Identify wimboot EFI includes directory
-my $wimbootdir = $FindBin::Bin;
-die "Directory \"$wimbootdir\" does not contain the wimboot EFI includes\n"
-    unless -e catfile ( $wimbootdir, "../wimboot.h" );
-
-if ( $verbosity >= 1 ) {
-  print "Importing EFI headers into $wimbootdir\nfrom ";
-  print join ( "\n and ", map { catdir ( $edktop, $_ ) } @$edkdirs )."\n";
-}
-
-# Import headers
-find ( { wanted => sub {
-  try_import_file ( $wimbootdir, $edktop, $edkdirs,
-		    abs2rel ( $_, $wimbootdir ) );
-}, no_chdir => 1 }, $wimbootdir );
diff --git a/src/efiblock.c b/src/efiblock.c
deleted file mode 100644
index fd79411..0000000
--- a/src/efiblock.c
+++ /dev/null
@@ -1,307 +0,0 @@
-/*
- * Copyright (C) 2014 Michael Brown <mbrown@fensystems.co.uk>.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of the
- * License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
- * 02110-1301, USA.
- */
-
-/**
- * @file
- *
- * EFI block device
- *
- */
-
-#include <stddef.h>
-#include <stdint.h>
-#include <stdio.h>
-#include "wimboot.h"
-#include "vdisk.h"
-#include "efi.h"
-#include "efipath.h"
-#include "efiblock.h"
-
-/** A block I/O device */
-struct efi_block {
-	/** EFI block I/O protocol */
-	EFI_BLOCK_IO_PROTOCOL block;
-	/** Device path */
-	EFI_DEVICE_PATH_PROTOCOL *path;
-	/** Starting LBA */
-	uint64_t lba;
-	/** Name */
-	const char *name;
-};
-
-/**
- * Reset block I/O protocol
- *
- * @v this		Block I/O protocol
- * @v extended		Perform extended verification
- * @ret efirc		EFI status code
- */
-static EFI_STATUS EFIAPI
-efi_reset_blocks ( EFI_BLOCK_IO_PROTOCOL *this, BOOLEAN extended ) {
-	struct efi_block *block =
-		container_of ( this, struct efi_block, block );
-	void *retaddr = __builtin_return_address ( 0 );
-
-	DBG2 ( "EFI %s %sreset -> %p\n",
-	       block->name, ( extended ? "extended " : "" ), retaddr );
-	return 0;
-}
-
-/**
- * Read blocks
- *
- * @v this		Block I/O protocol
- * @v media		Media ID
- * @v lba		Starting LBA
- * @v len		Length of data
- * @v data		Data buffer
- * @ret efirc		EFI status code
- */
-static EFI_STATUS EFIAPI
-efi_read_blocks ( EFI_BLOCK_IO_PROTOCOL *this, UINT32 media, EFI_LBA lba,
-		  UINTN len, VOID *data ) {
-	struct efi_block *block =
-		container_of ( this, struct efi_block, block );
-	void *retaddr = __builtin_return_address ( 0 );
-
-	DBG2 ( "EFI %s read media %08x LBA %#llx to %p+%zx -> %p\n",
-	       block->name, media, lba, data, ( ( size_t ) len ), retaddr );
-	vdisk_read ( ( lba + block->lba ), ( len / VDISK_SECTOR_SIZE ), data );
-	return 0;
-}
-
-/**
- * Write blocks
- *
- * @v this		Block I/O protocol
- * @v media		Media ID
- * @v lba		Starting LBA
- * @v len		Length of data
- * @v data		Data buffer
- * @ret efirc		EFI status code
- */
-static EFI_STATUS EFIAPI
-efi_write_blocks ( EFI_BLOCK_IO_PROTOCOL *this __unused,
-		   UINT32 media __unused, EFI_LBA lba __unused,
-		   UINTN len __unused, VOID *data __unused ) {
-	struct efi_block *block =
-		container_of ( this, struct efi_block, block );
-	void *retaddr = __builtin_return_address ( 0 );
-
-	DBG2 ( "EFI %s write media %08x LBA %#llx from %p+%zx -> %p\n",
-	       block->name, media, lba, data, ( ( size_t ) len ), retaddr );
-	return EFI_WRITE_PROTECTED;
-}
-
-/**
- * Flush block operations
- *
- * @v this		Block I/O protocol
- * @ret efirc		EFI status code
- */
-static EFI_STATUS EFIAPI
-efi_flush_blocks ( EFI_BLOCK_IO_PROTOCOL *this ) {
-	struct efi_block *block =
-		container_of ( this, struct efi_block, block );
-	void *retaddr = __builtin_return_address ( 0 );
-
-	DBG2 ( "EFI %s flush -> %p\n", block->name, retaddr );
-	return 0;
-}
-
-/** GUID used in vendor device path */
-#define EFIBLOCK_GUID {							\
-	0x1322d197, 0x15dc, 0x4a45,					\
-	{ 0xa6, 0xa4, 0xfa, 0x57, 0x05, 0x4e, 0xa6, 0x14 }		\
-	}
-
-/**
- * Initialise vendor device path
- *
- * @v name		Variable name
- */
-#define EFIBLOCK_DEVPATH_VENDOR_INIT( name ) {				\
-	.Header = EFI_DEVPATH_INIT ( name, HARDWARE_DEVICE_PATH,	\
-				     HW_VENDOR_DP ),			\
-	.Guid = EFIBLOCK_GUID,						\
-	}
-
-/**
- * Initialise ATA device path
- *
- * @v name		Variable name
- */
-#define EFIBLOCK_DEVPATH_ATA_INIT( name ) {				\
-	.Header = EFI_DEVPATH_INIT ( name, MESSAGING_DEVICE_PATH,	\
-				     MSG_ATAPI_DP ),			\
-	.PrimarySecondary = 0,						\
-	.SlaveMaster = 0,						\
-	.Lun = 0,							\
-	}
-
-/**
- * Initialise hard disk device path
- *
- * @v name		Variable name
- */
-#define EFIBLOCK_DEVPATH_HD_INIT( name ) {				\
-	.Header = EFI_DEVPATH_INIT ( name, MEDIA_DEVICE_PATH,		\
-				     MEDIA_HARDDRIVE_DP ),		\
-	.PartitionNumber = 1,						\
-	.PartitionStart = VDISK_PARTITION_LBA,				\
-	.PartitionSize = VDISK_PARTITION_COUNT,				\
-	.Signature[0] = ( ( VDISK_MBR_SIGNATURE >> 0 ) & 0xff ),	\
-	.Signature[1] = ( ( VDISK_MBR_SIGNATURE >> 8 ) & 0xff ),	\
-	.Signature[2] = ( ( VDISK_MBR_SIGNATURE >> 16 ) & 0xff ),	\
-	.Signature[3] = ( ( VDISK_MBR_SIGNATURE >> 24 ) & 0xff ),	\
-	.MBRType = MBR_TYPE_PCAT,					\
-	.SignatureType = SIGNATURE_TYPE_MBR,				\
-	}
-
-/** Virtual disk media */
-static EFI_BLOCK_IO_MEDIA efi_vdisk_media = {
-	.MediaId = VDISK_MBR_SIGNATURE,
-	.MediaPresent = TRUE,
-	.LogicalPartition = FALSE,
-	.ReadOnly = TRUE,
-	.BlockSize = VDISK_SECTOR_SIZE,
-	.LastBlock = ( VDISK_COUNT - 1 ),
-};
-
-/** Virtual disk device path */
-static struct {
-	VENDOR_DEVICE_PATH vendor;
-	ATAPI_DEVICE_PATH ata;
-	EFI_DEVICE_PATH_PROTOCOL end;
-} __attribute__ (( packed )) efi_vdisk_path = {
-	.vendor = EFIBLOCK_DEVPATH_VENDOR_INIT ( efi_vdisk_path.vendor ),
-	.ata = EFIBLOCK_DEVPATH_ATA_INIT ( efi_vdisk_path.ata ),
-	.end = EFI_DEVPATH_END_INIT ( efi_vdisk_path.end ),
-};
-
-/** Virtual disk device */
-static struct efi_block efi_vdisk = {
-	.block = {
-		.Revision = EFI_BLOCK_IO_PROTOCOL_REVISION,
-		.Media = &efi_vdisk_media,
-		.Reset = efi_reset_blocks,
-		.ReadBlocks = efi_read_blocks,
-		.WriteBlocks = efi_write_blocks,
-		.FlushBlocks = efi_flush_blocks,
-	},
-	.path = &efi_vdisk_path.vendor.Header,
-	.lba = 0,
-	.name = "vdisk",
-};
-
-/** Virtual partition media */
-static EFI_BLOCK_IO_MEDIA efi_vpartition_media = {
-	.MediaId = VDISK_MBR_SIGNATURE,
-	.MediaPresent = TRUE,
-	.LogicalPartition = TRUE,
-	.ReadOnly = TRUE,
-	.BlockSize = VDISK_SECTOR_SIZE,
-	.LastBlock = ( VDISK_PARTITION_COUNT - 1 ),
-};
-
-/** Virtual partition device path */
-static struct {
-	VENDOR_DEVICE_PATH vendor;
-	ATAPI_DEVICE_PATH ata;
-	HARDDRIVE_DEVICE_PATH hd;
-	EFI_DEVICE_PATH_PROTOCOL end;
-} __attribute__ (( packed )) efi_vpartition_path = {
-	.vendor = EFIBLOCK_DEVPATH_VENDOR_INIT ( efi_vpartition_path.vendor ),
-	.ata = EFIBLOCK_DEVPATH_ATA_INIT ( efi_vpartition_path.ata ),
-	.hd = EFIBLOCK_DEVPATH_HD_INIT ( efi_vpartition_path.hd ),
-	.end = EFI_DEVPATH_END_INIT ( efi_vpartition_path.end ),
-};
-
-/** Virtual partition device */
-static struct efi_block efi_vpartition = {
-	.block = {
-		.Revision = EFI_BLOCK_IO_PROTOCOL_REVISION,
-		.Media = &efi_vpartition_media,
-		.Reset = efi_reset_blocks,
-		.ReadBlocks = efi_read_blocks,
-		.WriteBlocks = efi_write_blocks,
-		.FlushBlocks = efi_flush_blocks,
-	},
-	.path = &efi_vpartition_path.vendor.Header,
-	.lba = VDISK_PARTITION_LBA,
-	.name = "vpartition",
-};
-
-/**
- * Install block I/O protocols
- *
- * @ret vdisk		New virtual disk handle
- * @ret vpartition	New virtual partition handle
- */
-void efi_install ( EFI_HANDLE *vdisk, EFI_HANDLE *vpartition ) {
-	EFI_BOOT_SERVICES *bs = efi_systab->BootServices;
-	EFI_STATUS efirc;
-
-	/* Install virtual disk */
-	if ( ( efirc = bs->InstallMultipleProtocolInterfaces (
-		vdisk,
-		&efi_block_io_protocol_guid, &efi_vdisk.block,
-		&efi_device_path_protocol_guid, efi_vdisk.path,
-		NULL ) ) != 0 ) {
-		die ( "Could not install disk block I/O protocols: %#lx\n",
-		      ( ( unsigned long ) efirc ) );
-	}
-
-	/* Install virtual partition */
-	if ( ( efirc = bs->InstallMultipleProtocolInterfaces (
-		vpartition,
-		&efi_block_io_protocol_guid, &efi_vpartition.block,
-		&efi_device_path_protocol_guid, efi_vpartition.path,
-		NULL ) ) != 0 ) {
-		die ( "Could not install partition block I/O protocols: %#lx\n",
-		      ( ( unsigned long ) efirc ) );
-	}
-}
-
-/** Boot image path */
-static struct {
-	VENDOR_DEVICE_PATH vendor;
-	ATAPI_DEVICE_PATH ata;
-	HARDDRIVE_DEVICE_PATH hd;
-	struct {
-		EFI_DEVICE_PATH header;
-		CHAR16 name[ sizeof ( EFI_REMOVABLE_MEDIA_FILE_NAME ) /
-			     sizeof ( CHAR16 ) ];
-	} __attribute__ (( packed )) file;
-	EFI_DEVICE_PATH_PROTOCOL end;
-} __attribute__ (( packed )) efi_bootmgfw_path = {
-	.vendor = EFIBLOCK_DEVPATH_VENDOR_INIT ( efi_bootmgfw_path.vendor ),
-	.ata = EFIBLOCK_DEVPATH_ATA_INIT ( efi_bootmgfw_path.ata ),
-	.hd = EFIBLOCK_DEVPATH_HD_INIT ( efi_bootmgfw_path.hd ),
-	.file = {
-		.header = EFI_DEVPATH_INIT ( efi_bootmgfw_path.file,
-					     MEDIA_DEVICE_PATH,
-					     MEDIA_FILEPATH_DP ),
-		.name = EFI_REMOVABLE_MEDIA_FILE_NAME,
-	},
-	.end = EFI_DEVPATH_END_INIT ( efi_bootmgfw_path.end ),
-};
-
-/** Boot image path */
-EFI_DEVICE_PATH_PROTOCOL *bootmgfw_path = &efi_bootmgfw_path.vendor.Header;
diff --git a/src/efiblock.h b/src/efiblock.h
deleted file mode 100644
index cd34fbb..0000000
--- a/src/efiblock.h
+++ /dev/null
@@ -1,38 +0,0 @@
-#ifndef _EFIBLOCK_H
-#define _EFIBLOCK_H
-
-/*
- * Copyright (C) 2014 Michael Brown <mbrown@fensystems.co.uk>.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of the
- * License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
- * 02110-1301, USA.
- */
-
-/**
- * @file
- *
- * EFI block device
- *
- */
-
-#include "efi.h"
-#include "efi/Protocol/BlockIo.h"
-#include "efi/Protocol/DevicePath.h"
-
-extern void efi_install ( EFI_HANDLE *vdisk, EFI_HANDLE *vpartition );
-
-extern EFI_DEVICE_PATH_PROTOCOL *bootmgfw_path;
-
-#endif /* _EFIBLOCK_H */
diff --git a/src/efiboot.c b/src/efiboot.c
deleted file mode 100644
index 5c800e9..0000000
--- a/src/efiboot.c
+++ /dev/null
@@ -1,157 +0,0 @@
-/*
- * Copyright (C) 2014 Michael Brown <mbrown@fensystems.co.uk>.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of the
- * License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
- * 02110-1301, USA.
- */
-
-/**
- * @file
- *
- * EFI boot manager invocation
- *
- */
-
-#include <stdio.h>
-#include <string.h>
-#include "wimboot.h"
-#include "cmdline.h"
-#include "vdisk.h"
-#include "pause.h"
-#include "efi.h"
-#include "efi/Protocol/GraphicsOutput.h"
-#include "efipath.h"
-#include "efiboot.h"
-
-/** Original OpenProtocol() method */
-static EFI_OPEN_PROTOCOL orig_open_protocol;
-
-/**
- * Intercept OpenProtocol()
- *
- * @v handle		EFI handle
- * @v protocol		Protocol GUID
- * @v interface		Opened interface
- * @v agent_handle	Agent handle
- * @v controller_handle	Controller handle
- * @v attributes	Attributes
- * @ret efirc		EFI status code
- */
-static EFI_STATUS EFIAPI
-efi_open_protocol_wrapper ( EFI_HANDLE handle, EFI_GUID *protocol,
-			    VOID **interface, EFI_HANDLE agent_handle,
-			    EFI_HANDLE controller_handle, UINT32 attributes ) {
-	static unsigned int count;
-	EFI_STATUS efirc;
-
-	/* Open the protocol */
-	if ( ( efirc = orig_open_protocol ( handle, protocol, interface,
-					    agent_handle, controller_handle,
-					    attributes ) ) != 0 ) {
-		return efirc;
-	}
-
-	/* Block first attempt by bootmgfw.efi to open
-	 * EFI_GRAPHICS_OUTPUT_PROTOCOL.  This forces error messages
-	 * to be displayed in text mode (thereby avoiding the totally
-	 * blank error screen if the fonts are missing).  We must
-	 * allow subsequent attempts to succeed, otherwise the OS will
-	 * fail to boot.
-	 */
-	if ( ( memcmp ( protocol, &efi_graphics_output_protocol_guid,
-			sizeof ( *protocol ) ) == 0 ) &&
-	     ( count++ == 0 ) && ( ! cmdline_gui ) ) {
-		DBG ( "Forcing text mode output\n" );
-		return EFI_INVALID_PARAMETER;
-	}
-
-	return 0;
-}
-
-/**
- * Boot from EFI device
- *
- * @v file		Virtual file
- * @v path		Device path
- * @v device		Device handle
- */
-void efi_boot ( struct vdisk_file *file, EFI_DEVICE_PATH_PROTOCOL *path,
-		EFI_HANDLE device ) {
-	EFI_BOOT_SERVICES *bs = efi_systab->BootServices;
-	union {
-		EFI_LOADED_IMAGE_PROTOCOL *image;
-		void *intf;
-	} loaded;
-	EFI_PHYSICAL_ADDRESS phys;
-	void *data;
-	unsigned int pages;
-	EFI_HANDLE handle;
-	EFI_STATUS efirc;
-
-	/* Allocate memory */
-	pages = ( ( file->len + PAGE_SIZE - 1 ) / PAGE_SIZE );
-	if ( ( efirc = bs->AllocatePages ( AllocateAnyPages,
-					   EfiBootServicesData, pages,
-					   &phys ) ) != 0 ) {
-		die ( "Could not allocate %d pages: %#lx\n",
-		      pages, ( ( unsigned long ) efirc ) );
-	}
-	data = ( ( void * ) ( intptr_t ) phys );
-
-
-	/* Read image */
-	file->read ( file, data, 0, file->len );
-	DBG ( "Read %s\n", file->name );
-
-	/* Load image */
-	if ( ( efirc = bs->LoadImage ( FALSE, efi_image_handle, path, data,
-				       file->len, &handle ) ) != 0 ) {
-		die ( "Could not load %s: %#lx\n",
-		      file->name, ( ( unsigned long ) efirc ) );
-	}
-	DBG ( "Loaded %s\n", file->name );
-
-	/* Get loaded image protocol */
-	if ( ( efirc = bs->OpenProtocol ( handle,
-					  &efi_loaded_image_protocol_guid,
-					  &loaded.intf, efi_image_handle, NULL,
-					  EFI_OPEN_PROTOCOL_GET_PROTOCOL ))!=0){
-		die ( "Could not get loaded image protocol for %s: %#lx\n",
-		      file->name, ( ( unsigned long ) efirc ) );
-	}
-
-	/* Force correct device handle */
-	if ( loaded.image->DeviceHandle != device ) {
-		DBG ( "Forcing correct DeviceHandle (%p->%p)\n",
-		      loaded.image->DeviceHandle, device );
-		loaded.image->DeviceHandle = device;
-	}
-
-	/* Intercept calls to OpenProtocol() */
-	orig_open_protocol =
-		loaded.image->SystemTable->BootServices->OpenProtocol;
-	loaded.image->SystemTable->BootServices->OpenProtocol =
-		efi_open_protocol_wrapper;
-
-	/* Start image */
-	if ( cmdline_pause )
-		pause();
-	if ( ( efirc = bs->StartImage ( handle, NULL, NULL ) ) != 0 ) {
-		die ( "Could not start %s: %#lx\n",
-		      file->name, ( ( unsigned long ) efirc ) );
-	}
-
-	die ( "%s returned\n", file->name );
-}
diff --git a/src/efiboot.h b/src/efiboot.h
deleted file mode 100644
index 6671ef1..0000000
--- a/src/efiboot.h
+++ /dev/null
@@ -1,38 +0,0 @@
-#ifndef _EFIBOOT_H
-#define _EFIBOOT_H
-
-/*
- * Copyright (C) 2014 Michael Brown <mbrown@fensystems.co.uk>.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of the
- * License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
- * 02110-1301, USA.
- */
-
-/**
- * @file
- *
- * EFI boot manager invocation
- *
- */
-
-#include "efi.h"
-#include "efi/Protocol/DevicePath.h"
-
-struct vdisk_file;
-
-extern void efi_boot ( struct vdisk_file *file, EFI_DEVICE_PATH_PROTOCOL *path,
-		       EFI_HANDLE device );
-
-#endif /* _EFIBOOT_H */
diff --git a/src/efifile.c b/src/efifile.c
deleted file mode 100644
index 93bfd64..0000000
--- a/src/efifile.c
+++ /dev/null
@@ -1,218 +0,0 @@
-/*
- * Copyright (C) 2014 Michael Brown <mbrown@fensystems.co.uk>.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of the
- * License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
- * 02110-1301, USA.
- */
-
-/**
- * @file
- *
- * EFI file system access
- *
- */
-
-#include <stdio.h>
-#include <string.h>
-#include <strings.h>
-#include <wchar.h>
-#include "wimboot.h"
-#include "vdisk.h"
-#include "cmdline.h"
-#include "wimpatch.h"
-#include "wimfile.h"
-#include "efi.h"
-#include "efifile.h"
-
-/** bootmgfw.efi path within WIM */
-static const wchar_t bootmgfw_path[] = L"\\Windows\\Boot\\EFI\\bootmgfw.efi";
-
-/** bootmgfw.efi file */
-struct vdisk_file *bootmgfw;
-
-/**
- * Get architecture-specific boot filename
- *
- * @ret bootarch	Architecture-specific boot filename
- */
-static const CHAR16 * efi_bootarch ( void ) {
-	static const CHAR16 bootarch_full[] = EFI_REMOVABLE_MEDIA_FILE_NAME;
-	const CHAR16 *tmp;
-	const CHAR16 *bootarch = bootarch_full;
-
-	for ( tmp = bootarch_full ; *tmp ; tmp++ ) {
-		if ( *tmp == L'\\' )
-			bootarch = ( tmp + 1 );
-	}
-	return bootarch;
-}
-
-/**
- * Read from EFI file
- *
- * @v vfile		Virtual file
- * @v data		Data buffer
- * @v offset		Offset
- * @v len		Length
- */
-static void efi_read_file ( struct vdisk_file *vfile, void *data,
-			    size_t offset, size_t len ) {
-	EFI_FILE_PROTOCOL *file = vfile->opaque;
-	UINTN size = len;
-	EFI_STATUS efirc;
-
-	/* Set file position */
-	if ( ( efirc = file->SetPosition ( file, offset ) ) != 0 ) {
-		die ( "Could not set file position: %#lx\n",
-		      ( ( unsigned long ) efirc ) );
-	}
-
-	/* Read from file */
-	if ( ( efirc = file->Read ( file, &size, data ) ) != 0 ) {
-		die ( "Could not read from file: %#lx\n",
-		      ( ( unsigned long ) efirc ) );
-	}
-}
-
-/**
- * Patch BCD file
- *
- * @v vfile		Virtual file
- * @v data		Data buffer
- * @v offset		Offset
- * @v len		Length
- */
-static void efi_patch_bcd ( struct vdisk_file *vfile __unused, void *data,
-			    size_t offset, size_t len ) {
-	static const wchar_t search[] = L".exe";
-	static const wchar_t replace[] = L".efi";
-	size_t i;
-
-	/* Do nothing if BCD patching is disabled */
-	if ( cmdline_rawbcd )
-		return;
-
-	/* Patch any occurrences of ".exe" to ".efi".  In the common
-	 * simple cases, this allows the same BCD file to be used for
-	 * both BIOS and UEFI systems.
-	 */
-	for ( i = 0 ; ( i + sizeof ( search ) ) < len ; i++ ) {
-		if ( wcscasecmp ( ( data + i ), search ) == 0 ) {
-			memcpy ( ( data + i ), replace, sizeof ( replace ) );
-			DBG ( "...patched BCD at %#zx: \"%ls\" to \"%ls\"\n",
-			      ( offset + i ), search, replace );
-		}
-	}
-}
-
-/**
- * Extract files from EFI file system
- *
- * @v handle		Device handle
- */
-void efi_extract ( EFI_HANDLE handle ) {
-	EFI_BOOT_SERVICES *bs = efi_systab->BootServices;
-	union {
-		EFI_SIMPLE_FILE_SYSTEM_PROTOCOL *fs;
-		void *interface;
-	} fs;
-	struct {
-		EFI_FILE_INFO file;
-		CHAR16 name[ VDISK_NAME_LEN + 1 /* WNUL */ ];
-	} __attribute__ (( packed )) info;
-	char name[ VDISK_NAME_LEN + 1 /* NUL */ ];
-	struct vdisk_file *vfile;
-	EFI_FILE_PROTOCOL *root;
-	EFI_FILE_PROTOCOL *file;
-	UINTN size;
-	CHAR16 *wname;
-	EFI_STATUS efirc;
-	unsigned int idx = 0;
-
-	/* Open file system */
-	if ( ( efirc = bs->OpenProtocol ( handle,
-					  &efi_simple_file_system_protocol_guid,
-					  &fs.interface, efi_image_handle, NULL,
-					  EFI_OPEN_PROTOCOL_GET_PROTOCOL ))!=0){
-		die ( "Could not open simple file system: %#lx\n",
-		      ( ( unsigned long ) efirc ) );
-	}
-
-	/* Open root directory */
-	if ( ( efirc = fs.fs->OpenVolume ( fs.fs, &root ) ) != 0 ) {
-		die ( "Could not open root directory: %#lx\n",
-		      ( ( unsigned long ) efirc ) );
-	}
-
-	/* Close file system */
-	bs->CloseProtocol ( handle, &efi_simple_file_system_protocol_guid,
-			    efi_image_handle, NULL );
-
-	/* Read root directory */
-	while ( 1 ) {
-
-		/* Read directory entry */
-		size = sizeof ( info );
-		if ( ( efirc = root->Read ( root, &size, &info ) ) != 0 ) {
-			die ( "Could not read root directory: %#lx\n",
-			      ( ( unsigned long ) efirc ) );
-		}
-		if ( size == 0 )
-			break;
-
-		/* Sanity check */
-		if ( idx >= VDISK_MAX_FILES )
-			die ( "Too many files\n" );
-
-		/* Open file */
-		wname = info.file.FileName;
-		if ( ( efirc = root->Open ( root, &file, wname,
-					    EFI_FILE_MODE_READ, 0 ) ) != 0 ) {
-			die ( "Could not open \"%ls\": %#lx\n",
-			      wname, ( ( unsigned long ) efirc ) );
-		}
-
-		/* Add file */
-		snprintf ( name, sizeof ( name ), "%ls", wname );
-		vfile = vdisk_add_file ( name, file, info.file.FileSize,
-					 efi_read_file );
-
-		/* Check for special-case files */
-		if ( ( wcscasecmp ( wname, efi_bootarch() ) == 0 ) ||
-		     ( wcscasecmp ( wname, L"bootmgfw.efi" ) == 0 ) ) {
-			DBG ( "...found bootmgfw.efi file %ls\n", wname );
-			bootmgfw = vfile;
-		} else if ( wcscasecmp ( wname, L"BCD" ) == 0 ) {
-			DBG ( "...found BCD\n" );
-			vdisk_patch_file ( vfile, efi_patch_bcd );
-		} else if ( wcscasecmp ( ( wname + ( wcslen ( wname ) - 4 ) ),
-					 L".wim" ) == 0 ) {
-			DBG ( "...found WIM file %ls\n", wname );
-			vdisk_patch_file ( vfile, patch_wim );
-			if ( ( ! bootmgfw ) &&
-			     ( bootmgfw = wim_add_file ( vfile, cmdline_index,
-							 bootmgfw_path,
-							 efi_bootarch() ) ) ) {
-				DBG ( "...extracted %ls\n", bootmgfw_path );
-			}
-		}
-	}
-
-	/* Check that we have a boot file */
-	if ( ! bootmgfw ) {
-		die ( "FATAL: no %ls or bootmgfw.efi found\n",
-		      efi_bootarch() );
-	}
-}
diff --git a/src/efifile.h b/src/efifile.h
deleted file mode 100644
index 885ea5c..0000000
--- a/src/efifile.h
+++ /dev/null
@@ -1,39 +0,0 @@
-#ifndef _EFIFILE_H
-#define _EFIFILE_H
-
-/*
- * Copyright (C) 2014 Michael Brown <mbrown@fensystems.co.uk>.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of the
- * License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
- * 02110-1301, USA.
- */
-
-/**
- * @file
- *
- * EFI file system access
- *
- */
-
-#include "efi.h"
-#include "efi/Protocol/SimpleFileSystem.h"
-#include "efi/Guid/FileInfo.h"
-
-struct vdisk_file;
-
-extern struct vdisk_file *bootmgfw;
-extern void efi_extract ( EFI_HANDLE handle );
-
-#endif /* _EFIFILE_H */
diff --git a/src/efiguid.c b/src/efiguid.c
deleted file mode 100644
index 00313fa..0000000
--- a/src/efiguid.c
+++ /dev/null
@@ -1,53 +0,0 @@
-/*
- * Copyright (C) 2014 Michael Brown <mbrown@fensystems.co.uk>.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of the
- * License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
- * 02110-1301, USA.
- */
-
-/**
- * @file
- *
- * EFI GUIDs
- *
- */
-
-#include "wimboot.h"
-#include "efi.h"
-#include "efi/Protocol/BlockIo.h"
-#include "efi/Protocol/DevicePath.h"
-#include "efi/Protocol/GraphicsOutput.h"
-#include "efi/Protocol/LoadedImage.h"
-#include "efi/Protocol/SimpleFileSystem.h"
-
-/** Block I/O protocol GUID */
-EFI_GUID efi_block_io_protocol_guid
-	= EFI_BLOCK_IO_PROTOCOL_GUID;
-
-/** Device path protocol GUID */
-EFI_GUID efi_device_path_protocol_guid
-	= EFI_DEVICE_PATH_PROTOCOL_GUID;
-
-/** Graphics output protocol GUID */
-EFI_GUID efi_graphics_output_protocol_guid
-	= EFI_GRAPHICS_OUTPUT_PROTOCOL_GUID;
-
-/** Loaded image protocol GUID */
-EFI_GUID efi_loaded_image_protocol_guid
-	= EFI_LOADED_IMAGE_PROTOCOL_GUID;
-
-/** Simple file system protocol GUID */
-EFI_GUID efi_simple_file_system_protocol_guid
-	= EFI_SIMPLE_FILE_SYSTEM_PROTOCOL_GUID;
diff --git a/src/efimain.c b/src/efimain.c
deleted file mode 100644
index 3207dec..0000000
--- a/src/efimain.c
+++ /dev/null
@@ -1,101 +0,0 @@
-/*
- * Copyright (C) 2014 Michael Brown <mbrown@fensystems.co.uk>.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of the
- * License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
- * 02110-1301, USA.
- */
-
-/**
- * @file
- *
- * EFI entry point
- *
- */
-
-#include <stdio.h>
-#include "wimboot.h"
-#include "cmdline.h"
-#include "efi.h"
-#include "efifile.h"
-#include "efiblock.h"
-#include "efiboot.h"
-
-/**
- * Process command line
- *
- * @v loaded		Loaded image protocol
- */
-static void efi_cmdline ( EFI_LOADED_IMAGE_PROTOCOL *loaded ) {
-	size_t cmdline_len = ( loaded->LoadOptionsSize / sizeof ( wchar_t ) );
-	char cmdline[ cmdline_len + 1 /* NUL */ ];
-	const wchar_t *wcmdline = loaded->LoadOptions;
-
-	/* Convert command line to ASCII */
-	snprintf ( cmdline, sizeof ( cmdline ), "%ls", wcmdline );
-
-	/* Process command line */
-	process_cmdline ( cmdline );
-}
-
-/**
- * EFI entry point
- *
- * @v image_handle	Image handle
- * @v systab		EFI system table
- * @ret efirc		EFI status code
- */
-EFI_STATUS EFIAPI efi_main ( EFI_HANDLE image_handle,
-			     EFI_SYSTEM_TABLE *systab ) {
-	EFI_BOOT_SERVICES *bs;
-	union {
-		EFI_LOADED_IMAGE_PROTOCOL *image;
-		void *interface;
-	} loaded;
-	EFI_HANDLE vdisk = NULL;
-	EFI_HANDLE vpartition = NULL;
-	EFI_STATUS efirc;
-
-	/* Record EFI handle and system table */
-	efi_image_handle = image_handle;
-	efi_systab = systab;
-	bs = systab->BootServices;
-
-	/* Print welcome banner */
-	printf ( "\n\nwimboot " VERSION " -- Windows Imaging Format "
-		 "bootloader -- http://ipxe.org/wimboot\n\n" );
-
-	/* Get loaded image protocol */
-	if ( ( efirc = bs->OpenProtocol ( image_handle,
-					  &efi_loaded_image_protocol_guid,
-					  &loaded.interface, image_handle, NULL,
-					  EFI_OPEN_PROTOCOL_GET_PROTOCOL ))!=0){
-		die ( "Could not open loaded image protocol: %#lx\n",
-		      ( ( unsigned long ) efirc ) );
-	}
-
-	/* Process command line */
-	efi_cmdline ( loaded.image );
-
-	/* Extract files from file system */
-	efi_extract ( loaded.image->DeviceHandle );
-
-	/* Install virtual disk */
-	efi_install ( &vdisk, &vpartition );
-
-	/* Invoke boot manager */
-	efi_boot ( bootmgfw, bootmgfw_path, vpartition );
-
-	return 0;
-}
diff --git a/src/efipath.c b/src/efipath.c
deleted file mode 100644
index b4f1c5c..0000000
--- a/src/efipath.c
+++ /dev/null
@@ -1,46 +0,0 @@
-/*
- * Copyright (C) 2014 Michael Brown <mbrown@fensystems.co.uk>.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of the
- * License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
- * 02110-1301, USA.
- */
-
-/**
- * @file
- *
- * EFI device paths
- *
- */
-
-#include "wimboot.h"
-#include "efi.h"
-#include "efipath.h"
-
-/**
- * Find end of device path
- *
- * @v path		Path to device
- * @ret path_end	End of device path
- */
-EFI_DEVICE_PATH_PROTOCOL * efi_devpath_end ( EFI_DEVICE_PATH_PROTOCOL *path ) {
-
-	while ( path->Type != END_DEVICE_PATH_TYPE ) {
-		path = ( ( ( void * ) path ) +
-			 /* There's this amazing new-fangled thing known as
-			  * a UINT16, but who wants to use one of those? */
-			 ( ( path->Length[1] << 8 ) | path->Length[0] ) );
-	}
-	return path;
-}
diff --git a/src/efipath.h b/src/efipath.h
deleted file mode 100644
index ec7e8c3..0000000
--- a/src/efipath.h
+++ /dev/null
@@ -1,89 +0,0 @@
-#ifndef _EFIPATH_H
-#define _EFIPATH_H
-
-/*
- * Copyright (C) 2014 Michael Brown <mbrown@fensystems.co.uk>.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of the
- * License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
- * 02110-1301, USA.
- */
-
-/**
- * @file
- *
- * EFI device paths
- *
- */
-
-#include "efi.h"
-#include "efi/Protocol/DevicePath.h"
-
-/**
- * Initialise device path
- *
- * @v name		Variable name
- * @v type		Type
- * @v subtype		Subtype
- */
-#define EFI_DEVPATH_INIT( name, type, subtype ) {		\
-	.Type = (type),						\
-	.SubType = (subtype),					\
-	.Length[0] = ( sizeof (name) & 0xff ),			\
-	.Length[1] = ( sizeof (name) >> 8 ),			\
-	}
-
-/**
- * Initialise device path
- *
- * @v path		Device path
- * @v type		Type
- * @v subtype		Subtype
- * @v len		Length
- */
-static inline __attribute__ (( always_inline )) void
-efi_devpath_init ( EFI_DEVICE_PATH_PROTOCOL *path, unsigned int type,
-		   unsigned int subtype, size_t len ) {
-
-	path->Type = type;
-	path->SubType = subtype;
-	path->Length[0] = ( len & 0xff );
-	path->Length[1] = ( len >> 8 );
-}
-
-/**
- * Initialise device path end
- *
- * @v name		Variable name
- */
-#define EFI_DEVPATH_END_INIT( name )				\
-	EFI_DEVPATH_INIT ( name, END_DEVICE_PATH_TYPE,		\
-			   END_ENTIRE_DEVICE_PATH_SUBTYPE )
-
-/**
- * Initialise device path end
- *
- * @v path		Device path
- */
-static inline __attribute__ (( always_inline )) void
-efi_devpath_end_init ( EFI_DEVICE_PATH_PROTOCOL *path ) {
-
-	efi_devpath_init ( path, END_DEVICE_PATH_TYPE,
-			   END_ENTIRE_DEVICE_PATH_SUBTYPE, sizeof ( *path ) );
-}
-
-extern EFI_DEVICE_PATH_PROTOCOL *
-efi_devpath_end ( EFI_DEVICE_PATH_PROTOCOL *path );
-
-#endif /* _EFIPATH_H */
diff --git a/src/efireloc.c b/src/efireloc.c
deleted file mode 100644
index e0736cd..0000000
--- a/src/efireloc.c
+++ /dev/null
@@ -1,548 +0,0 @@
-/*
- * Copyright (C) 2014 Michael Brown <mbrown@fensystems.co.uk>.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of the
- * License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
- * 02110-1301, USA.
- */
-
-/**
- * @file
- *
- * EFI relocations
- *
- * Derived from iPXE's elf2efi.c
- *
- */
-
-#define PACKAGE "wimboot"
-#define PACKAGE_VERSION VERSION
-#include <stdint.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <unistd.h>
-#include <errno.h>
-#include <sys/mman.h>
-#include <fcntl.h>
-#include <getopt.h>
-#include <bfd.h>
-#include "efi.h"
-#include "efi/IndustryStandard/PeImage.h"
-#include "wimboot.h"
-
-#define eprintf(...) fprintf ( stderr, __VA_ARGS__ )
-
-/** PE header maximum length
- *
- * This maximum length is guaranteed by the fact that the PE headers
- * have to fit entirely before the start of the bzImage header.
- */
-#define PE_HEADER_LEN 512
-
-/** .reloc section index */
-#define RELOC_SECTION_INDEX 3
-
-/** PE relocations */
-struct pe_relocs {
-	struct pe_relocs *next;
-	unsigned long start_rva;
-	unsigned int used_relocs;
-	unsigned int total_relocs;
-	uint16_t *relocs;
-};
-
-/** Command-line options */
-struct options {
-	/** Verbosity */
-	int verbosity;
-};
-
-/**
- * Allocate memory
- *
- * @v len		Length of memory to allocate
- * @ret ptr		Pointer to allocated memory
- */
-static void * xmalloc ( size_t len ) {
-	void *ptr;
-
-	ptr = malloc ( len );
-	if ( ! ptr ) {
-		eprintf ( "Could not allocate %zd bytes\n", len );
-		exit ( 1 );
-	}
-
-	return ptr;
-}
-
-/**
- * Write to file
- *
- * @v fd		File descriptor
- * @v data		Data
- * @v len		Length of data
- */
-static void xwrite ( int fd, const void *data, size_t len ) {
-	ssize_t written;
-
-	written = write ( fd, data, len );
-	if ( written < 0 ) {
-		eprintf ( "Could not write %zd bytes: %s\n",
-			  len, strerror ( errno ) );
-		exit ( 1 );
-	}
-	if ( ( size_t ) written != len ) {
-		eprintf ( "Wrote only %zd of %zd bytes\n", written, len );
-		exit ( 1 );
-	}
-}
-
-/**
- * Seek to file position
- *
- * @v fd		File descriptor
- * @v offset		Offset
- * @v whence		Origin
- */
-static void xlseek ( int fd, off_t offset, int whence ) {
-	off_t pos;
-
-	pos = lseek ( fd, offset, whence );
-	if ( pos < 0 ) {
-		eprintf ( "Could not seek: %s\n", strerror ( errno ) );
-		exit ( 1 );
-	}
-}
-
-/**
- * Close file
- *
- * @v fd		File descriptor
- */
-static void xclose ( int fd ) {
-
-	if ( close ( fd ) < 0 ) {
-		eprintf ( "Could not close: %s\n", strerror ( errno ) );
-		exit ( 1 );
-	}
-}
-
-/**
- * Open input BFD file
- *
- * @v filename		File name
- * @ret ibfd		BFD file
- */
-static bfd * open_input_bfd ( const char *filename ) {
-	bfd *bfd;
-
-	/* Open the file */
-	bfd = bfd_openr ( filename, NULL );
-	if ( ! bfd ) {
-		eprintf ( "Cannot open %s: ", filename );
-		bfd_perror ( NULL );
-		exit ( 1 );
-	}
-
-	/* The call to bfd_check_format() must be present, otherwise
-	 * we get a segfault from later BFD calls.
-	 */
-	if ( ! bfd_check_format ( bfd, bfd_object ) ) {
-		eprintf ( "%s is not an object file: ", filename );
-		bfd_perror ( NULL );
-		exit ( 1 );
-	}
-
-	return bfd;
-}
-
-/**
- * Read symbol table
- *
- * @v bfd		BFD file
- */
-static asymbol ** read_symtab ( bfd *bfd ) {
-	long symtab_size;
-	asymbol **symtab;
-	long symcount;
-
-	/* Get symbol table size */
-	symtab_size = bfd_get_symtab_upper_bound ( bfd );
-	if ( symtab_size < 0 ) {
-		bfd_perror ( "Could not get symbol table upper bound" );
-		exit ( 1 );
-	}
-
-	/* Allocate and read symbol table */
-	symtab = xmalloc ( symtab_size );
-	symcount = bfd_canonicalize_symtab ( bfd, symtab );
-	if ( symcount < 0 ) {
-		bfd_perror ( "Cannot read symbol table" );
-		exit ( 1 );
-	}
-
-	return symtab;
-}
-
-/**
- * Read relocation table
- *
- * @v bfd		BFD file
- * @v symtab		Symbol table
- * @v section		Section
- * @v symtab		Symbol table
- * @ret reltab		Relocation table
- */
-static arelent ** read_reltab ( bfd *bfd, asymbol **symtab,
-				asection *section ) {
-	long reltab_size;
-	arelent **reltab;
-	long numrels;
-
-	/* Get relocation table size */
-	reltab_size = bfd_get_reloc_upper_bound ( bfd, section );
-	if ( reltab_size < 0 ) {
-		bfd_perror ( "Could not get relocation table upper bound" );
-		exit ( 1 );
-	}
-
-	/* Allocate and read relocation table */
-	reltab = xmalloc ( reltab_size );
-	numrels = bfd_canonicalize_reloc ( bfd, section, reltab, symtab );
-	if ( numrels < 0 ) {
-		bfd_perror ( "Cannot read relocation table" );
-		exit ( 1 );
-	}
-
-	return reltab;
-}
-
-/**
- * Generate entry in PE relocation table
- *
- * @v pe_reltab		PE relocation table
- * @v rva		RVA
- * @v size		Size of relocation entry
- */
-static void generate_pe_reloc ( struct pe_relocs **pe_reltab,
-				unsigned long rva, size_t size ) {
-	unsigned long start_rva;
-	uint16_t reloc;
-	struct pe_relocs *pe_rel;
-	uint16_t *relocs;
-
-	/* Construct */
-	start_rva = ( rva & ~0xfff );
-	reloc = ( rva & 0xfff );
-	switch ( size ) {
-	case 8:
-		reloc |= 0xa000;
-		break;
-	case 4:
-		reloc |= 0x3000;
-		break;
-	case 2:
-		reloc |= 0x2000;
-		break;
-	default:
-		eprintf ( "Unsupported relocation size %zd\n", size );
-		exit ( 1 );
-	}
-
-	/* Locate or create PE relocation table */
-	for ( pe_rel = *pe_reltab ; pe_rel ; pe_rel = pe_rel->next ) {
-		if ( pe_rel->start_rva == start_rva )
-			break;
-	}
-	if ( ! pe_rel ) {
-		pe_rel = xmalloc ( sizeof ( *pe_rel ) );
-		memset ( pe_rel, 0, sizeof ( *pe_rel ) );
-		pe_rel->next = *pe_reltab;
-		*pe_reltab = pe_rel;
-		pe_rel->start_rva = start_rva;
-	}
-
-	/* Expand relocation list if necessary */
-	if ( pe_rel->used_relocs < pe_rel->total_relocs ) {
-		relocs = pe_rel->relocs;
-	} else {
-		pe_rel->total_relocs = ( pe_rel->total_relocs ?
-					 ( pe_rel->total_relocs * 2 ) : 256 );
-		relocs = xmalloc ( pe_rel->total_relocs *
-				   sizeof ( pe_rel->relocs[0] ) );
-		memset ( relocs, 0,
-			 pe_rel->total_relocs * sizeof ( pe_rel->relocs[0] ) );
-		memcpy ( relocs, pe_rel->relocs,
-			 pe_rel->used_relocs * sizeof ( pe_rel->relocs[0] ) );
-		free ( pe_rel->relocs );
-		pe_rel->relocs = relocs;
-	}
-
-	/* Store relocation */
-	pe_rel->relocs[ pe_rel->used_relocs++ ] = reloc;
-}
-
-/**
- * Process relocation record
- *
- * @v bfd		BFD file
- * @v section		Section
- * @v rel		Relocation entry
- * @v pe_reltab		PE relocation table to fill in
- */
-static void process_reloc ( bfd *bfd __unused, asection *section, arelent *rel,
-			    struct pe_relocs **pe_reltab ) {
-	reloc_howto_type *howto = rel->howto;
-	asymbol *sym = *(rel->sym_ptr_ptr);
-	unsigned long offset = ( bfd_get_section_vma ( bfd, section ) +
-				 rel->address - BASE_ADDRESS );
-
-	if ( bfd_is_abs_section ( sym->section ) ) {
-		/* Skip absolute symbols; the symbol value won't
-		 * change when the object is loaded.
-		 */
-	} else if ( strcmp ( howto->name, "R_X86_64_64" ) == 0 ) {
-		/* Generate an 8-byte PE relocation */
-		generate_pe_reloc ( pe_reltab, offset, 8 );
-	} else if ( ( strcmp ( howto->name, "R_386_32" ) == 0 ) ||
-		    ( strcmp ( howto->name, "R_X86_64_32" ) == 0 ) ||
-		    ( strcmp ( howto->name, "R_X86_64_32S" ) == 0 ) ) {
-		/* Generate a 4-byte PE relocation */
-		generate_pe_reloc ( pe_reltab, offset, 4 );
-	} else if ( ( strcmp ( howto->name, "R_386_16" ) == 0 ) ||
-		    ( strcmp ( howto->name, "R_X86_64_16" ) == 0 ) ) {
-		/* Generate a 2-byte PE relocation */
-		generate_pe_reloc ( pe_reltab, offset, 2 );
-	} else if ( ( strcmp ( howto->name, "R_386_PC32" ) == 0 ) ||
-		    ( strcmp ( howto->name, "R_X86_64_PC32" ) == 0 ) ||
-		    ( strcmp ( howto->name, "R_X86_64_PLT32" ) == 0 ) ) {
-		/* Skip PC-relative relocations; all relative offsets
-		 * remain unaltered when the object is loaded.
-		 */
-	} else {
-		eprintf ( "Unrecognised relocation type %s\n", howto->name );
-		exit ( 1 );
-	}
-}
-
-/**
- * Calculate size of binary PE relocation table
- *
- * @v fh		File handle
- * @v pe_reltab		PE relocation table
- * @ret size		Size of binary table
- */
-static size_t output_pe_reltab ( int fd, struct pe_relocs *pe_reltab ) {
-	EFI_IMAGE_BASE_RELOCATION header;
-	struct pe_relocs *pe_rel;
-	static uint8_t pad[16];
-	unsigned int num_relocs;
-	size_t size;
-	size_t pad_size;
-	size_t total_size = 0;
-
-	for ( pe_rel = pe_reltab ; pe_rel ; pe_rel = pe_rel->next ) {
-		num_relocs = ( ( pe_rel->used_relocs + 1 ) & ~1 );
-		size = ( sizeof ( header ) +
-			 ( num_relocs * sizeof ( uint16_t ) ) );
-		pad_size = ( ( -size ) & ( sizeof ( pad ) - 1 ) );
-		size += pad_size;
-		header.VirtualAddress = pe_rel->start_rva;
-		header.SizeOfBlock = size;
-		xwrite ( fd, &header, sizeof ( header ) );
-		xwrite ( fd, pe_rel->relocs,
-			 ( num_relocs * sizeof ( uint16_t ) ) );
-		xwrite ( fd, pad, pad_size );
-		total_size += size;
-	}
-
-	return total_size;
-}
-
-/**
- * Add relocation information
- *
- * @v elf_name		ELF file name
- * @v pe_name		PE file name
- */
-static void efireloc ( const char *elf_name, const char *pe_name ) {
-	struct pe_relocs *pe_reltab = NULL;
-	int fd;
-	EFI_IMAGE_DOS_HEADER *dos;
-	EFI_IMAGE_OPTIONAL_HEADER_UNION *nt;
-	EFI_IMAGE_DATA_DIRECTORY *data_dir;
-	EFI_IMAGE_SECTION_HEADER *pe_sections;
-	UINT32 *image_size;
-	bfd *bfd;
-	asymbol **symtab;
-	asection *section;
-	arelent **reltab;
-	arelent **rel;
-	size_t reloc_len;
-
-	/* Open the output file */
-	fd = open ( pe_name, O_RDWR );
-	if ( fd < 0 ) {
-		eprintf ( "Could not open %s: %s\n",
-			  pe_name, strerror ( errno ) );
-		exit ( 1 );
-	}
-
-	/* Map the output file header */
-	dos = mmap ( NULL, PE_HEADER_LEN, ( PROT_READ | PROT_WRITE ),
-		     MAP_SHARED, fd, 0 );
-	if ( ! dos ) {
-		eprintf ( "Could not mmap %s: %s\n",
-			  pe_name, strerror ( errno ) );
-		exit ( 1 );
-	}
-
-	/* Locate the modifiable fields within the output file header */
-	nt = ( ( ( void * ) dos ) + dos->e_lfanew );
-	if ( nt->Pe32.FileHeader.Machine == EFI_IMAGE_MACHINE_IA32 ) {
-		image_size = &nt->Pe32.OptionalHeader.SizeOfImage;
-		data_dir = nt->Pe32.OptionalHeader.DataDirectory;
-		pe_sections = ( ( void * ) ( &nt->Pe32 + 1 ) );
-	} else if ( nt->Pe32Plus.FileHeader.Machine == EFI_IMAGE_MACHINE_X64 ) {
-		image_size = &nt->Pe32Plus.OptionalHeader.SizeOfImage;
-		data_dir = nt->Pe32Plus.OptionalHeader.DataDirectory;
-		pe_sections = ( ( void * ) ( &nt->Pe32Plus + 1 ) );
-	} else {
-		eprintf ( "Unrecognised machine type\n" );
-		exit ( 1 );
-	}
-
-	/* Open the input file */
-	bfd = open_input_bfd ( elf_name );
-	symtab = read_symtab ( bfd );
-
-	/* For each input section, create the appropriate relocation records */
-	for ( section = bfd->sections ; section ; section = section->next ) {
-		/* Discard non-allocatable sections */
-		if ( ! ( bfd_get_section_flags ( bfd, section ) & SEC_ALLOC ) )
-			continue;
-		/* Add relocations from this section */
-		reltab = read_reltab ( bfd, symtab, section );
-		for ( rel = reltab ; *rel ; rel++ )
-			process_reloc ( bfd, section, *rel, &pe_reltab );
-		free ( reltab );
-	}
-
-	/* Close input file */
-	bfd_close ( bfd );
-
-	/* Generate relocation section */
-	xlseek ( fd, 0, SEEK_END );
-	reloc_len = output_pe_reltab ( fd, pe_reltab );
-
-	/* Modify image header */
-	*image_size += reloc_len;
-	data_dir[EFI_IMAGE_DIRECTORY_ENTRY_BASERELOC].Size = reloc_len;
-	pe_sections[RELOC_SECTION_INDEX].Misc.VirtualSize = reloc_len;
-	pe_sections[RELOC_SECTION_INDEX].SizeOfRawData = reloc_len;
-
-	/* Unmap output file header */
-	munmap ( dos, PE_HEADER_LEN );
-
-	/* Close output file */
-	xclose ( fd );
-}
-
-/**
- * Print help
- *
- * @v program_name	Program name
- */
-static void print_help ( const char *program_name ) {
-	eprintf ( "Syntax: %s [-v|-q] infile outfile\n", program_name );
-}
-
-/**
- * Parse command-line options
- *
- * @v argc		Argument count
- * @v argv		Argument list
- * @v opts		Options structure to populate
- */
-static int parse_options ( const int argc, char **argv,
-			   struct options *opts ) {
-	int c;
-
-	while (1) {
-		int option_index = 0;
-		static struct option long_options[] = {
-			{ "help", 0, NULL, 'h' },
-			{ "verbose", 0, NULL, 'v' },
-			{ "quiet", 0, NULL, 'q' },
-			{ 0, 0, 0, 0 }
-		};
-
-		if ( ( c = getopt_long ( argc, argv, "hvq",
-					 long_options,
-					 &option_index ) ) == -1 ) {
-			break;
-		}
-
-		switch ( c ) {
-		case 'v':
-			opts->verbosity++;
-			break;
-		case 'q':
-			if ( opts->verbosity )
-				opts->verbosity--;
-			break;
-		case 'h':
-			print_help ( argv[0] );
-			exit ( 0 );
-		case '?':
-		default:
-			exit ( 2 );
-		}
-	}
-	return optind;
-}
-
-/**
- * Main program
- *
- * @v argc		Number of arguments
- * @v argv		Command-line arguments
- * @ret rc		Return status code
- */
-int main ( int argc, char **argv ) {
-	struct options opts = {
-		.verbosity = 0,
-	};
-	int infile_index;
-	const char *infile;
-	const char *outfile;
-
-	/* Initialise libbfd */
-	bfd_init();
-
-	/* Parse command-line arguments */
-	infile_index = parse_options ( argc, argv, &opts );
-	if ( argc != ( infile_index + 2 ) ) {
-		print_help ( argv[0] );
-		exit ( 2 );
-	}
-	infile = argv[infile_index];
-	outfile = argv[infile_index + 1];
-
-	/* Add relocation information */
-	efireloc ( infile, outfile );
-
-	return 0;
-}
diff --git a/src/i386.i b/src/i386.i
deleted file mode 100644
index 099070d..0000000
--- a/src/i386.i
+++ /dev/null
@@ -1 +0,0 @@
-	.code32
diff --git a/src/prefix.S b/src/prefix.S
index d19cc29..eab97d6 100644
--- a/src/prefix.S
+++ b/src/prefix.S
@@ -27,11 +27,7 @@
 #include "wimboot.h"
 
 /* Refer to i386 symbols as needed */
-#if __x86_64__
-#define i386(symbol) __i386_ ## symbol
-#else
 #define i386(symbol) symbol
-#endif
 
 /** Standard number of setup sectors */
 #define SETUP_SECTS 4
@@ -57,149 +53,12 @@
 /** 32 bit protected mode flat data segment */
 #define PREFIX_FLAT_DS 0x18
 
-/* PE header architecture-dependent values */
-#if __x86_64__
-	.equ	coff_machine, 0x8664
-	.equ	coff_characteristics, 0x2022
-	.equ	opt_magic, 0x20b
-#else
-	.equ	coff_machine, 0x014c
-	.equ	coff_characteristics, 0x2102
-	.equ	opt_magic, 0x10b
-#endif
-
 	.text
 	.code16
 	.arch	i386
 	.org	0
 	.section ".prefix", "ax", @progbits
 
-	.org	0
-_prefix:
-mz_header:
-	.ascii	"MZ"
-	.org	mz_header + 0x3c
-mz_lfanew:
-	.word	( pe_header - _prefix )
-	.equ	mz_header_len, . - mz_header
-	.size	mz_header,     . - mz_header
-
-	.org	0x40
-pe_header:
-	.ascii	"PE"			/* Signature */
-	.byte	0, 0
-	.word	coff_machine		/* Machine */
-	.word	4			/* NumberOfSections */
-	.long	0x10d1a884		/* TimeDateStamp */
-	.long	0			/* PointerToSymbolTable */
-	.long	0			/* NumberOfSymbols */
-	.word	( opt_header_len + data_directory_len ) /*SizeOfOptionalHeader*/
-	.word	coff_characteristics	/* Characteristics */
-	.equ	pe_header_len, . - pe_header
-	.size	pe_header,     . - pe_header
-opt_header:
-	.word	opt_magic		/* Magic */
-	.byte	42			/* MajorLinkerVersion */
-	.byte	42			/* MinorLinkerVersion */
-	.long	_text_total_len		/* SizeOfCode */
-	.long	_data_total_len		/* SizeOfInitializedData */
-	.long	_bss_total_len		/* SizeOfUninitializedData */
-	.long	( efi_main - BASE_ADDRESS ) /* AddressOfEntryPoint */
-	.long	( _text - BASE_ADDRESS ) /* BaseOfCode */
-#if __x86_64__
-	.quad	BASE_ADDRESS		/* ImageBase */
-#else
-	.long	( _data - BASE_ADDRESS ) /* BaseOfData */
-	.long	BASE_ADDRESS		/* ImageBase */
-#endif
-	.long	0x10			/* SectionAlignment */
-	.long	0x10			/* FileAlignment */
-	.word	0			/* MajorOperatingSystemVersion */
-	.word	0			/* MinorOperatingSystemVersion */
-	.word	0			/* MajorImageVersion */
-	.word	0			/* MinorImageVersion */
-	.word	0			/* MajorSubsystemVersion */
-	.word	0			/* MinorSubsystemVersion */
-	.long	0			/* Win32VersionValue */
-	.long	( _end - BASE_ADDRESS )	/* SizeOfImage */
-	.long	_prefix_len		/* SizeOfHeaders */
-	.long	0			/* Checksum */
-	.word	0x0a			/* Subsystem */
-	.word	0			/* DllCharacteristics */
-#if __x86_64__
-	.quad	0			/* SizeOfStackReserve */
-	.quad	0			/* SizeOfStackCommit */
-	.quad	0			/* SizeOfHeapReserve */
-	.quad	0			/* SizeOfHeapCommit */
-#else
-	.long	0			/* SizeOfStackReserve */
-	.long	0			/* SizeOfStackCommit */
-	.long	0			/* SizeOfHeapReserve */
-	.long	0			/* SizeOfHeapCommit */
-#endif
-	.long	0			/* LoaderFlags */
-	.long	16			/* NumberOfRvaAndSizes */
-	.equ	opt_header_len,	. - opt_header
-	.size	opt_header,	. - opt_header
-data_directory:
-	.org	data_directory + ( 8 * 5 )
-directory_entry_reloc:
-	.long	( _reloc - BASE_ADDRESS )
-	.long	0
-	.org	data_directory + ( 8 * 6 )
-directory_entry_debug:
-	.long	( debug - _prefix )
-	.long	debug_len
-	.org	data_directory + ( 8 * 16 )
-	.equ	data_directory_len, . - data_directory
-	.size	data_directory,	    . - data_directory
-coff_sections:
-	.ascii	".bss16"		/* Name */
-	.byte	0, 0
-	.long	_bss16_len		/* Misc.VirtualSize */
-	.long	( _bss16 - BASE_ADDRESS ) /* VirtualAddress */
-	.long	0			/* SizeOfRawData */
-	.long	0			/* PointerToRawData */
-	.long	0			/* PointerToRelocations */
-	.long	0			/* PointerToLinenumbers */
-	.word	0			/* NumberOfRelocations */
-	.word	0			/* NumberOfLinenumbers */
-	.long	0xc8000080		/* Characteristics */
-	.ascii	".payload"		/* Name */
-	.long	_payload_len		/* Misc.VirtualSize */
-	.long	( _payload - BASE_ADDRESS ) /* VirtualAddress */
-	.long	_payload_len		/* SizeOfRawData */
-	.long	_payload_pos		/* PointerToRawData */
-	.long	0			/* PointerToRelocations */
-	.long	0			/* PointerToLinenumbers */
-	.word	0			/* NumberOfRelocations */
-	.word	0			/* NumberOfLinenumbers */
-	.long	0xe80000e0		/* Characteristics */
-	.ascii	".bss"			/* Name */
-	.byte	0, 0, 0, 0
-	.long	_bss_len		/* Misc.VirtualSize */
-	.long	( _bss - BASE_ADDRESS )	/* VirtualAddress */
-	.long	0			/* SizeOfRawData */
-	.long	0			/* PointerToRawData */
-	.long	0			/* PointerToRelocations */
-	.long	0			/* PointerToLinenumbers */
-	.word	0			/* NumberOfRelocations */
-	.word	0			/* NumberOfLinenumbers */
-	.long	0xc8000080		/* Characteristics */
-	.ascii	".reloc"		/* Name */
-	.byte	0, 0
-	.long	0			/* Misc.VirtualSize */
-	.long	( _reloc - BASE_ADDRESS ) /* VirtualAddress */
-	.long	0			/* SizeOfRawData */
-	.long	_reloc_pos		/* PointerToRawData */
-	.long	0			/* PointerToRelocations */
-	.long	0			/* PointerToLinenumbers */
-	.word	0			/* NumberOfRelocations */
-	.word	0			/* NumberOfLinenumbers */
-	.long	0x48000040		/* Characteristics */
-	.equ	coff_sections_len, . - coff_sections
-	.size	coff_sections,	   . - coff_sections
-
 	.org	0x1f1
 setup_sects:
 	.byte	SETUP_SECTS
@@ -221,10 +80,6 @@ header:
 version:
 	.word	0x203	/* Version 2.03 */
 
-	.org	0x20e
-kernel_version:
-	.word	( version_string - _prefix - 0x200 )
-
 	.org	0x211
 loadflags:
 	.byte	LOADED_HIGH
@@ -245,30 +100,27 @@ cmd_line_ptr:
 ramdisk_max:
 	.long	0x7fffffff
 
-version_string:
-	.asciz	VERSION
-
 	/* Setup code */
 setup:
 	/* Reset %cs so that labels work */
 	pushw	%ds
-	pushw	$( 1f - _prefix )
+	pushw	$1f
 	lret
 1:
 	/* Fix up GDT */
 	xorl	%eax, %eax
 	movw	%cs, %ax
 	shll	$4, %eax
-	addl	%eax, ( gdt - _prefix + 2 )
-	addl	%eax, ( gdt - _prefix + PREFIX_CS + 2 )
+	addl	%eax, ( gdt + 2 )
+	addl	%eax, ( gdt + PREFIX_CS + 2 )
 
 	/* Switch to protected mode and jump to startup code */
 	cli
-	data32 lgdt ( gdt - _prefix )
+	data32 lgdt gdt
 	movl	%cr0, %eax
 	orb	$CR0_PE, %al
 	movl	%eax, %cr0
-	data32 ljmp $PREFIX_CS, $( 1f - _prefix )
+	data32 ljmp $PREFIX_CS, $1f
 	.code32
 1:
 	/* Load data segment registers */
@@ -296,11 +148,11 @@ setup:
 	rep movsb
 
 	/* Copy parameters required by runtime */
-	movl	%cs:( cmd_line_ptr - _prefix ), %eax
+	movl	%cs:cmd_line_ptr, %eax
 	movl	%eax, i386(cmdline)
-	movl	%cs:( ramdisk_image - _prefix ), %eax
+	movl	%cs:ramdisk_image, %eax
 	movl	%eax, i386(initrd)
-	movl	%cs:( ramdisk_size - _prefix ), %eax
+	movl	%cs:ramdisk_size, %eax
 	movl	%eax, i386(initrd_len)
 
 	/* Jump to payload */
@@ -310,7 +162,7 @@ setup:
 	/* Global descriptor table */
 gdt:
 	.word	gdt_limit
-	.long	( gdt - _prefix )
+	.long	gdt
 	/* 32-bit protected mode code segment based at real-mode %cs:0000 */
 	.org	( gdt + PREFIX_CS )
 	.word	0xffff, 0
@@ -326,26 +178,4 @@ gdt:
 	.size	gdt, . - gdt
 	.equ	gdt_limit, . - gdt - 1
 
-debug:
-	.long	0			/* Characteristics */
-	.long	0x10d1a884		/* TimeDateStamp */
-	.word	0			/* MajorVersion */
-	.word	0			/* MinorVersion */
-	.long	2			/* Type */
-	.long	debug_rsds_len		/* SizeOfData */
-	.long	( debug_rsds - _prefix ) /* RVA */
-	.long	( debug_rsds - _prefix ) /* FileOffset */
-	.equ	debug_len, . - debug
-	.size	debug,	   . - debug
-debug_rsds:
-	.ascii	"RSDS"			/* Signature */
-	.long	0			/* Unknown */
-	.long	0			/* Unknown2 */
-	.long	0			/* Unknown3 */
-	.long	0			/* Unknown4 */
-	.long	0			/* Unknown5 */
-	.asciz	"wimboot.efi"
-	.equ	debug_rsds_len, . - debug_rsds
-	.size	debug_rsds,	. - debug_rsds
-
 	.org	( ( SETUP_SECTS + 1 ) * SECTOR_SIZE )
diff --git a/src/script.lds b/src/script.lds
index 64643bd..86796e9 100644
--- a/src/script.lds
+++ b/src/script.lds
@@ -1,23 +1,18 @@
 SECTIONS {
 
-	/* Align sections to keep PE tools happy */
-	alignment = 16;
-
-	/* Virtual addresses start at 0x20000 */
-	. = 0x20000;
-	_start = .;
-
 	/* bzImage prefix */
-	_prefix_pos = 0;
-	.prefix : AT ( _prefix_pos ) {
+	.prefix : AT ( 0 ) {
 		_prefix = .;
 		*(.prefix)
 		*(.prefix.*)
-		. = ALIGN ( alignment );
 		_eprefix = .;
 	}
 	_prefix_len = ABSOLUTE ( _eprefix ) - ABSOLUTE ( _prefix );
 
+	/* Payload code executes at 0x20000 */
+	. = 0x20000;
+	_start = .;
+
 	/* Real-mode uninitialised data section */
 	.bss16 ( NOLOAD ) : {
 		_bss16 = .;
@@ -25,44 +20,29 @@ SECTIONS {
 		*(.stack16.*)
 		*(.bss16)
 		*(.bss16.*)
-		. = ALIGN ( alignment );
 		_ebss16 = .;
 	}
 	_bss16_len = ABSOLUTE ( _ebss16 ) - ABSOLUTE ( _bss16 );
 
 	/* Payload section */
-	_payload_pos = ( _prefix_pos + _prefix_len );
-	.payload : AT ( _payload_pos ) {
+	.payload : AT ( _prefix_len ) {
 		_payload = .;
 		/* Portions that must be accessible in 16-bit modes */
-		_text16 = .;
 		*(.text16)
 		*(.text16.*)
-		_etext16 = .;
-		_data16 = .;
 		*(.rodata16)
 		*(.rodata16.*)
 		*(.data16)
 		*(.data16.*)
-		_edata16 = .;
 		/* Portions that need not be accessible in 16-bit modes */
-		_text = .;
 		*(.text)
 		*(.text.*)
-		_etext = .;
-		_data = .;
 		*(.rodata)
 		*(.rodata.*)
 		*(.data)
 		*(.data.*)
-		. = ALIGN ( alignment );
-		_edata = .;
 		_epayload = .;
 	}
-	_text16_len = ABSOLUTE ( _etext16 ) - ABSOLUTE ( _text16 );
-	_data16_len = ABSOLUTE ( _edata16 ) - ABSOLUTE ( _data16 );
-	_text_len = ABSOLUTE ( _etext ) - ABSOLUTE ( _text );
-	_data_len = ABSOLUTE ( _edata ) - ABSOLUTE ( _data );
 	_payload_len = ABSOLUTE ( _epayload ) - ABSOLUTE ( _payload );
 
 	/* bootmgr.exe hardcodes the address 0x30000 for use as a
@@ -84,21 +64,12 @@ SECTIONS {
 		*(COMMON)
 		*(.stack)
 		*(.stack.*)
-		. = ALIGN ( alignment );
 		_ebss = .;
 	}
 	_bss_len = ABSOLUTE ( _ebss ) - ABSOLUTE ( _bss );
 
-	/* Relocations section */
-	_reloc_pos = ( _payload_pos + _payload_len );
-	_reloc = .;
-
 	_end = .;
 
-	_text_total_len = ( _text_len + _text16_len );
-	_data_total_len = ( _data_len + _data16_len );
-	_bss_total_len = ( _bss_len + _bss16_len );
-
 	/* Symbols required by i386.x86_64 objects */
 	__i386__start = _start;
 	__i386__end = _end;
diff --git a/src/sha1.c b/src/sha1.c
index fc5c061..7c7679f 100644
--- a/src/sha1.c
+++ b/src/sha1.c
@@ -36,6 +36,11 @@
 #include "rotate.h"
 #include "sha1.h"
 
+#if __GNUC__ >= 9
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Waddress-of-packed-member"
+#endif
+
 /** SHA-1 variables */
 struct sha1_variables {
 	/* This layout matches that of struct sha1_digest_data,
@@ -230,3 +235,7 @@ void sha1_final ( void *ctx, void *out ) {
 	memcpy ( out, &context->ddd.dd.digest,
 		 sizeof ( context->ddd.dd.digest ) );
 }
+
+#if __GNUC__ >= 9
+#pragma GCC diagnostic pop
+#endif
diff --git a/src/stdio.c b/src/stdio.c
index c119bd3..c1f0e8a 100644
--- a/src/stdio.c
+++ b/src/stdio.c
@@ -28,7 +28,6 @@
 #include <string.h>
 #include "bootapp.h"
 #include "wimboot.h"
-#include "efi.h"
 
 /**
  * Print character to console
@@ -36,31 +35,17 @@
  * @v character		Character to print
  */
 int putchar ( int character ) {
-	EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL *conout;
 	struct bootapp_callback_params params;
-	wchar_t wbuf[2];
 
 	/* Convert LF to CR,LF */
 	if ( character == '\n' )
 		putchar ( '\r' );
 
-	/* Print character to bochs debug port */
-	__asm__ __volatile__ ( "outb %b0, $0xe9"
-			       : : "a" ( character ) );
-
-	/* Print character to EFI/BIOS console as applicable */
-	if ( efi_systab ) {
-		conout = efi_systab->ConOut;
-		wbuf[0] = character;
-		wbuf[1] = 0;
-		conout->OutputString ( conout, wbuf );
-	} else {
-		memset ( &params, 0, sizeof ( params ) );
-		params.vector.interrupt = 0x10;
-		params.eax = ( 0x0e00 | character );
-		params.ebx = 0x0007;
-		call_interrupt ( &params );
-	}
+	memset ( &params, 0, sizeof ( params ) );
+	params.vector.interrupt = 0x10;
+	params.eax = ( 0x0e00 | character );
+	params.ebx = 0x0007;
+	call_interrupt ( &params );
 
 	return 0;
 }
@@ -71,26 +56,14 @@ int putchar ( int character ) {
  * @ret character	Character
  */
 int getchar ( void ) {
-	EFI_BOOT_SERVICES *bs;
-	EFI_SIMPLE_TEXT_INPUT_PROTOCOL *conin;
-	EFI_INPUT_KEY key;
-	UINTN index;
 	struct bootapp_callback_params params;
 	int character;
 
 	/* Get character */
-	if ( efi_systab ) {
-		bs = efi_systab->BootServices;
-		conin = efi_systab->ConIn;
-		bs->WaitForEvent ( 1, &conin->WaitForKey, &index );
-		conin->ReadKeyStroke ( conin, &key );
-		character = key.UnicodeChar;
-	} else {
-		memset ( &params, 0, sizeof ( params ) );
-		params.vector.interrupt = 0x16;
-		call_interrupt ( &params );
-		character = params.al;
-	}
+	memset ( &params, 0, sizeof ( params ) );
+	params.vector.interrupt = 0x16;
+	call_interrupt ( &params );
+	character = params.al;
 
 	return character;
 }
diff --git a/src/vdisk.c b/src/vdisk.c
index 7885a5b..27433c1 100644
--- a/src/vdisk.c
+++ b/src/vdisk.c
@@ -35,6 +35,11 @@
 /** Virtual files */
 struct vdisk_file vdisk_files[VDISK_MAX_FILES];
 
+#if __GNUC__ >= 9
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Waddress-of-packed-member"
+#endif
+
 /**
  * Read from virtual Master Boot Record
  *
@@ -663,3 +668,7 @@ void vdisk_patch_file ( struct vdisk_file *file,
 	/* Allow patch method to update file length */
 	patch ( file, NULL, 0, 0 );
 }
+
+#if __GNUC__ >= 9
+#pragma GCC diagnostic pop
+#endif
diff --git a/src/wimboot.h b/src/wimboot.h
index 2356992..b2fbcd9 100644
--- a/src/wimboot.h
+++ b/src/wimboot.h
@@ -129,23 +129,9 @@ static inline void bochsbp ( void ) {
 /* Mark parameter as unused */
 #define __unused __attribute__ (( unused ))
 
-#if __x86_64__
-static inline void call_real ( struct bootapp_callback_params *params ) {
-	/* Not available in 64-bit mode */
-	( void ) params;
-}
-static inline void call_interrupt ( struct bootapp_callback_params *params ) {
-	/* Not available in 64-bit mode */
-	( void ) params;
-}
-static inline void reboot ( void ) {
-	/* Not available in 64-bit mode */
-}
-#else
 extern void call_real ( struct bootapp_callback_params *params );
 extern void call_interrupt ( struct bootapp_callback_params *params );
 extern void __attribute__ (( noreturn )) reboot ( void );
-#endif
 
 extern void __attribute__ (( noreturn, format ( printf, 1, 2 ) ))
 die ( const char *fmt, ... );
diff --git a/src/wimboot.i386 b/src/wimboot.i386
deleted file mode 100755
index 2c5b921e0ae9b496cf0bdd39320f9f1a8aa2af80..0000000000000000000000000000000000000000
GIT binary patch
literal 0
HcmV?d00001

literal 27776
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
QlU`1GJ?Q{WwJE><4VlQ65C8xG

diff --git a/src/wimboot.x86_64 b/src/wimboot.x86_64
deleted file mode 100755
index 326e77e65d1dd86b32ecff244099b0f3311e9063..0000000000000000000000000000000000000000
GIT binary patch
literal 0
HcmV?d00001

literal 42752
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

diff --git a/src/wimpatch.c b/src/wimpatch.c
index c57b6e7..004929c 100644
--- a/src/wimpatch.c
+++ b/src/wimpatch.c
@@ -39,6 +39,11 @@
 /** Directory into which files are injected */
 #define WIM_INJECT_DIR "\\Windows\\System32"
 
+#if __GNUC__ >= 9
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Waddress-of-packed-member"
+#endif
+
 struct wim_patch;
 
 /** A region of a patched WIM file */
@@ -791,3 +796,7 @@ void patch_wim ( struct vdisk_file *file, void *data, size_t offset,
 		}
 	}
 }
+
+#if __GNUC__ >= 9
+#pragma GCC diagnostic pop
+#endif
diff --git a/src/x86_64.i b/src/x86_64.i
deleted file mode 100644
index f821626..0000000
--- a/src/x86_64.i
+++ /dev/null
@@ -1 +0,0 @@
-	.code64
-- 
2.27.0

